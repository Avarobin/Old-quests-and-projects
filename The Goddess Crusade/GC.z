//-----------------------
// INIT STUFF
//-----------------------

import "std.zh"
import "The Goddess Crusade/ffcscript.zh"
import "The Goddess Crusade/ghost.zh"

const int ITM_HyliasLight = 143;
const int ITM_DinsFire = 144;
const int ITM_NayrusWater = 145;
const int ITM_FaroresWind = 146;
const int ITM_HyliasSpirit = 147;
const int ITM_DinsEarth = 148;
const int ITM_NayrusTime = 149;
const int ITM_FaroresNature = 150;

const int LWType_HyliasLight = 1;
const int LWType_Armos = 2;
const int LWType_NayrusTimeEnd = 3;
const int LWType_FaroresNature = 4;
const int LWType_CarriedBlock = 5;
const int LWType_FireThatOpens = 6;
const int LWType_RealBlast = 7;

const int GLW_DinsFire = 0;
const int GLW_HyliasArmos = 1;
const int GLW_DinsEarth = 2;
const int GLW_NayrusTime = 3;
const int GLW_FaroresNature = 4;
const int GLW_Force1 = 5;
const int GLW_Force2 = 6;
const int GLW_Force3 = 7;
const int GLW_SacredFlame = 8;

const int CMB_AWarpA = 2560;
const int CMB_AWarpB = 2561;
const int CMB_AWarpC = 2562;
const int CMB_AWarpD = 2563;
const int CMB_ScriptSolid = 2564;
const int CMB_ArmosOff = 908;
const int CMB_Savepoint = 912;

const int MP_StartingRegen = 1.5;
const int MP_BaseAcc = 0.03;
const int MP_MaxRegen = 6;
const int MP_BaseCD = 150;
const int MP_Cost_HyliasLight = 32; // = 1
const int MP_Cost_DinsFire = 64; // = 2
const int MP_Cost_NayrusWater = 32; // = 1
const int MP_Cost_NayrusWaterStun = 32; // = 1
const int MP_Cost_DinsEarth = 128; // = 4
const int MP_Cost_NayrusTime = 96; // = 3
const int MP_Cost_FaroresNature = 64; // = 2

const int ColourText1 = 0x01; // unselected text colour
const int ColourText2 = 0x76; // selected text colour

const int CR_SpiritGemPower = 7; // CR_SCRIPT1
const int CR_SpiritGemWisdom = 8; // CR_SCRIPT2
const int CR_SpiritGemCourage = 9; // CR_SCRIPT3
const int CR_FlameToken = 10; // CR_SCRIPT4

const int LinkPastArraySize = 90;
int LinkPastX[90];
int LinkPastY[90];
int LinkPastZ[90];
int LinkPastDir[90];
int LinkPastTile[90];

int G[1000];
const int G_LinksCurrDMap = 0;
const int G_LinksCurrScreen = 1;
const int G_LinkCasting = 2;
const int G_ScreenInitAfterScroll = 3;
const int G_Tictoc16 = 4;
const int G_LinkPower = 5;
const int G_HyliasLightCD = 6;
const int G_DinsFireActive = 7;
const int G_DinsFireRadius = 8;
const int G_DinsFireDegrees = 9;
const int G_DinsFireX = 10;
const int G_DinsFireY = 11;
const int G_Unusedxddd = 12;
const int G_NayrusWaterState = 13;
const int G_NayrusWaterCD = 14;
const int G_NayrusWaterDir = 15;
const int G_NayrusWaterCharge = 16;
const int G_NayrusWaterX = 17;
const int G_NayrusWaterY = 18;
const int G_NayrusWaterYOffset = 19;
const int G_NayrusWaterTicToc20 = 20;
const int G_HyliasSpiritState = 21;
const int G_HyliasSpiritCD = 22;
const int G_HyliasSpiritMagicDir = 23;
const int G_HyliasSpiritMagicX = 24;
const int G_HyliasSpiritMagicY = 25;
const int G_HyliasSpiritParticles = 26;
const int G_HyliasArmosDir = 27;
const int G_HyliasArmosX = 28;
const int G_HyliasArmosY = 29;
const int G_ContinueDMap = 30;
const int G_ContinueScreen = 31;
const int G_FaroresWindActive = 32;
const int G_FaroresWindY = 33;
const int G_DinsEarthState = 34;
const int G_Unusedxdddd = 35;
const int G_DinsEarthX = 36;
const int G_DinsEarthY = 37;
const int G_DinsEarthTimer = 38;
const int G_DinsEarthZ = 39;
const int G_DinsEarthGravity = 40;
const int G_NayrusTimeActive = 41;
const int G_NayrusTimePos = 42;
const int G_NayrusTimeSpeed = 43;
const int G_NayrusTimeAcc = 44;
const int G_FaroresNatureState = 45;
const int G_FaroresNatureCD = 46;
const int G_FaroresNatureDir = 47;
const int G_FaroresNatureX = 48;
const int G_FaroresNatureY = 49;
const int G_FaroresNatureVar = 50;
const int G_LinkBusy = 51;
const int G_MP_Val = 52;
const int G_MP_RegenLock = 53;
const int G_MP_CD = 54;
const int G_MP_Regen = 55;
const int G_GameStopFreeze = 56;
const int G_SavepointHeal = 57;
const int G_CurrentArea = 58;
const int G_ForceGemActive = 59;
const int G_ForceGemSpeed = 60;
const int G_ForceGemDegrees = 61;
const int G_ForceGemRadius = 62;
const int G_PedestalCutsceneState = 63;
const int G_DungeonLightState = 64;
const int G_LightSwitchLocked = 65;
const int G_ButtonLockHoldA = 66;
const int G_ButtonLockHoldB = 67;
const int G_LinkSacredFlameState = 69;
const int G_FlamePadNum = 70;
const int G_FlamePadScreens = 71;
// 71 - 100 = FlamePadScreens
const int G_DungeonFanFloor = 101;
const int G_LinkExtraPush = 102;
const int G_WaterModX = 103;
const int G_WaterModY = 104;
const int G_WaterModSpeed = 105;
const int G_WaterModFFCID = 106;
const int G_WaterModPos = 107;
const int G_WaterModState = 108;
const int G_Timestop = 109;
const int G_HotRoomFrames = 110;
const int G_EndlessPaths = 111;
// 111 - 113 = G_EndlessPaths
const int G_FaroresWindHold = 114;
const int G_FaroresWindDegrees = 115;
const int G_MPBaseCDReduction = 116;
const int G_DeluxeMagic = 117;
const int G_DungeonLightAmbience = 118;

//-----------------------
// FUNCTIONS
//-----------------------

/*
	int music[256];
	Game->GetDMapMusicFilename(16, music);
	Game->PlayEnhancedMusic(music, Game->GetDMapMusicTrack(16));

	if ( RectCollision(Link->X, Link->Y+2, Link->X+15, Link->Y+15, gx+5, gy+5, gx+10, gy+10) ) {
		eweapon e = FireEWeapon(EW_SCRIPT10, Link->X+InFrontX(Link->Dir, 12), Link->Y+InFrontY(Link->Dir, 12), 0, 0, 6, -1, -1, EWF_UNBLOCKABLE);
		e->Dir = Link->Dir;
		e->DrawYOffset = -1000;
		SetEWeaponLifespan(e, EWL_TIMER, 1);
		SetEWeaponDeathEffect(e, EWD_VANISH, 0);
	}
*/

/*
void DrawStringWithFullOutline(int l, int x, int y, int f, int c, int b, int s, int t, int o) {
	Screen->DrawString(l, x-1, y-1, f, 0x0F, b, s, t, o);
	Screen->DrawString(l, x, y-1, f, 0x0F, b, s, t, o);
	Screen->DrawString(l, x+1, y-1, f, 0x0F, b, s, t, o);
	Screen->DrawString(l, x-1, y, f, 0x0F, b, s, t, o);
	Screen->DrawString(l, x+1, y, f, 0x0F, b, s, t, o);
	Screen->DrawString(l, x-1, y+1, f, 0x0F, b, s, t, o);
	Screen->DrawString(l, x, y+1, f, 0x0F, b, s, t, o);
	Screen->DrawString(l, x+1, y+1, f, 0x0F, b, s, t, o);
	Screen->DrawString(l, x, y, f, c, -1, s, t, o);
}
*/

bool InputItem(int ID) {
	if ( (GetEquipmentA() == ID && Link->InputA) || (GetEquipmentB() == ID && Link->InputB) )
		return true;
	return false;
}
bool PressItem(int ID) {
	if ( (GetEquipmentA() == ID && Link->PressA) || (GetEquipmentB() == ID && Link->PressB) )
		return true;
	return false;
}
bool LinkCanAttack() {
	if ( Link->Action != LA_NONE && Link->Action != LA_WALKING )
		return false;
	if ( MooshPit[_MP_FALLSTATE] > 0 || Link->Z > 0 || G[G_LinkBusy] > 0 )
		return false;
	return true;
}

void SetLinkCasting(bool v) {
	if ( v ) {
		G[G_LinkCasting] = 1;
		Link->DrawYOffset = -1000;
	}
	else {
		G[G_LinkCasting] = 0;
		Link->DrawYOffset = 0;
		Link->Action = LA_NONE;
	}
}

void LoseMP(int v) {
	G[G_MP_Val] -= v;
	if ( G[G_MP_Val] < 0 )
		G[G_MP_Val] = 0;
	G[G_MP_CD] = MP_BaseCD - G[G_MPBaseCDReduction];
	G[G_MP_Regen] = MP_StartingRegen;
}
void RestoreMP(int v) {
	G[G_MP_Val] += v;
	Link->MP += v;
	if ( G[G_MP_Val] > Game->MCounter[CR_MAGIC] )
		G[G_MP_Val] = Game->MCounter[CR_MAGIC];
	if ( Link->MP > Game->MCounter[CR_MAGIC] )
		Link->MP = Game->MCounter[CR_MAGIC];
}

const int AreaID_Necluda = 0;
const int AreaID_Hylia = 1;
const int AreaID_Gerudo = 2;
const int AreaID_Zonai = 3;
const int AreaID_Faron = 4;
const int AreaID_Hebra = 5;
const int AreaID_Lanayru = 6;
const int AreaID_Akkala = 7;
const int AreaID_Zorana = 8;
const int AreaID_Eldin = 9;
const int AreaID_HerosSanctum = 10;
const int AreaID_TempleOfHylia = 11;
const int AreaID_TempleOfDin = 12;
const int AreaID_TempleOfNayru = 13;
const int AreaID_TempleOfFarore = 14;
const int AreaID_TrialOfBeginnings = 15;
const int AreaID_TrialOfSpikes = 16;
const int AreaID_TrialOfStrength = 17;

int GetAreaID() {
	int d = Game->GetCurDMap();
	if ( d == 1 )
		return AreaID_Necluda;
	if ( d == 2 )
		return AreaID_Hylia;
	if ( d == 3 )
		return AreaID_Gerudo;
	if ( d == 4 )
		return AreaID_Zonai;
	if ( d == 5 )
		return AreaID_Faron;
	if ( d == 6 )
		return AreaID_Hebra;
	if ( d == 7 )
		return AreaID_Lanayru;
	if ( d == 8 )
		return AreaID_Akkala;
	if ( d == 9 )
		return AreaID_Zorana;
	if ( d == 10 )
		return AreaID_Eldin;
	if ( d == 12 || d == 13 )
		return AreaID_HerosSanctum;
	if ( d == 20 )
		return AreaID_TempleOfHylia;
	if ( d == 22 )
		return AreaID_TempleOfDin;
	if ( d == 25 )
		return AreaID_TempleOfNayru;
	if ( d == 27 )
		return AreaID_TempleOfFarore;
	if ( d == 37 )
		return AreaID_TrialOfBeginnings;
	if ( d == 38 )
		return AreaID_TrialOfSpikes;
	if ( d == 39 )
		return AreaID_TrialOfStrength;
	return -1;
}

void RandomDrop(int x, int y) {
	int rng = Rand(100);
	int id = -1;
	if ( rng < 20 )
		id = 0; // rupee 1
	if ( id != -1 ) {
		item itm = CreateItemAt(id, x, y);
		itm->Pickup = IP_TIMEOUT;
	}
}

bool PointWithinRect(int px, int py, int x1, int y1, int x2, int y2) {
	if ( px < x1 ) return false;
	if ( px > x2 ) return false;
	if ( py < y1 ) return false;
	if ( py > y2 ) return false;
	return true;
}

int RotateDirNum(int d, int n){
	for (int i = 0; i < n; ++i) {
		if ( d == DIR_UP )
			d = DIR_RIGHT;
		else if ( d == DIR_RIGHT )
			d = DIR_DOWN;
		else if ( d == DIR_DOWN )
			d = DIR_LEFT;
		else
			d = DIR_UP;
	}
	return d;
}

bool PositionIsOk(int x, int y, int condition) {
	if ( condition == 0 ) { // not solid and not offscreen
		if ( !PointWithinRect(x, y, 0, 0, 255, 175) )
			return false;
		return !Screen->isSolid(x, y);
	}
	else if ( condition == 1 ) { // not solid
		return !Screen->isSolid(x, y);
	}
	else if ( condition == 2 ) { // armos
		if ( !PointWithinRect(x, y, 0, 0, 255, 175) )
			return false;
		if ( PointWithinRect(x, y, Link->X+2, Link->Y+8, Link->X+13, Link->Y+20) )
			return false;
		if ( Screen->ComboT[ComboAt(x, y)] == CT_NOGROUNDENEMY )
			return false;
		if ( Screen->ComboF[ComboAt(x, y)] == 67 )
			return false;
		if ( Screen->LayerMap(1) != -1 ) {
			if ( GetLayerComboS(1, ComboAt(x, y)) != 0000b )
				return false;
		}
		if ( Screen->LayerMap(2) != -1 ) {
			if ( GetLayerComboS(2, ComboAt(x, y)) != 0000b )
				return false;
		}
		return Screen->ComboS[ComboAt(x, y)] == 0000b;
	}
	else if ( condition == 3 ) { // nayrus bubble movement
		if ( !PointWithinRect(x, y, 1, 9, 254, 174) )
			return false;
		return !Screen->isSolid(x, y);
	}
	else if ( condition == 4 ) { // not solid, not offscreen and not in a moving block
		if ( !PointWithinRect(x, y, 0, 0, 255, 175) )
			return false;
		if ( Screen->MovingBlockX != -1 ) {
			if ( PointWithinRect(x, y, Screen->MovingBlockX, Screen->MovingBlockY, Screen->MovingBlockX+15, Screen->MovingBlockY+15) )
				return false;
		}
		return !Screen->isSolid(x, y);
	}
}

// less accurate when using objects bigger than 16x16
bool CanWalkLegit(int x1, int y1, int x2, int y2, int dir, int step, int condition) {
	int xC = (x1+x2) * 0.5;
	int yC = (y1+y2) * 0.5;
	if ( dir == DIR_UP ) {
		return PositionIsOk(x1, y1-step, condition) && PositionIsOk(xC, y1-step, condition) && PositionIsOk(x2, y1-step, condition);
	}
	else if ( dir == DIR_DOWN ) {
		return PositionIsOk(x1, y2+step, condition) && PositionIsOk(xC, y2+step, condition) && PositionIsOk(x2, y2+step, condition);
	}
	else if ( dir == DIR_LEFT ) {
		return PositionIsOk(x1-step, y1, condition) && PositionIsOk(x1-step, yC, condition) && PositionIsOk(x1-step, y2, condition);
	}
	else {
		return PositionIsOk(x2+step, y1, condition) && PositionIsOk(x2+step, yC, condition) && PositionIsOk(x2+step, y2, condition);
	}
}

void FastTileLWeapon(int x, int y, int t, int c, int d) {
	lweapon wpn = CreateLWeaponAt(LW_SCRIPT10, x, y);
	wpn->DrawYOffset = 0;
	wpn->Tile = t;
	wpn->CSet = c;
	wpn->CollDetection = false;
	wpn->DeadState = d;
}

void UncoverOverworld() {
	if ( Game->GetCurMap() >= 4 && Game->GetCurMap() <= 13 ) {
		int s = Game->GetCurScreen();
		for (int i = 4; i <= 13; ++i) {
			Game->SetScreenState(i, s, ST_VISITED, true);
		}
	}
}

void DungeonLightPitsInit() {
	// place the pits on background layers
	for (int m = 18; m < 22; m += 3) { // maps
		for (int s = 0x25; s < 0x6B; ++s) { // screens
			if ( s % 16 > 10 )
				s += 10;
			for (int p = 0; p < 176; ++p) { // positions
				if ( Game->GetComboType(m, s, p) == CT_NOGROUNDENEMY ) {
					Game->SetComboData(m+2, s, p, Game->GetComboData(m, s, p));
				}
			}
		}
	}
}

void SetLightCombos() {
	int id;
	if ( G[G_DungeonLightState] == 1 ) {
		CopyTile(13226, 13224);
		for (int m = 19; m < 23; m += 3) { // maps
			for (int s = 0x25; s < 0x6B; ++s) { // screens
				if ( s % 16 > 10 )
					s += 10;
				for (int p = 0; p < 176; ++p) { // positions
					id = Game->GetComboData(m, s, p);
					if ( id >= 1308 && id <= 1315 ) {
						Game->SetComboData(m, s, p, id - 8);
					}
				}
			}
		}
	}
	else {
		CopyTile(13225, 13224);
		for (int m = 19; m < 23; m += 3) { // maps
			for (int s = 0x25; s < 0x6B; ++s) { // screens
				if ( s % 16 > 10 )
					s += 10;
				for (int p = 0; p < 176; ++p) { // positions
					id = Game->GetComboData(m, s, p);
					if ( id >= 1300 && id <= 1307 ) {
						Game->SetComboData(m, s, p, id + 8);
					}
				}
			}
		}
	}
}

void UpdateFlamePads() {
	int s; int m;
	for (int i = 71; i <= 100; ++i) {
		if ( G[i] > 0 ) {
			s = G[i];
			m = 24;
			if ( s >= 128 ) {
				s -= 128;
				m = 27;
			}
			for (int p = 0; p < 176; ++p) {
				if ( Game->GetComboData(m, s, p) == 1320 ) {
					Game->SetComboData(m, s, p, 1322);
					Game->SetComboData(m, s, p+1, 1323);
					Game->SetComboData(m, s, p+16, 1326);
					Game->SetComboData(m, s, p+17, 1327);
					break;
				}
			}
		}
	}
}

void SetTimestop() {
	int curdmap = Game->GetCurDMap();
	if ( G[G_Timestop] == 1 ) {
		int music[256];
		Game->GetDMapMusicFilename(32, music);
		if ( curdmap == 25 || curdmap == 26 )
			Game->PlayEnhancedMusic(music, Game->GetDMapMusicTrack(32));
		for(int i=25; i<=26; i++)
			Game->SetDMapEnhancedMusic(i, music, Game->GetDMapMusicTrack(32));
		
		Link->Item[19] = false;
	}
	else {
		int music[256];
		Game->GetDMapMusicFilename(31, music);
		if ( curdmap == 25 || curdmap == 26 )
			Game->PlayEnhancedMusic(music, Game->GetDMapMusicTrack(31));
		for(int i=25; i<=26; i++)
			Game->SetDMapEnhancedMusic(i, music, Game->GetDMapMusicTrack(31));
		
		Link->Item[19] = true;
	}
}

void SetFanFloor() {
	CopyTile(14401-1+G[G_DungeonFanFloor], 14400);
}

void ScreenAndContinueInit() {
	int i;
	Link->DrawXOffset = 0;
	Link->DrawYOffset = 0;
	Link->CollDetection = true;
	Link->Invisible = false;
	
	for (i = 0; i < LinkPastArraySize; ++i) {
		LinkPastX[i] = -1;
		LinkPastY[i] = -1;
		LinkPastZ[i] = -1;
		LinkPastDir[i] = -1;
		LinkPastTile[i] = -1;
	}
	
	G[G_LinkCasting] = 0;
	G[G_HyliasLightCD] = 0;
	G[G_DinsFireActive] = 0;
	G[G_NayrusWaterState] = 0;
	G[G_NayrusWaterCD] = 0;
	G[G_HyliasSpiritState] = 0;
	G[G_HyliasSpiritCD] = 0;
	G[G_FaroresWindActive] = 0;
	G[G_NayrusTimeActive] = 0;
	G[G_DinsEarthState] = 0;
	G[G_FaroresNatureState] = 0;
	G[G_SavepointHeal] = 0;
	G[G_ButtonLockHoldA] = 0;
	G[G_ButtonLockHoldB] = 0;
	G[G_LinkExtraPush] = 1;
	G[G_HotRoomFrames] = 0;
	G[G_FaroresWindHold] = 0;
	
	if ( ScreenFlag(SF_VIEW, SFV_NOSUBSCREEN) > 0 ) { // if it's a cutscene
		G[G_ForceGemActive] = 0;
		G[G_DeluxeMagic] = 0;
	}
	
	if ( Game->GetCurDMap() < 22 || Game->GetCurDMap() > 24 )
		G[G_LinkSacredFlameState] = 0;
	
	if ( G[G_LinkSacredFlameState] == 0 )
		G[G_MP_Val] = Game->MCounter[CR_MAGIC];
	else
		G[G_MP_Val] = 0;
	G[G_MP_RegenLock] = 0;
	G[G_MP_CD] = 0;
	G[G_MP_Regen] = MP_StartingRegen;
	
	for (i=0; i<176; ++i) {
		if ( Screen->LayerMap(2) != -1 ) {
			SetLayerComboD(2, i, 0); // remove all layer 2 combos
		}
		
		if ( G[G_CurrentArea] == AreaID_TempleOfHylia ) {
			if ( GetLayerComboD(1, i) >= 1300 && GetLayerComboD(1, i) <= 1303 ) // remove pits for light combos
				Screen->ComboD[i] = 0;
		}
	}
	
	UncoverOverworld();
	
	// do timestopped things
	if ( G[G_Timestop] == 1 ) {
		for (i=0; i<176; ++i) {
			if ( Screen->ComboD[i] == 620 )
				Screen->ComboD[i] = 2868;
			if ( Screen->ComboD[i] >= 924 && Screen->ComboD[i] <= 939 ) {
				if ( Screen->ComboT[i] == CT_NONE )
					Screen->ComboD[i] = 2870;
				else
					Screen->ComboD[i] = 2871;
			}
			if ( Screen->ComboD[i] == 555 )
				Screen->ComboD[i] = 2872;
			if ( Screen->ComboD[i] >= 464 && Screen->ComboD[i] <= 487 )
				Screen->ComboD[i] += 2412;
			if ( (Screen->ComboD[i] >= 1376 && Screen->ComboD[i] <= 1379) || (Screen->ComboD[i] >= 1384 && Screen->ComboD[i] <= 1387) )
				Screen->ComboD[i] += 4;
		}
		
		for (i=1; i<=32; ++i) {
			ffc f = Screen->LoadFFC(i);
			if ( f->Data == 909 ) {
				f->Vx = 0;
				f->Vy = 0;
				f->Data = 2869;
				SetLayerComboD(2, ComboAt(f->X+8, f->Y+8), 2874);
			}
		}
	}
}

//-----------------------
// QUEST SCRIPTS
//-----------------------

global script Init{
	void run(){
		G[G_LinkPower] = 4;
		G[G_CurrentArea] = -1;
		G[G_DungeonFanFloor] = 1;
		
		G[G_ContinueDMap] = Game->GetCurDMap();
		G[G_ContinueScreen] = Game->GetCurScreen();
	}
}

global script ActiveScript{
	void run(){
		for (int i = 0; i <= 6; ++i) {
			Screen->SetRenderTarget(i);
			Screen->Rectangle(0, 0, 0, 512, 512, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
		}
		Screen->SetRenderTarget(-1);
		
		G[G_LinksCurrDMap] = -1;
		G[G_LinksCurrScreen] = -1;
		G[G_ForceGemActive] = 0;
		G[G_DeluxeMagic] = 0;
		G[G_LinkSacredFlameState] = 0;
		
		LinkMovement_Init();
		StartGhostZH();
		MooshPit_Init();
		ScreenAndContinueInit();
		G[G_ScreenInitAfterScroll] = 1;
		
		DungeonLightPitsInit();
		SetLightCombos();
		UpdateFlamePads();
		SetFanFloor();
		SetTimestop();
		setIcePhysics(1.5, CT_SCRIPT5, IC_CUSTOM20, GRID_HALF, false);
		
		lweapon GLW[9];
		while(true){
			UpdateGhostZH1();
			MooshPit_Update();
			LinkMovement_Update1();
			
			G[G_Tictoc16] ++;
			G[G_Tictoc16] %= 16;
			
			if ( G[G_LinkBusy] > 0 )
				G[G_LinkBusy] --;
			
			// button lock
			if ( G[G_ButtonLockHoldA] == 1 ) {
				if ( !Link->InputA )
					G[G_ButtonLockHoldA] = 0;
				Link->PressA = false;
				Link->InputA = false;
			}
			if ( G[G_ButtonLockHoldB] == 1 ) {
				if ( !Link->InputB )
					G[G_ButtonLockHoldB] = 0;
				Link->PressB = false;
				Link->InputB = false;
			}
			
			// Game over script
			if ( Link->HP == 0 ) {
				Link->HP = Link->MaxHP;
				if ( G[G_GameStopFreeze] == 0 ) {
					G[G_GameStopFreeze] = 1;
					Link->X = Clamp(Link->X, 0, 240);
					Link->Y = Clamp(Link->Y, 0, 160);
					Link->PitWarp(0, 0x70);
				}
			}
			if ( G[G_GameStopFreeze] > 0 ) {
				NoAction();
				Link->InputStart = false;
				Link->InputMap = false;
				Link->HitDir = -1;
				Link->CollDetection = false;
			}
			
			// GLOBAL SCREEN SCRIPTS
			if ( Link->Action != LA_SCROLLING ) {
				// Screen Init After Scroll
				if ( G[G_ScreenInitAfterScroll] == 0 ) {
					G[G_ScreenInitAfterScroll] = 1;
					
					for(int i=0; i<176; ++i){
						// set up armoses
						if ( Screen->ComboD[i] == CMB_ArmosOff ) {
							Screen->ComboD[i] = 0;
							SetLayerComboD(2, i, CMB_ScriptSolid);
							lweapon Armos = CreateLWeaponAt(LW_SCRIPT1, ComboX(i), ComboY(i));
							Armos->DrawYOffset = 0;
							Armos->UseSprite(95);
							Armos->Tile = Armos->OriginalTile+DIR_DOWN;
							Armos->CollDetection = false;
							Armos->Misc[0] = LWType_Armos;
						}
						
						// register continue and savepoint
						if ( Screen->ComboD[i] == CMB_Savepoint ) {
							G[G_ContinueDMap] = Game->GetCurDMap();
							G[G_ContinueScreen] = Game->GetCurScreen();
						}
						
						// auto waterstream ffcs
						if ( Screen->ComboD[i] >= 1376 && Screen->ComboD[i] <= 1383 ) {
							ffc f = Screen->LoadFFC(RunFFCScript(34, 0));
							f->X = ComboX(i);
							f->Y = ComboY(i);
						}
						// waterstreams
						if ( Screen->ComboD[i] >= 1384 && Screen->ComboD[i] <= 1391 ) {
							SetLayerComboD(2, i, Screen->ComboD[i]);
							SetLayerComboC(2, i, Screen->ComboC[i]);
							Screen->ComboD[i] = 0;
						}
					}
					
					// auto chest ffcs
					if ( CountFFCsRunning(5) == 0 ) {
						for(int i=0; i<176; ++i){
							if ( Screen->ComboT[i] == CT_CHEST2 ) {
								ffc f = Screen->LoadFFC(RunFFCScript(5, 0));
								f->X = ComboX(i);
								f->Y = ComboY(i);
								break;
							}
						}
					}
					
					// area change name display
					int areaID = GetAreaID();
					if ( areaID != -1 && areaID != G[G_CurrentArea] ) {
						if ( ScreenFlag(SF_VIEW, SFV_NOSUBSCREEN) == 0 ) { // if it's not a cutscene
							int args[8] = { areaID };
							RunFFCScript(15, args);
							G[G_CurrentArea] = areaID;
						}
					}
					
					// dungeon light ambience
					if ( G[G_CurrentArea] == AreaID_TempleOfHylia ) {
						if ( G[G_GameStopFreeze] == 0 )
							RunFFCScript(20, 0);
					}
					
					// hot room
					if ( Game->GetCurMap() == 30 )
						RunFFCScript(35, 0);
					else
						G[G_HotRoomFrames] = 0;
					
				} // End of Screen Init After Scroll
				
				for (int i = Screen->NumNPCs(); i >= 1; --i) {
					npc enem = Screen->LoadNPC(i);
					if ( enem->HP <= 0 ) {
						// spirited darknut
						if ( enem->ID == 92 && enem->Misc[0] == 0 ) {
							enem->Misc[0] = 1;
							CreateNPCAt(179, enem->X, enem->Y);
						}
					}
				}
				
				// for all eweapons
				for (int i = Screen->NumEWeapons(); i >= 1; --i) {
					eweapon wpn = Screen->LoadEWeapon(i);
					if ( G[G_LinkSacredFlameState] == 1 ) { //turn of all fire colldetection
						if ( wpn->ID == EW_FIRE )
							wpn->CollDetection = false;
					}
					
					if ( wpn->ID == EW_FIRE ) {
						// draw gel firetrails on layer 1
						if ( wpn->Tile == 27560 )
							Screen->FastTile(1, wpn->X, wpn->Y, 27626, 8, OP_OPAQUE);
						else if ( wpn->Tile == 27561 )
							Screen->FastTile(1, wpn->X, wpn->Y, 27627, 8, OP_OPAQUE);
					}
				}
				
				// for all lweapons
				for (int i = Screen->NumLWeapons(); i >= 1; --i) {
					lweapon wpn = Screen->LoadLWeapon(i);
					
					if ( wpn->ID == LW_SCRIPT1 ) {
						if ( wpn->Misc[0] == LWType_HyliasLight ) {
							wpn->DeadState = WDS_ALIVE;
							
							if ( wpn->Misc[1] > 6 ) {
								wpn->Misc[1] = Rand(2);
								lweapon Sparkle = CreateLWeaponAt(LW_SPARKLE, wpn->X, wpn->Y);
								Sparkle->DrawYOffset = 0;
								Sparkle->UseSprite(30);
							}
							else
								wpn->Misc[1] ++;
							
							int v = ComboAt(wpn->X+8, wpn->Y+8);
							if ( Screen->ComboT[v] == CT_RIGHTSTATUE || Screen->ComboT[v] == CT_LEFTSTATUE ) {
								if ( wpn->Misc[2] != v ) { // if this isnt the last mirror touched
									if ( (PointWithinRect(wpn->X+8, wpn->Y+8, ComboX(v), ComboY(v)+4, ComboX(v)+15, ComboY(v)+10) && (wpn->Dir == DIR_UP || wpn->Dir == DIR_DOWN))
									|| (PointWithinRect(wpn->X+8, wpn->Y+8, ComboX(v)+4, ComboY(v), ComboX(v)+10, ComboY(v)+15) && (wpn->Dir == DIR_LEFT || wpn->Dir == DIR_RIGHT)) ) {
										wpn->Misc[2] = v;
										if ( Screen->ComboT[v] == CT_RIGHTSTATUE ) {
											if ( wpn->Dir == DIR_UP )
												wpn->Dir = DIR_LEFT;
											else if ( wpn->Dir == DIR_DOWN )
												wpn->Dir = DIR_RIGHT;
											else if ( wpn->Dir == DIR_LEFT )
												wpn->Dir = DIR_UP;
											else if ( wpn->Dir == DIR_RIGHT )
												wpn->Dir = DIR_DOWN;
										}
										else {
											if ( wpn->Dir == DIR_UP )
												wpn->Dir = DIR_RIGHT;
											else if ( wpn->Dir == DIR_DOWN )
												wpn->Dir = DIR_LEFT;
											else if ( wpn->Dir == DIR_LEFT )
												wpn->Dir = DIR_DOWN;
											else if ( wpn->Dir == DIR_RIGHT )
												wpn->Dir = DIR_UP;
										}
										if ( wpn->Dir == DIR_UP || wpn->Dir == DIR_DOWN )
											wpn->X = ComboX(v);
										else
											wpn->Y = ComboY(v);
										wpn->UseSprite(88);
										wpn->Tile += wpn->Dir;
									}
								}
							}
							else if ( Screen->isSolid(wpn->X+8, wpn->Y+8) || !PointWithinRect(wpn->X+8, wpn->Y+8, 8, 8, 247, 167) ) {
								wpn->DeadState = WDS_DEAD;
								lweapon Sparkle = CreateLWeaponAt(LW_SPARKLE, wpn->X, wpn->Y);
								Sparkle->DrawYOffset = 0;
								Sparkle->UseSprite(89);
							}
						}
						else if ( wpn->Misc[0] == LWType_NayrusTimeEnd ) {
							wpn->Misc[1] += 2;
							int calculation;
							for (int i = 0; i < 3; ++i) {
								calculation = wpn->Misc[1]+i*5;
								if ( calculation > 1 && calculation < 20 )
									Screen->Circle(4, wpn->X+8, wpn->Y+8, calculation, 0x01, 1, 0, 0, 0, false, OP_OPAQUE);
							}
							if ( wpn->Misc[1] > 30 )
								wpn->DeadState = WDS_DEAD;
						}
						else if ( wpn->Misc[0] == LWType_FaroresNature ) {
							if ( Screen->isSolid(wpn->X+8, wpn->Y+8) || !PointWithinRect(wpn->X+8, wpn->Y+8, 8, 8, 247, 167) ) {
								wpn->DeadState = WDS_DEAD;
							}
						}
						else if ( wpn->Misc[0] == LWType_CarriedBlock ) {
							if ( CanWalk(wpn->X, wpn->Y, wpn->Dir, 2, true) ) {
								wpn->X += VectorX(2, DirAngle(wpn->Dir));
								wpn->Y += VectorY(2, DirAngle(wpn->Dir));
							}
							else {
								int pos = ComboAt(wpn->X+8, wpn->Y+8);
								int combo = 896;
								if ( wpn->Tile == 13091 )
									combo = 1395; // im just starting to realise how HORRIBLY hardcoded everything in this codebase is
								Screen->ComboD[pos] = combo;
								Screen->ComboC[pos] = 2;
								wpn->DeadState = WDS_DEAD;
							}
						}
						else if ( wpn->Misc[0] == LWType_FireThatOpens ) {
							if ( wpn->Misc[2] >= 45 ) {
								if ( wpn->Misc[1] == 1 ) {
									Game->PlaySound(27);
									Screen->TriggerSecrets();
									Screen->State[ST_SECRET] = true;
								}
								else {
									Screen->ComboD[ComboAt(wpn->X+8, wpn->Y+8)] = 61;
									RandomDrop(wpn->X, wpn->Y);
								}
								wpn->DeadState = WDS_DEAD;
							}
							else
								wpn->Misc[2] ++;
						}
						else if ( wpn->Misc[0] == LWType_RealBlast ) {
							wpn->DeadState = WDS_ALIVE;
							if ( wpn->Misc[1] == 1 )
								wpn->Misc[1] = 0;
						}
						
						if ( wpn->Misc[15] > 0 ) {
							wpn->Misc[15] --;
							if ( wpn->Misc[15] == 0 )
								wpn->DeadState = WDS_DEAD;
						}
					}
					else if ( wpn->ID == LW_SPARKLE ) {
						if ( wpn->Misc[15] > 0 ) {
							Screen->FastTile(wpn->Misc[15], wpn->X, wpn->Y, wpn->Tile, wpn->CSet, OP_OPAQUE);
						}
					}
				}
				
				// ice script
				doIcePhysics();
				if ( isSliding() ) {
					G[G_LinkBusy] = 2;
					NoAction();
				}
				
				// Hylias Light
				if ( PressItem(ITM_HyliasLight) ) {
					if ( LinkCanAttack() && G[G_HyliasLightCD] == 0 ) {
						if ( G[G_MP_Val] >= MP_Cost_HyliasLight ) {
							LoseMP(MP_Cost_HyliasLight);
							Game->PlaySound(63);
							G[G_HyliasLightCD] = 20;
							Link->Action = LA_ATTACKING;
							
							lweapon HyliasLight = CreateLWeaponAt(LW_SCRIPT1, Link->X+VectorX(12, DirAngle(Link->Dir)), Link->Y+VectorY(12, DirAngle(Link->Dir)));
							HyliasLight->DrawYOffset = 0;
							HyliasLight->UseSprite(88);
							HyliasLight->Tile += Link->Dir;
							HyliasLight->Dir = Link->Dir;
							HyliasLight->Step = 300;
							HyliasLight->Damage = G[G_LinkPower];
							HyliasLight->Misc[0] = LWType_HyliasLight;
							HyliasLight->Misc[1] = 8;
						}
						else // Not enough MP
							Game->PlaySound(64);
					}
				}
				if ( G[G_HyliasLightCD] > 0 )
					G[G_HyliasLightCD] --;
				
				// Dins Fire
				if ( PressItem(ITM_DinsFire) ) {
					if ( LinkCanAttack() && G[G_DinsFireActive] == 0 && G[G_MP_Val] >= MP_Cost_DinsFire ) {
						if ( G[G_MP_Val] >= MP_Cost_DinsFire ) {
							LoseMP(MP_Cost_DinsFire);
							Game->PlaySound(36);
							Link->Action = LA_ATTACKING;
							G[G_DinsFireActive] = 1;
							G[G_DinsFireRadius] = 16;
							G[G_DinsFireDegrees] = 45;
							G[G_DinsFireX] = Link->X+VectorX(12, DirAngle(Link->Dir));
							G[G_DinsFireY] = Link->Y+VectorY(12, DirAngle(Link->Dir));
						}
						else // Not enough MP
							Game->PlaySound(64);
					}
					if ( LinkCanAttack() && G[G_DinsFireActive] == 2 ) {
						Game->PlaySound(3);
						G[G_DinsFireActive] = 0;
						Link->Action = LA_ATTACKING;
						
						if ( GLW[GLW_DinsFire]->isValid() )
							GLW[GLW_DinsFire]->DeadState = WDS_DEAD;
						lweapon Explosion = CreateLWeaponAt(LW_BOMBBLAST, G[G_DinsFireX], G[G_DinsFireY]);
						Explosion->DrawYOffset = 0;
						Explosion->CollDetection = false;
						
						lweapon RealBlast = CreateLWeaponAt(LW_SCRIPT1, G[G_DinsFireX], G[G_DinsFireY]);
						RealBlast->Tile = 180;
						RealBlast->HitXOffset = -8;
						RealBlast->HitYOffset = -8;
						RealBlast->HitWidth = 32;
						RealBlast->HitHeight = 32;
						RealBlast->Dir = -1;
						RealBlast->Damage = (G[G_LinkPower]+2)*2;
						RealBlast->Misc[0] = LWType_RealBlast;
						RealBlast->Misc[1] = 1;
						RealBlast->Misc[15] = 24;
						
						// break certain combos
						int x; int y;
						for (int i = 0; i < 3; ++i) {
							for (int j = 0; j < 3; ++j) {
								x = G[G_DinsFireX]-6 + i*14;
								y = G[G_DinsFireY]-6 + j*14;
								if ( PointWithinRect(x, y, 0, 0, 255, 175) ) {
									if ( Screen->ComboD[ComboAt(x, y)] == 910 ) // cracked dungeon blocks
										Screen->ComboD[ComboAt(x, y)] ++;
									if ( Screen->ComboD[ComboAt(x, y)] == 1124 ) { // rocks
										if ( Screen->ComboF[ComboAt(x, y)] == 16 ) {
											Game->PlaySound(27);
											Screen->TriggerSecrets();
											Screen->State[ST_SECRET] = true;
										}
										else {
											Screen->ComboD[ComboAt(x, y)] = 14;
											RandomDrop(ComboX(ComboAt(x, y)), ComboY(ComboAt(x, y)));
										}
									}
									if ( Screen->ComboD[ComboAt(x, y)] == 1087 ) { // bombable mountain entries
										Game->PlaySound(27);
										Screen->TriggerSecrets();
										Screen->State[ST_SECRET] = true;
									}
								}
							}
						}
					}
				}
				if ( G[G_DinsFireActive] == 1 ) {
					int t = 23728;
					if ( G[G_Tictoc16] > 3 ) t ++;
					if ( G[G_Tictoc16] > 7 ) t ++;
					if ( G[G_Tictoc16] > 11 ) t ++;
					for (int i = 0; i < 4; ++i) {
						Screen->FastTile(4, G[G_DinsFireX]+G[G_DinsFireRadius]*Cos(G[G_DinsFireDegrees]+360/4*i), G[G_DinsFireY]+G[G_DinsFireRadius]*Sin(G[G_DinsFireDegrees]+360/4*i), t, 8, OP_OPAQUE);
					}
					G[G_DinsFireDegrees] -= 6;
					G[G_DinsFireDegrees] %= 360;
					G[G_DinsFireRadius] -= 0.5;
					if ( G[G_DinsFireRadius] < 4 ) {
						G[G_DinsFireActive] = 2;
						
						// burn certain combos
						bool burned;
						int x; int y;
						for (int i = 0; i < 2; ++i) {
							for (int j = 0; j < 2; ++j) {
								x = G[G_DinsFireX]+1 + i*13;
								y = G[G_DinsFireY]+1 + j*13;
								if ( PointWithinRect(x, y, 0, 0, 255, 175) ) {
									if ( Screen->ComboD[ComboAt(x, y)] == 57 ) { // trees
										Game->PlaySound(13);
										lweapon Effect = CreateLWeaponAt(LW_SCRIPT1, ComboX(ComboAt(x, y)), ComboY(ComboAt(x, y)));
										Effect->DrawYOffset = 0;
										Effect->UseSprite(12);
										Effect->CollDetection = false;
										Effect->Misc[0] = LWType_FireThatOpens;
										if ( Screen->ComboF[ComboAt(x, y)] == 16 )
											Effect->Misc[1] = 1;
										burned = true;
									}
								}
							}
						}
						
						if ( burned ) {
							G[G_DinsFireActive] = 0;
						}
						else {
							GLW[GLW_DinsFire] = CreateLWeaponAt(LW_SCRIPT10, G[G_DinsFireX], G[G_DinsFireY]);
							GLW[GLW_DinsFire]->DrawYOffset = 0;
							GLW[GLW_DinsFire]->UseSprite(90);
							GLW[GLW_DinsFire]->CollDetection = false;
						}
					}
				}
				
				// Nayrus Water
				if ( PressItem(ITM_NayrusWater) ) {
					if ( LinkCanAttack() && G[G_NayrusWaterState] == 0 && G[G_NayrusWaterCD] == 0 ) {
						if ( G[G_MP_Val] >= MP_Cost_NayrusWater ) {
							if ( CanWalkLegit(Link->X+3, Link->Y+8+3, Link->X+12, Link->Y+12, Link->Dir, 5, 3) ) {
								LoseMP(MP_Cost_NayrusWater);
								Game->PlaySound(61);
								G[G_NayrusWaterState] = 1;
								G[G_NayrusWaterDir] = Link->Dir;
								G[G_NayrusWaterCharge] = 0;
								G[G_NayrusWaterX] = Link->X;
								G[G_NayrusWaterY] = Link->Y;
								G[G_NayrusWaterYOffset] = 0;
								G[G_NayrusWaterTicToc20] = 0;
								G[G_WaterModFFCID] = 0;
								G[G_WaterModPos] = 0;
								G[G_WaterModState] = 0;
							}
						}
						else // Not enough MP
							Game->PlaySound(64);
					}
				}
				if ( G[G_NayrusWaterState] > 0 ) {
					if ( G[G_NayrusWaterState] <= 3 ) { // charge
						Screen->DrawTile(4, G[G_NayrusWaterX]-8, G[G_NayrusWaterY]-8, 23740+2*(G[G_NayrusWaterState]-1), 2, 2, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
						if ( G[G_NayrusWaterCharge] == 8 ) {
							G[G_NayrusWaterState] ++;
							G[G_NayrusWaterCharge] = 0;
						}
						else
							G[G_NayrusWaterCharge] ++;
					}
					if ( G[G_NayrusWaterState] == 4 ) { // moving
						if ( G[G_WaterModState] == 0 ) {
							G[G_NayrusWaterX] += VectorX(1.5, DirAngle(G[G_NayrusWaterDir]));
							G[G_NayrusWaterY] += VectorY(1.5, DirAngle(G[G_NayrusWaterDir]));
						}
						else {
							if ( G[G_WaterModState] == 1 ) {
								if ( G[G_NayrusWaterX] > G[G_WaterModX] )
									G[G_NayrusWaterX] --;
								else if ( G[G_NayrusWaterX] < G[G_WaterModX] )
									G[G_NayrusWaterX] ++;
								else if ( G[G_NayrusWaterY] > G[G_WaterModY] )
									G[G_NayrusWaterY] --;
								else if ( G[G_NayrusWaterY] < G[G_WaterModY] )
									G[G_NayrusWaterY] ++;
								else
									G[G_WaterModState] = 2;
							}
							else {
								G[G_NayrusWaterX] += VectorX(G[G_WaterModSpeed], DirAngle(G[G_NayrusWaterDir]));
								G[G_NayrusWaterY] += VectorY(G[G_WaterModSpeed], DirAngle(G[G_NayrusWaterDir]));
								if ( G[G_WaterModSpeed] < 1.5 )
									G[G_WaterModSpeed] += 0.1;
								else
									G[G_WaterModState] = 0;
							}
						}
						
						for (int i = Screen->NumNPCs(); i >= 1; --i) {
							npc enem = Screen->LoadNPC(i);
							if ( enem->ID > 10 ) { // moldorm
								if ( enem->Stun <= 10 && enem->CollDetection && enem->Z == 0 ) {
									if ( RectCollision(Link->X-4, Link->Y-4, Link->X+19, Link->Y+19,
									enem->X, enem->Y, enem->X+enem->HitWidth-1+enem->HitXOffset, enem->Y+enem->HitHeight-1+enem->HitYOffset) ) {
										Game->PlaySound(11);
										enem->Stun = 120;
										LoseMP(MP_Cost_NayrusWaterStun);
									}
								}
							}
						}
						
						G[G_NayrusWaterTicToc20] += 0.5;
						G[G_NayrusWaterTicToc20] %= 20;
						if ( G[G_NayrusWaterTicToc20] >= 4 && G[G_NayrusWaterTicToc20] <= 9 )
							G[G_NayrusWaterYOffset] = 1;
						else if ( G[G_NayrusWaterTicToc20] >= 14 )
							G[G_NayrusWaterYOffset] = -1;
						else
							G[G_NayrusWaterYOffset] = 0;
						
						if ( G[G_WaterModState] != 1 ) {
							if ( G[G_NayrusWaterDir] == DIR_UP || G[G_NayrusWaterDir] == DIR_DOWN ) {
								if ( Screen->isSolid(G[G_NayrusWaterX], G[G_NayrusWaterY]+12) )
									G[G_NayrusWaterX] ++;
								if ( Screen->isSolid(G[G_NayrusWaterX]+15, G[G_NayrusWaterY]+12) )
									G[G_NayrusWaterX] --;
								if ( !CanWalkLegit(G[G_NayrusWaterX]+3, G[G_NayrusWaterY]+8, G[G_NayrusWaterX]+12, G[G_NayrusWaterY]+15, G[G_NayrusWaterDir], 1.5, 3) )
									G[G_NayrusWaterState] = 5;
							}
							else {
								if ( Screen->isSolid(G[G_NayrusWaterX]+8, G[G_NayrusWaterY]+8) )
									G[G_NayrusWaterY] ++;
								if ( Screen->isSolid(G[G_NayrusWaterX]+8, G[G_NayrusWaterY]+15) )
									G[G_NayrusWaterY] --;
								if ( !CanWalkLegit(G[G_NayrusWaterX], G[G_NayrusWaterY]+8+3, G[G_NayrusWaterX]+15, G[G_NayrusWaterY]+12, G[G_NayrusWaterDir], 1.5, 3) )
									G[G_NayrusWaterState] = 5;
							}
						}
					}
					if ( G[G_NayrusWaterState] == 4 ) {
						Link->DrawYOffset = G[G_NayrusWaterYOffset];
						Screen->DrawTile(4, G[G_NayrusWaterX]-8, G[G_NayrusWaterY]-8+G[G_NayrusWaterYOffset], 23744, 2, 2, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
					}
					if ( G[G_NayrusWaterState] == 5 ) { //pop
						Game->PlaySound(55);
						G[G_NayrusWaterState] = 0;
						G[G_NayrusWaterCD] = 10;
						Link->DrawYOffset = 0;
						
						lweapon Pop = CreateLWeaponAt(LW_SPARKLE, G[G_NayrusWaterX], G[G_NayrusWaterY]);
						Pop->UseSprite(92);
						Pop->DrawYOffset = -1000;
						Pop->Misc[15] = 4;
					}
					
					NoAction();
					G[G_LinkBusy] = 2;
					Link->HitDir = -1;
					Link->X = G[G_NayrusWaterX];
					Link->Y = G[G_NayrusWaterY];
				}
				if ( G[G_NayrusWaterCD] > 0 )
					G[G_NayrusWaterCD] --;
				
				// Farores Wind
				if ( InputItem(ITM_FaroresWind) ) {
					if ( LinkCanAttack() ) {
						if ( G[G_FaroresWindHold] > 0 ) {
							if ( G[G_FaroresWindHold] == 1 )
								G[G_FaroresWindDegrees] = 0;
							if ( G[G_FaroresWindHold] > 50 ) {
								Game->PlaySound(39);
								G[G_FaroresWindActive] = 1;
								G[G_FaroresWindY] = 0;
							}
							else {
								for (int i = 0; i < 4; ++i)
									Screen->FastCombo(2, Link->X+VectorX((54-G[G_FaroresWindHold])*0.3, 45+i*90+G[G_FaroresWindDegrees]),
									Link->Y+VectorY((54-G[G_FaroresWindHold])*0.3, 45+i*90+G[G_FaroresWindDegrees]), 2569, 5, OP_OPAQUE);
							}
							G[G_FaroresWindDegrees] += 4;
							G[G_FaroresWindHold] ++;
						}
						else if ( PressItem(ITM_FaroresWind) )
							G[G_FaroresWindHold] = 1;
					}
				}
				else
					G[G_FaroresWindHold] = 0;
				if ( G[G_FaroresWindActive] > 0 ){
					NoAction();
					G[G_LinkBusy] = 2;
					Link->DrawYOffset = -1000;
					Link->CollDetection = false;
					
					G[G_FaroresWindActive] ++;
					if ( G[G_FaroresWindActive] > 30 )
						G[G_FaroresWindY] -= 3.5;
					
					Screen->FastCombo(5, Link->X, Link->Y+G[G_FaroresWindY], 2569, 5, OP_OPAQUE);
					Screen->FastCombo(5, Link->X, Link->Y+G[G_FaroresWindY], 2568, 6, OP_OPAQUE);
					
					if ( Link->Y+G[G_FaroresWindY] < -48 ) {
						Link->HP = Link->MaxHP;
						G[G_GameStopFreeze] = 1;
						int filename[100];
						Game->GetDMapMusicFilename(Game->GetCurDMap(), filename);
						Game->SetDMapEnhancedMusic(0, filename, Game->GetDMapMusicTrack(Game->GetCurDMap()));
						Link->Warp(0, 0x72);
					}
				}
				
				// Hylias Spirit
				if ( PressItem(ITM_HyliasSpirit) ) {
					if ( LinkCanAttack() && G[G_HyliasSpiritState] == 0 && G[G_HyliasSpiritCD] == 0 ) {
						Game->PlaySound(32);
						G[G_HyliasSpiritState] = 1;
						G[G_HyliasSpiritMagicDir] = Link->Dir;
						G[G_HyliasSpiritMagicX] = Link->X+VectorX(12, DirAngle(Link->Dir));
						G[G_HyliasSpiritMagicY] = Link->Y+VectorY(12, DirAngle(Link->Dir));
						G[G_HyliasSpiritParticles] = 0;
						NoAction();
					}
				}
				if ( G[G_HyliasSpiritState] == 1 ) { // shooting the magic
					Link->Action = LA_NONE;
					Link->Action = LA_ATTACKING;
					
					if ( G[G_HyliasSpiritParticles] == 0 ) {
						G[G_HyliasSpiritParticles] = 1+Rand(3);
						lweapon Sparkle = CreateLWeaponAt(LW_SPARKLE, G[G_HyliasSpiritMagicX]+Rand(-5, 5), G[G_HyliasSpiritMagicY]+Rand(-5, 5));
						Sparkle->DrawYOffset = 0;
						Sparkle->UseSprite(114);
					}
					else
						G[G_HyliasSpiritParticles] --;
					
					G[G_HyliasSpiritMagicX] += VectorX(2, DirAngle(G[G_HyliasSpiritMagicDir]));
					G[G_HyliasSpiritMagicY] += VectorY(2, DirAngle(G[G_HyliasSpiritMagicDir]));
					
					if ( !PointWithinRect(G[G_HyliasSpiritMagicX]+8, G[G_HyliasSpiritMagicY]+8, 8, 8, 247, 167) ) {
						Link->Action = LA_NONE;
						G[G_HyliasSpiritState] = 0;
						G[G_HyliasSpiritCD] = 10;
					}
					for (int i = Screen->NumLWeapons(); i >= 1; --i) {
						lweapon wpn = Screen->LoadLWeapon(i);
						if ( wpn->ID == LW_SCRIPT1 ) {
							if ( wpn->Misc[0] == LWType_Armos ) {
								if ( PointWithinRect(G[G_HyliasSpiritMagicX]+8, G[G_HyliasSpiritMagicY]+8, wpn->X, wpn->Y, wpn->X+15, wpn->Y+15) ) {
									Game->PlaySound(47);
									SetLinkCasting(true);
									G[G_HyliasSpiritState] = 2;
									
									int pos = ComboAt(G[G_HyliasSpiritMagicX]+8, G[G_HyliasSpiritMagicY]+8);
									SetLayerComboD(2, pos, 0);
									G[G_HyliasArmosDir] = wpn->Tile-23788;
									G[G_HyliasArmosX] = ComboX(pos);
									G[G_HyliasArmosY] = ComboY(pos);
									
									// renew weapon so it draws above other armoses
									GLW[GLW_HyliasArmos] = Screen->LoadLWeapon(i);
									GLW[GLW_HyliasArmos]->Y = -1000;
									GLW[GLW_HyliasArmos]->DeadState = WDS_DEAD;
									
									GLW[GLW_HyliasArmos] = CreateLWeaponAt(LW_SCRIPT1, ComboX(i), ComboY(i));
									GLW[GLW_HyliasArmos]->DrawYOffset = 0;
									GLW[GLW_HyliasArmos]->CollDetection = false;
									GLW[GLW_HyliasArmos]->Misc[0] = LWType_Armos;
									break;
								}
							}
						}
					}
				}
				if ( G[G_HyliasSpiritState] == 2 ) { // controlling armos
					if ( G[G_HyliasSpiritParticles] == 0 ) {
						G[G_HyliasSpiritParticles] = 2+Rand(3);
						lweapon Sparkle = CreateLWeaponAt(LW_SPARKLE, G[G_HyliasArmosX]+Rand(-5, 5), G[G_HyliasArmosY]+Rand(-5, 5));
						Sparkle->DrawYOffset = 0;
						Sparkle->UseSprite(114);
					}
					else
						G[G_HyliasSpiritParticles] --;
					
					int ArmosMove[4];
					if ( Link->InputUp && !Link->InputDown ) {
						ArmosMove[DIR_UP] = 1;
						if ( G[G_HyliasArmosDir] == DIR_DOWN || (!Link->InputLeft && !Link->InputRight) )
							G[G_HyliasArmosDir] = DIR_UP;
						if ( CanWalkLegit(G[G_HyliasArmosX], G[G_HyliasArmosY]+8, G[G_HyliasArmosX]+15, G[G_HyliasArmosY]+15, DIR_UP, 1, 2) )
							G[G_HyliasArmosY] --;
					}
					if ( Link->InputDown && !Link->InputUp ) {
						ArmosMove[DIR_DOWN] = 1;
						if ( G[G_HyliasArmosDir] == DIR_UP || (!Link->InputLeft && !Link->InputRight) )
							G[G_HyliasArmosDir] = DIR_DOWN;
						if ( CanWalkLegit(G[G_HyliasArmosX], G[G_HyliasArmosY]+8, G[G_HyliasArmosX]+15, G[G_HyliasArmosY]+15, DIR_DOWN, 1, 2) )
							G[G_HyliasArmosY] ++;
					}
					if ( Link->InputLeft && !Link->InputRight ) {
						ArmosMove[DIR_LEFT] = 1;
						if ( G[G_HyliasArmosDir] == DIR_RIGHT || (!Link->InputUp && !Link->InputDown) )
							G[G_HyliasArmosDir] = DIR_LEFT;
						if ( CanWalkLegit(G[G_HyliasArmosX], G[G_HyliasArmosY]+8, G[G_HyliasArmosX]+15, G[G_HyliasArmosY]+15, DIR_LEFT, 1, 2) )
							G[G_HyliasArmosX] --;
					}
					if ( Link->InputRight && !Link->InputLeft ) {
						ArmosMove[DIR_RIGHT] = 1;
						if ( G[G_HyliasArmosDir] == DIR_LEFT || (!Link->InputUp && !Link->InputDown) )
							G[G_HyliasArmosDir] = DIR_RIGHT;
						if ( CanWalkLegit(G[G_HyliasArmosX], G[G_HyliasArmosY]+8, G[G_HyliasArmosX]+15, G[G_HyliasArmosY]+15, DIR_RIGHT, 1, 2) )
							G[G_HyliasArmosX] ++;
					}
					
					GLW[GLW_HyliasArmos]->X = G[G_HyliasArmosX];
					GLW[GLW_HyliasArmos]->Y = G[G_HyliasArmosY];
					
					if ( ArmosMove[DIR_UP] == 1 || ArmosMove[DIR_DOWN] == 1 || ArmosMove[DIR_LEFT] == 1 || ArmosMove[DIR_RIGHT] == 1 ) {
						GLW[GLW_HyliasArmos]->UseSprite(97+G[G_HyliasArmosDir]);
					}
					else {
						GLW[GLW_HyliasArmos]->UseSprite(96);
						GLW[GLW_HyliasArmos]->Tile = GLW[GLW_HyliasArmos]->OriginalTile+G[G_HyliasArmosDir];
					}
					
					lweapon ArmosDamage = CreateLWeaponAt(LW_SCRIPT1, G[G_HyliasArmosX]+2, G[G_HyliasArmosY]+2);
					ArmosDamage->Tile = 180;
					ArmosDamage->Damage = G[G_LinkPower]*2;
					ArmosDamage->Dir = G[G_HyliasArmosDir];
					ArmosDamage->HitWidth = 12;
					ArmosDamage->HitHeight = 12;
					ArmosDamage->Misc[15] = 2;
					
					if ( Link->PressA || Link->PressB || Link->Action == LA_GOTHURTLAND ) {
						Game->PlaySound(46);
						SetLinkCasting(false);
						GLW[GLW_HyliasArmos]->UseSprite(95);
						GLW[GLW_HyliasArmos]->Tile = GLW[GLW_HyliasArmos]->OriginalTile+G[G_HyliasArmosDir];
						
						int pos = ComboAt(G[G_HyliasArmosX]+8, G[G_HyliasArmosY]+8);
						SetLayerComboD(2, pos, CMB_ScriptSolid);
						GLW[GLW_HyliasArmos]->X = ComboX(pos);
						GLW[GLW_HyliasArmos]->Y = ComboY(pos);
						
						G[G_HyliasSpiritState] = 0;
						G[G_HyliasSpiritCD] = 10;
					}
					
					NoAction();
				}
				if ( G[G_HyliasSpiritCD] > 0 )
					G[G_HyliasSpiritCD] --;
				
				// Dins Earth
				if ( PressItem(ITM_DinsEarth) ) {
					if ( LinkCanAttack() && G[G_DinsEarthState] == 0 ) {
						if ( G[G_MP_Val] >= MP_Cost_DinsEarth ) {
							G[G_MP_RegenLock] = 1;
							Game->PlaySound(36);
							G[G_DinsEarthState] = 1;
							SetLinkCasting(true);
							G[G_DinsEarthTimer] = 0;
							G[G_DinsEarthX] = Link->X+VectorX(20, DirAngle(Link->Dir));
							G[G_DinsEarthY] = Link->Y+VectorY(20, DirAngle(Link->Dir));
							
							G[G_DinsEarthX] = Clamp(G[G_DinsEarthX], 2, 238);
							G[G_DinsEarthY] = Clamp(G[G_DinsEarthY], 2, 158);
						}
						else // Not enough MP
							Game->PlaySound(64);
					}
				}
				if ( G[G_DinsEarthState] > 0 ) {
					if ( G[G_DinsEarthState] == 1 ) {
						if ( Link->Action == LA_GOTHURTLAND ) {
							G[G_MP_RegenLock] = 0;
							G[G_DinsEarthState] = 0;
							SetLinkCasting(false);
							GLW[GLW_DinsEarth]->DeadState = WDS_DEAD;
						}
						else if ( G[G_DinsEarthTimer] >= 30 ) {
							G[G_MP_RegenLock] = 0;
							LoseMP(MP_Cost_DinsEarth);
							G[G_DinsEarthState] = 2;
							
							G[G_DinsEarthTimer] = 0;
							G[G_DinsEarthZ] = 180;
							G[G_DinsEarthGravity] = 0;
							
							GLW[GLW_DinsEarth] = CreateLWeaponAt(LW_SCRIPT10, G[G_DinsEarthX], G[G_DinsEarthY]);
							GLW[GLW_DinsEarth]->DrawYOffset = 0;
							GLW[GLW_DinsEarth]->UseSprite(50);
							GLW[GLW_DinsEarth]->CollDetection = false;
						}
						else
							G[G_DinsEarthTimer] ++;
					}
					if ( G[G_DinsEarthState] == 2 ) {
						G[G_DinsEarthTimer] ++;
						if ( G[G_DinsEarthTimer] >= 10 ) {
							LoseMP(0);
							SetLinkCasting(false);
						}
						
						G[G_DinsEarthZ] -= G[G_DinsEarthGravity];
						G[G_DinsEarthGravity] += 0.16;
						
						if ( G[G_DinsEarthZ] <= 0 ) {
							G[G_DinsEarthZ] = 0;
							Game->PlaySound(3);
							G[G_DinsEarthState] = 3;
							G[G_DinsEarthTimer] = 0;
							
							GLW[GLW_DinsEarth]->DeadState = WDS_DEAD;
							Screen->Quake = 45;
							
							int i; int j;
							for (i = Screen->NumNPCs(); i >= 1; --i) {
								npc enem = Screen->LoadNPC(i);
								if ( enem->ID > 10 ) { // moldorm
									if ( enem->CollDetection && enem->Z == 0 )
										enem->Stun = 120;
								}
							}
							for (i = 0; i < 5; ++i) {
								lweapon Damage = CreateLWeaponAt(LW_SCRIPT1, G[G_DinsEarthX]-8, G[G_DinsEarthY]-8);
								Damage->Tile = 180;
								Damage->HitWidth = 32;
								Damage->HitHeight = 32;
								Damage->Dir = -1;
								Damage->Damage = (G[G_LinkPower]+6)*2;
								Damage->Misc[15] = 2;
							}
							for (i = 0; i < 2; ++i) {
								for (j = 0; j < 2; ++j) {
									lweapon Effect = CreateLWeaponAt(LW_SPARKLE, G[G_DinsEarthX]-8+i*16, G[G_DinsEarthY]-8+j*16);
									Effect->DrawYOffset = 0;
									Effect->UseSprite(103);
								}
							}
							// break certain combos
							int x; int y;
							for (i = 0; i < 3; ++i) {
								for (j = 0; j < 3; ++j) {
									x = G[G_DinsEarthX]-6 + i*14;
									y = G[G_DinsEarthY]-6 + j*14;
									if ( Screen->ComboD[ComboAt(x, y)] == 910 ) // cracked dungeon blocks
										Screen->ComboD[ComboAt(x, y)] ++;
									if ( Screen->ComboD[ComboAt(x, y)] == 1124 ) { // rocks
										if ( Screen->ComboF[ComboAt(x, y)] == 16 ) {
											Game->PlaySound(27);
											Screen->TriggerSecrets();
											Screen->State[ST_SECRET] = true;
										}
										else {
											Screen->ComboD[ComboAt(x, y)] = 14;
											RandomDrop(ComboX(ComboAt(x, y)), ComboY(ComboAt(x, y)));
										}
									}
									if ( Screen->ComboT[ComboAt(x, y)] == CT_SCRIPT2 ) { // big rocks
										if ( Screen->ComboF[ComboAt(x, y)] == 16 || Screen->ComboF[ComboAt(x, y)] == 17 ) {
											Game->PlaySound(27);
											Screen->TriggerSecrets();
											Screen->State[ST_SECRET] = true;
										}
										else {
											int k = ComboAt(x, y);
											int l;
											Screen->ComboD[k] = 14;
											for (l = 0; l < 8; ++l) {
												if ( Screen->ComboT[AdjacentCombo(k, l)] == CT_SCRIPT2 )
													Screen->ComboD[AdjacentCombo(k, l)] = 14;
											}
										}
									}
								}
							}
						}
						
						int t = 23840;
						if ( G[G_Tictoc16] > 3 ) t += 2;
						if ( G[G_Tictoc16] > 7 ) t += 2;
						if ( G[G_Tictoc16] > 11 ) t += 2;
						Screen->DrawTile(5, G[G_DinsEarthX]-8, G[G_DinsEarthY]-G[G_DinsEarthZ]-8, t, 2, 2, 8, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
					}
					if ( G[G_DinsEarthState] == 3 ) {
						G[G_DinsEarthTimer] ++;
						if ( G[G_DinsEarthTimer] > 20 )
							G[G_DinsEarthState] = 0;
					}
				}
				
				// Nayrus Time
				if ( PressItem(ITM_NayrusTime) ) {
					if ( LinkCanAttack() && G[G_NayrusTimeActive] == 0 && LinkPastTile[LinkPastArraySize-1] != -1 ) {
						if ( G[G_MP_Val] >= MP_Cost_NayrusTime ) {
							G[G_MP_RegenLock] = 1;
							Game->PlaySound(62);
							G[G_NayrusTimeActive] = 1;
							Link->DrawYOffset = -1000;
							Link->CollDetection = false;
							
							G[G_NayrusTimePos] = 0;
							G[G_NayrusTimeSpeed] = 0.5;
							G[G_NayrusTimeAcc] = 0;
						}
						else // Not enough MP
							Game->PlaySound(64);
					}
				}
				
				if ( G[G_Tictoc16] % 2 == 0 ) { // every 2nd frame, cycle the LinkPast arrays
					if ( G[G_NayrusTimeActive] == 0 ) {
						for (int i = LinkPastArraySize-1; i > 0; --i) {
							LinkPastX[i] = LinkPastX[i-1];
							LinkPastY[i] = LinkPastY[i-1];
							LinkPastZ[i] = LinkPastZ[i-1];
							LinkPastDir[i] = LinkPastDir[i-1];
							LinkPastTile[i] = LinkPastTile[i-1];
						}
						LinkPastX[0] = Link->X;
						LinkPastY[0] = Link->Y;
						LinkPastZ[0] = Link->Z;
						LinkPastDir[0] = Link->Dir;
						LinkPastTile[0] = Link->Tile;
					}
				}
				
				if ( GetEquipmentA() == ITM_NayrusTime || GetEquipmentB() == ITM_NayrusTime ) {
					if ( LinkPastTile[LinkPastArraySize-1] != -1 ) {
						if ( !GLW[GLW_NayrusTime]->isValid() ) {
							GLW[GLW_NayrusTime] = Screen->CreateLWeapon(LW_SCRIPT10);
							GLW[GLW_NayrusTime]->DrawYOffset = 0;
							GLW[GLW_NayrusTime]->UseSprite(101);
							GLW[GLW_NayrusTime]->CollDetection = false;
						}
						GLW[GLW_NayrusTime]->X = LinkPastX[LinkPastArraySize-1];
						GLW[GLW_NayrusTime]->Y = LinkPastY[LinkPastArraySize-1];
					}
				}
				else if ( GLW[GLW_NayrusTime]->isValid() )
					GLW[GLW_NayrusTime]->DeadState = WDS_DEAD;
				
				if ( G[G_NayrusTimeActive] == 1 ) {
					NoAction();
					G[G_LinkBusy] = 2;
					int index = Min(Floor(G[G_NayrusTimePos]), LinkPastArraySize-1);
					
					Link->X = LinkPastX[index];
					Link->Y = LinkPastY[index];
					Link->Z = LinkPastZ[index];
					Link->Dir = LinkPastDir[index];
					FastTileLWeapon(Link->X, Link->Y-Link->Z, LinkPastTile[index], 6, 6);
					
					if ( index == LinkPastArraySize-1 ) {
						G[G_MP_RegenLock] = 0;
						LoseMP(MP_Cost_NayrusTime);
						Game->PlaySound(60);
						G[G_NayrusTimeActive] = 0;
						Link->DrawYOffset = 0;
						Link->CollDetection = true;
						
						for (int i = 0; i < LinkPastArraySize; ++i) {
							LinkPastX[i] = -1;
							LinkPastY[i] = -1;
							LinkPastZ[i] = -1;
							LinkPastDir[i] = -1;
							LinkPastTile[i] = -1;
						}
						GLW[GLW_NayrusTime]->DeadState = WDS_DEAD;
						
						lweapon Effect = CreateLWeaponAt(LW_SCRIPT1, Link->X, Link->Y-Link->Z);
						Effect->Tile = 180;
						Effect->CollDetection = false;
						Effect->Misc[0] = LWType_NayrusTimeEnd;
						Effect->Misc[1] = -15;
					}
					
					G[G_NayrusTimePos] += G[G_NayrusTimeSpeed];
					G[G_NayrusTimeSpeed] += G[G_NayrusTimeAcc];
					G[G_NayrusTimeAcc] += 0.001;
				}
				
				// Farores Nature
				if ( PressItem(ITM_FaroresNature) ) {
					if ( LinkCanAttack() && G[G_FaroresNatureState] == 0 && G[G_FaroresNatureCD] == 0 ) {
						if ( G[G_MP_Val] >= MP_Cost_FaroresNature ) {
							LoseMP(MP_Cost_FaroresNature);
							Game->PlaySound(56);
							Link->Action = LA_ATTACKING;
							G[G_FaroresNatureState] = 1;
							G[G_FaroresNatureDir] = Link->Dir;
							G[G_FaroresNatureX] = Link->X;
							G[G_FaroresNatureY] = Link->Y;
							int x = Link->X;
							int y = Link->Y;
							for (int i = 0; i < 16; ++i) {
								G[G_FaroresNatureX] = x;
								G[G_FaroresNatureY] = y;
								x += VectorX(1, DirAngle(Link->Dir));
								y += VectorY(1, DirAngle(Link->Dir));
								if ( !CanWalkLegit(x, y+8, x+15, y+15, Link->Dir, 0, 0) )
									break;
							}
							G[G_FaroresNatureVar] = 8;
						}
						else // Not enough MP
							Game->PlaySound(64);
					}
				}
				if ( G[G_FaroresNatureState] > 0 ) {
					if ( G[G_FaroresNatureState] == 1 ) {
						Screen->Circle(2, G[G_FaroresNatureX]+8, G[G_FaroresNatureY]+8, G[G_FaroresNatureVar], 0x52, 1, 0, 0, 0, true, OP_OPAQUE);
						
						if ( G[G_FaroresNatureVar] <= 3 ) {
							//Game->PlaySound(56);
							G[G_FaroresNatureState] = 2;
							
							G[G_FaroresNatureX] = Clamp(G[G_FaroresNatureX], 2, 238);
							G[G_FaroresNatureY] = Clamp(G[G_FaroresNatureY], 2, 258);
							G[G_FaroresNatureVar] = 15;
							
							GLW[GLW_FaroresNature] = CreateLWeaponAt(LW_SCRIPT10, G[G_FaroresNatureX], G[G_FaroresNatureY]);
							GLW[GLW_FaroresNature]->DrawYOffset = 0;
							GLW[GLW_FaroresNature]->UseSprite(104);
							GLW[GLW_FaroresNature]->CollDetection = false;
							
							lweapon Poof = CreateLWeaponAt(LW_SPARKLE, G[G_FaroresNatureX], G[G_FaroresNatureY]);
							Poof->DrawYOffset = 0;
							Poof->UseSprite(22);
						}
						else {
							G[G_FaroresNatureVar] -= 0.25;
						}
					}
					if ( Link->Action != LA_HOLD1LAND && Link->Action != LA_HOLD2LAND ) {
						if ( G[G_FaroresNatureState] == 12 ) {
							if ( G[G_FaroresNatureVar] <= 45 ) {
								G[G_FaroresNatureState] = 0;
								G[G_FaroresNatureCD] = 20;
								
								GLW[GLW_FaroresNature]->DeadState = WDS_DEAD;
								lweapon Poof = CreateLWeaponAt(LW_SPARKLE, G[G_FaroresNatureX], G[G_FaroresNatureY]);
								Poof->DrawYOffset = 0;
								Poof->UseSprite(22);
							}
							else
								G[G_FaroresNatureVar] --;
						}
						else if ( G[G_FaroresNatureState] >= 2 ) {
							if ( !GLW[GLW_FaroresNature]->isValid() ) {
								GLW[GLW_FaroresNature] = CreateLWeaponAt(LW_SCRIPT10, G[G_FaroresNatureX], G[G_FaroresNatureY]);
								GLW[GLW_FaroresNature]->DrawYOffset = 0;
								GLW[GLW_FaroresNature]->UseSprite(104);
								GLW[GLW_FaroresNature]->CollDetection = false;
							}
							
							if ( PressItem(ITM_FaroresNature) && LinkCanAttack() ) {
								G[G_FaroresNatureVar] = 1;
								G[G_FaroresNatureState] = 12;
							}
							
							if ( G[G_FaroresNatureVar] == 0 ) {
								G[G_FaroresNatureVar] = 60;
								G[G_FaroresNatureState] ++;
								
								Game->PlaySound(1);
								for (int i = 0; i < 4; ++i) {
									lweapon Thorn = CreateLWeaponAt(LW_SCRIPT1, G[G_FaroresNatureX]+VectorX(10, DirAngle(i)), G[G_FaroresNatureY]+VectorY(10, DirAngle(i)));
									Thorn->DrawYOffset = 0;
									Thorn->UseSprite(105);
									Thorn->Tile += i;
									Thorn->Dir = i;
									Thorn->Step = 250;
									Thorn->Damage = G[G_LinkPower];
									Thorn->Misc[0] = LWType_FaroresNature;
								}
							}
							else
								G[G_FaroresNatureVar] --;
						}
					}
				}
				if ( G[G_FaroresNatureCD] > 0 )
					G[G_FaroresNatureCD] --;
				
				// force gem
				if ( G[G_ForceGemActive] > 0 ) {
					for (int i = 0; i < 3; ++i) {
						if ( !GLW[GLW_Force1 + i]->isValid() ) {
							GLW[GLW_Force1 + i] = Screen->CreateLWeapon(LW_SCRIPT10);
							GLW[GLW_Force1 + i]->DrawYOffset = 0;
							GLW[GLW_Force1 + i]->UseSprite(106);
							GLW[GLW_Force1 + i]->Damage = G[G_LinkPower]*2;
						}
						
						GLW[GLW_Force1 + i]->DeadState = WDS_ALIVE;
						GLW[GLW_Force1 + i]->X = Link->X + G[G_ForceGemRadius] * Cos(360/3*i+G[G_ForceGemDegrees]);
						GLW[GLW_Force1 + i]->Y = Link->Y + G[G_ForceGemRadius] * Sin(360/3*i+G[G_ForceGemDegrees]);
						GLW[GLW_Force1 + i]->Dir = Link->Dir;
						if ( G[G_Tictoc16] < 12 )
							GLW[GLW_Force1 + i]->Tile = 23462;
						else
							GLW[GLW_Force1 + i]->Tile = 23463;
					}
					
					G[G_ForceGemDegrees] += G[G_ForceGemSpeed];
					G[G_ForceGemDegrees] %= 360;
					if ( G[G_ForceGemActive] > 570 ) {
						G[G_ForceGemRadius] ++;
						G[G_ForceGemSpeed] += 0.15;
					}
					else if ( G[G_ForceGemActive] <= 30 ) {
						G[G_ForceGemRadius] --;
						G[G_ForceGemSpeed] -= 0.15;
					}
					
					G[G_ForceGemActive] --;
					if ( G[G_ForceGemActive] == 0 ) {
						for (int i = 0; i < 3; ++i) {
							if ( GLW[GLW_Force1 + i]->isValid() )
								GLW[GLW_Force1 + i]->DeadState = WDS_DEAD;
						}
					}
				}
				
				// sacred flame
				if ( G[G_LinkSacredFlameState] == 1 ) {
					LoseMP(2);
					if ( !GLW[GLW_SacredFlame]->isValid() ) {
						GLW[GLW_SacredFlame] = CreateLWeaponAt(LW_SCRIPT10, 4, 4);
						GLW[GLW_SacredFlame]->UseSprite(112);
						GLW[GLW_SacredFlame]->CollDetection = false;
						GLW[GLW_SacredFlame]->Extend = 3;
						GLW[GLW_SacredFlame]->TileWidth = 2;
						GLW[GLW_SacredFlame]->TileHeight = 2;
					}
				}
				else if ( G[G_LinkSacredFlameState] == 2 ) {
					G[G_LinkSacredFlameState] = 0;
					if ( GLW[GLW_SacredFlame]->isValid() )
						GLW[GLW_SacredFlame]->DeadState = WDS_DEAD;
					for (int i = Screen->NumEWeapons(); i >= 1; --i) {
						eweapon wpn = Screen->LoadEWeapon(i);
						if ( wpn->ID == EW_FIRE ) //turn on all fire colldetection
							wpn->CollDetection = true;
					}
				}
				
				// fans push
				if ( Link->Action == LA_GOTHURTLAND )
					G[G_LinkExtraPush] = 3;
				else if ( G[G_LinkExtraPush] > 1 )
					G[G_LinkExtraPush] -= 0.1;
				
				// move link out of solid combos
				if ( G[G_NayrusTimeActive] == 0 && Game->Cheat < 4 ) { // !!!
					int i; int j; int x = Link->X; int y = Link->Y;
					if ( Screen->isSolid(Link->X+8, Link->Y+8) ) {
						for (i = 1; i < 6; ++i) {
							for (j = 0; j < 4; ++j) {
								x = Link->X+8+VectorX(8*i, DirAngle(RotateDirNum(Link->Dir, j)));
								y = Link->Y+8+VectorY(8*i, DirAngle(RotateDirNum(Link->Dir, j)));
								if ( !Screen->isSolid(x, y) && PointWithinRect(x, y, 8, 8, 248, 168) ) {
									i = 9999;
									j = 4;
								}
							}
						}
						if ( i >= 9999 ) {
							Link->X = x-8;
							Link->Y = y-8;
						}
					}
				}
				
				// link combo interaction
				int linkpos = ComboAt(Link->X+8, Link->Y+12);
				if ( LinkCanAttack() ) {
					// savepoints
					if ( Screen->ComboD[linkpos] == CMB_Savepoint ) {
						if ( Link->PressA ) {
							Link->HP = Link->MaxHP;
							G[G_GameStopFreeze] = 1;
							int filename[100];
							Game->GetDMapMusicFilename(Game->GetCurDMap(), filename);
							Game->SetDMapEnhancedMusic(0, filename, Game->GetDMapMusicTrack(Game->GetCurDMap()));
							Link->Warp(0, 0x71);
						}
						else
							Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
						if ( Link->HP < Link->MaxHP && G[G_SavepointHeal] == 0 ) {
							G[G_SavepointHeal] = Link->MaxHP - Link->HP +2;
						}
					}
				}
				
				// savepoint healing
				if ( G[G_SavepointHeal] > 0 ) {
					Game->PlaySound(22);
					Link->HP += 2;
					G[G_SavepointHeal] -= 2;
					if ( Link->HP >= Link->MaxHP ) {
						Link->HP = Link->MaxHP;
						G[G_SavepointHeal] = 0;
					}
				}
				
				// Magic code
				if ( Link->Action != LA_HOLD1LAND && Link->Action != LA_HOLD2LAND ) {
					if ( G[G_DeluxeMagic] > 0 ) {
						G[G_DeluxeMagic] --;
						if ( G[G_LinkSacredFlameState] == 0 ) {
							G[G_MP_RegenLock] = 0;
							G[G_MP_CD] = 0;
							G[G_MP_Regen] = MP_MaxRegen;
						}
					}
					if ( G[G_MP_RegenLock] == 0 ) {
						if ( G[G_MP_CD] > 0 )
							G[G_MP_CD] --;
						else {
							G[G_MP_Val] += G[G_MP_Regen];
							if ( G[G_MP_Val] > Game->MCounter[CR_MAGIC] )
								G[G_MP_Val] = Game->MCounter[CR_MAGIC];
							
							G[G_MP_Regen] += MP_BaseAcc;
							if ( G[G_MP_Regen] > MP_MaxRegen )
								G[G_MP_Regen] = MP_MaxRegen;
						}
					}
				}
				Game->Counter[CR_MAGIC] = G[G_MP_Val];
				
				if ( G[G_LinkCasting] == 1 ) {
					Link->Action = LA_NONE;
					Link->Action = LA_ATTACKING;
				}
			}
			// END OF GLOBAL SCREEN SCRIPTS
			
			// misc stuff
			if ( Link->PressL )
				Link->SelectBWeapon(DIR_LEFT);
			if ( Link->PressR )
				Link->SelectBWeapon(DIR_RIGHT);
			
			Game->ContinueDMap = G[G_ContinueDMap];
			Game->ContinueScreen = G[G_ContinueScreen];
			
			Waitdraw();
			UpdateGhostZH2();
			LinkMovement_Update2();
			
			if ( G[G_LinksCurrDMap] != Game->GetCurDMap() || G[G_LinksCurrScreen] != Game->GetCurDMapScreen() ) { //screen init
				G[G_LinksCurrDMap] = Game->GetCurDMap();
				G[G_LinksCurrScreen] = Game->GetCurDMapScreen();
				
				ScreenAndContinueInit();
				G[G_ScreenInitAfterScroll] = 0;
			}
			
			if ( GLW[GLW_SacredFlame]->isValid() ) {
				GLW[GLW_SacredFlame]->DrawXOffset = Link->X-12;
				GLW[GLW_SacredFlame]->DrawYOffset = Link->Y-14;
			}
			
			if ( G[G_LinkCasting] == 1 )
				FastTileLWeapon(Link->X, Link->Y-Link->Z, 31660, 6, 0);
			Waitframe();
		}
	}
}

bool CrystalHit(int pos) {
	if ( G[G_Timestop] == 1 )
		return false;
	for (int i = Screen->NumLWeapons(); i >= 1; --i) {
		lweapon wpn = Screen->LoadLWeapon(i);
		if ( wpn->ID == LW_SCRIPT1 ) {
			if ( wpn->Misc[0] == LWType_HyliasLight || wpn->Misc[0] == LWType_FaroresNature ) {
				if ( PointWithinRect(wpn->X+8, wpn->Y+8, ComboX(pos), ComboY(pos), ComboX(pos)+15, ComboY(pos)+15) )
					return true;
			}
			else if ( wpn->Misc[0] == LWType_RealBlast && wpn->Misc[1] == 1 ) {
				if ( RectCollision(wpn->X+3, wpn->Y+3, wpn->X+12, wpn->Y+12, ComboX(pos), ComboY(pos), ComboX(pos)+15, ComboY(pos)+15) )
					return true;
			}
		}
		else if ( wpn->ID == LW_SWORD ) {
			if ( RectCollision(wpn->X+3, wpn->Y+3, wpn->X+12, wpn->Y+12, ComboX(pos), ComboY(pos), ComboX(pos)+15, ComboY(pos)+15) )
				return true;
		}
	}
	return false;
}

item script RecoveryHeart{
	void run(){
		if ( Link->Item[163] )
			Link->HP = Min(Link->HP + 32, Link->MaxHP);
		else
			Link->HP = Min(Link->HP + 16, Link->MaxHP);
	}
}

item script PickupMessage{
	void run(int m){
		Screen->Message(m);
	}
}

item script ForceGem{
	void run(){
		G[G_ForceGemActive] = 600;
		G[G_ForceGemSpeed] = 2;
		G[G_ForceGemDegrees] = 0;
		G[G_ForceGemRadius] = 8;
	}
}

item script DeluxePotion{
	void run(){
		G[G_ForceGemActive] = 600;
		G[G_ForceGemSpeed] = 2;
		G[G_ForceGemDegrees] = 0;
		G[G_ForceGemRadius] = 8;
		G[G_DeluxeMagic] = 600;
	}
}

item script SpecialThing{
	void run(int type){
		if ( type == 1 ) { // power gem
			if ( Game->MCounter[CR_SpiritGemPower] == 0 ) {
				Game->MCounter[CR_SpiritGemPower] = 50;
				Screen->Message(73);
			}
			Game->Counter[CR_SpiritGemPower] ++;
		}
		if ( type == 2 ) { // wisdom gem
			if ( Game->MCounter[CR_SpiritGemWisdom] == 0 ) {
				Game->MCounter[CR_SpiritGemWisdom] = 50;
				Screen->Message(74);
			}
			Game->Counter[CR_SpiritGemWisdom] ++;
		}
		if ( type == 3 ) { // courage gem
			if ( Game->MCounter[CR_SpiritGemCourage] == 0 ) {
				Game->MCounter[CR_SpiritGemCourage] = 50;
				Screen->Message(75);
			}
			Game->Counter[CR_SpiritGemCourage] ++;
		}
		if ( type == 4 ) { // flame token
			if ( Game->MCounter[CR_FlameToken] == 0 ) {
				Game->MCounter[CR_FlameToken] = 50;
				Screen->Message(95);
			}
			Game->Counter[CR_FlameToken] ++;
		}
		if ( type == 5 ) { // health potion
			if ( !Link->Item[30] && !Link->Item[170] )
				Link->Item[29] = true;
			Screen->Message(100);
		}
		if ( type == 6 ) { // deluxe potion
			Link->Item[29] = false;
			Link->Item[30] = true;
			Link->Item[170] = true;
			Screen->Message(133);
		}
		if ( type == 7 ) { // master key
			SetLevelItem(LI_BOSSKEY, true);
			Screen->Message(72);
		}
	}
}

// Put the crystal combo on layer 0.
// “Run Script at Screen Init”.
// If you put multiple of these on the screen, Link has to hit all.
// D0: 0 = temporary, 1 = permanent
ffc script CrystalSecret{
	void run(int perm){
		int pos = ComboAt(this->X+8, this->Y+8);
		if ( perm == 1 && Screen->State[ST_SECRET] ) {
			Screen->ComboD[pos] ++;
			Quit();
		}
		int CMB_Crystal = Screen->ComboD[pos];
		
		while ( !CrystalHit(pos) )
			Waitframe();
		
		Game->PlaySound(67);
		Screen->ComboD[pos] = CMB_Crystal+1;
		
		bool AllHit = true;
		int scriptName[] = "CrystalSecret";
		int scriptNum = Game->GetFFCScript(scriptName);
		for (int i=1; i<=32; ++i) {
			ffc f = Screen->LoadFFC(i);
			if ( f->Script == scriptNum ) {
				if ( Screen->ComboD[ComboAt(f->X+8, f->Y+8)] == CMB_Crystal )
					AllHit = false;
			}
		}
		
		if ( AllHit && !Screen->State[ST_SECRET] ) {
			Game->PlaySound(27);
			Screen->TriggerSecrets();
			if ( perm == 1 )
				Screen->State[ST_SECRET] = true;
		}
	}
}

// Put the crystal combo on layer 0.
// “Run Script at Screen Init”.
// D0: The flag that specifies the region for the remote toggle.
// D1: 0 = toggle, 1 = stay lit
ffc script CrystalRemoteToggle{
	void run(int flag, int stayLit){
		int pos = ComboAt(this->X+8, this->Y+8);
		int CMB_Crystal = Screen->ComboD[pos];
		
		int comboD[176];
		for (int i=0; i<176; ++i) {
			if(Screen->ComboF[i]==flag)
				comboD[i] = Screen->ComboD[i];
			else
				comboD[i] = -1000;
		}
		while(true){
			while ( !CrystalHit(pos) )
				Waitframe();
			
			Game->PlaySound(67);
			Screen->ComboD[pos] = CMB_Crystal+1;
			
			for (int i=0; i<176; ++i) {
				if ( Screen->ComboD[i] == comboD[i] )
					Screen->ComboD[i] = comboD[i] + 1;
				else if ( Screen->ComboD[i] == comboD[i] + 1 )
					Screen->ComboD[i] = comboD[i];
			}
			
			if ( stayLit == 1 )
				Quit();
			
			Waitframes(20);
			
			Screen->ComboD[pos] = CMB_Crystal;
		}
	}
}

ffc script CrystalFanFloorToggle{
	void run(){
		int pos = ComboAt(this->X+8, this->Y+8);
		int CMB_Crystal = Screen->ComboD[pos];
		
		while(true){
			while ( !CrystalHit(pos) )
				Waitframe();
			
			Game->PlaySound(67);
			Screen->ComboD[pos] = CMB_Crystal+1;
			
			Screen->Quake = 12;
			G[G_DungeonFanFloor] ++;
			if ( G[G_DungeonFanFloor] > 3 )
				G[G_DungeonFanFloor] = 1;
			SetFanFloor();
			
			for(int i=1; i<=32; i++){
				ffc f = Screen->LoadFFC(i);
				if ( G[G_DungeonFanFloor] == Game->GetCurDMap() - 26 ) {
					if ( f->Data % 2 == 0 )
						f->Data ++;
				}
				else {
					if ( f->Data % 2 == 1 )
						f->Data --;
				}
			}
			
			Waitframes(20);
			
			Screen->ComboD[pos] = CMB_Crystal;
		}
	}
}

// NPC Script edits from Moosh's DB script
const int LAYER_NPC_CANTALK = 6; //The layer used for the speech bubble
const int CMB_NPC_CANTALK = 2571; //The combo used for the speech bubble
const int CS_NPC_CANTALK = 7; //The CSet used for the speech bubble

ffc script Interactable_NPC{
	void run(int String, int Signpost){
		if ( G[G_Timestop] == 1 )
			Quit();
		//Saves the width and height of the FFC for collision checks
		int Width = 16;
		int Height = 16;
		if(this->EffectWidth!=16)
			Width = this->EffectWidth;
		else if(this->TileWidth>1)
			Width = this->TileWidth*16;
		if(this->EffectHeight!=16)
			Height = this->EffectHeight;
		else if(this->TileHeight>1)
			Height = this->TileHeight*16;
		while(true){
			if ( Link->Z == 0 && LinkCanAttack() ) {
				//Facing Up
				if(Link->Dir==DIR_UP&&Link->Y>=this->Y&&Link->Y<=this->Y+Height-8&&Link->X>=this->X-8&&Link->X<=this->X+Width-8){
					if(Link->PressA){
						Link->InputA = false;
						Link->PressA = false;
						Screen->Message(String);
					}
					else if(CMB_NPC_CANTALK>0)
						Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				}
				//Facing Down
				else if(Signpost == 0 && Link->Dir==DIR_DOWN&&Link->Y>=this->Y-16&&Link->Y<=this->Y+Height-16&&Link->X>=this->X-8&&Link->X<=this->X+Width-8){
					if(Link->PressA){
						Link->InputA = false;
						Link->PressA = false;
						Screen->Message(String);
					}
					else if(CMB_NPC_CANTALK>0)
						Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				}
				//Facing Left
				else if(Signpost == 0 && Link->Dir==DIR_LEFT&&Link->Y>=this->Y-8&&Link->Y<=this->Y+Height-9&&Link->X>=this->X&&Link->X<=this->X+Width){
					if(Link->PressA){
						Link->InputA = false;
						Link->PressA = false;
						Screen->Message(String);
					}
					else if(CMB_NPC_CANTALK>0)
						Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				}
				//Facing Right
				else if(Signpost == 0 && Link->Dir==DIR_RIGHT&&Link->Y>=this->Y-8&&Link->Y<=this->Y+Height-9&&Link->X>=this->X-16&&Link->X<=this->X+Width-16){
					if(Link->PressA){
						Link->InputA = false;
						Link->PressA = false;
						Screen->Message(String);
					}
					else if(CMB_NPC_CANTALK>0)
						Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				}
			}
			Waitframe();
		}
	}
}

ffc script Interactable_Chest{
	void run(){
		if ( Screen->State[ST_CHEST] )
			Quit();
		if ( G[G_Timestop] == 1 )
			Quit();
		//Saves the width and height of the FFC for collision checks
		int Width = 16;
		int Height = 16;
		if(this->EffectWidth!=16)
			Width = this->EffectWidth;
		else if(this->TileWidth>1)
			Width = this->TileWidth*16;
		if(this->EffectHeight!=16)
			Height = this->EffectHeight;
		else if(this->TileHeight>1)
			Height = this->TileHeight*16;
		while(true){
			if ( Screen->ComboT[ComboAt(this->X+8, this->Y+8)] == CT_CHEST2 && Link->Z == 0 && LinkCanAttack() ) {
				//Facing Up
				if(Link->Dir==DIR_UP&&Link->Y>=this->Y&&Link->Y<=this->Y+Height-8&&Link->X>=this->X-8&&Link->X<=this->X+Width-8){
					if(Link->PressA){
						Link->InputA = false;
						Link->PressA = false;
						break;
					}
					else if(CMB_NPC_CANTALK>0)
						Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				}
				//Facing Down
				else if(Link->Dir==DIR_DOWN&&Link->Y>=this->Y-16&&Link->Y<=this->Y+Height-16&&Link->X>=this->X-8&&Link->X<=this->X+Width-8){
					if(Link->PressA){
						Link->InputA = false;
						Link->PressA = false;
						break;
					}
					else if(CMB_NPC_CANTALK>0)
						Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				}
				//Facing Left
				else if(Link->Dir==DIR_LEFT&&Link->Y>=this->Y-8&&Link->Y<=this->Y+Height-9&&Link->X>=this->X&&Link->X<=this->X+Width){
					if(Link->PressA){
						Link->InputA = false;
						Link->PressA = false;
						break;
					}
					else if(CMB_NPC_CANTALK>0)
						Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				}
				//Facing Right
				else if(Link->Dir==DIR_RIGHT&&Link->Y>=this->Y-8&&Link->Y<=this->Y+Height-9&&Link->X>=this->X-16&&Link->X<=this->X+Width-16){
					if(Link->PressA){
						Link->InputA = false;
						Link->PressA = false;
						break;
					}
					else if(CMB_NPC_CANTALK>0)
						Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				}
			}
			Waitframe();
		}
		Screen->ComboD[ComboAt(this->X+8, this->Y+8)] ++;
		Screen->State[ST_CHEST] = true;
		
		item itm = CreateItemAt(Screen->RoomData, Link->X, Link->Y);
		SetItemPickup(itm, IP_HOLDUP, true);
		
		NoAction();
	}
}

ffc script ContinueSaveScreen{
	void run(int type){
		if ( type == 0 ) {
			Game->NumDeaths = Min(Game->NumDeaths+1, 999);
			Game->PlaySound(28);
			Game->PlaySound(19);
			for (int i=0; i<90; ++i) {
				Link->Action = LA_GOTHURTLAND;
				if ( i >= 60 ) {
					Link->DrawYOffset = -1000;
					Screen->FastTile(2, Link->X, Link->Y, Link->Tile, 6, OP_OPAQUE);
				}
				Waitframe();
			}
			
			for (int i=0; i<60; ++i) {
				if ( i % 4 == 0 )
					Link->Dir = RotateDirNum(Link->Dir, 1);
				Screen->FastTile(2, Link->X, Link->Y, Link->Tile, 6, OP_OPAQUE);
				Waitframe();
			}
			
			Game->PlaySound(18);
			
			lweapon Poof = CreateLWeaponAt(LW_SPARKLE, Link->X, Link->Y);
			Poof->DrawYOffset = 0;
			Poof->UseSprite(22);
			
			Waitframes(90);
		}
		
		// save and continue menu
		
		int TXT_Continue[] = "Continue";
		int TXT_SaveAndContinue[] = "Save & Continue";
		int TXT_SaveAndQuit[] = "Save & Quit";
		
		int MainFrameX = 48;
		int MainFrameY = (176+56)/2 - 8 - 5/2*16 - 56;
		
		int Selected = 0;
		int Confirmed;
		int Blinking;
		int colour;
		int selectorX1;
		int selectorX2;
		while(true){
			// bg
			
			Screen->Rectangle(7, 0, -56, 256, 176, 0x0F, 1, 0, 0, 0, true, OP_OPAQUE);
			Screen->DrawTile(7, MainFrameX, MainFrameY, 20100, 10, 5, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
			
			// move selector
			
			if ( Confirmed == 0 ) {
				if ( Link->PressUp ) {
					Game->PlaySound(5);
					Selected --;
					if ( Selected < 0 )
						Selected = 2;
				}
				if ( Link->PressDown ) {
					Game->PlaySound(5);
					Selected ++;
					if ( Selected > 2 )
						Selected = 0;
				}
				
				if ( Link->PressStart || Link->PressA ) {
					Game->PlaySound(68);
					Confirmed = 1;
				}
			}
			
			// text
			
			if ( Selected == 0 && (Confirmed == 0 || Blinking < 2) )
				colour = ColourText2;
			else
				colour = ColourText1;
			Screen->DrawString(7, 128, MainFrameY+20 + 16*0, FONT_Z1, colour, -1, TF_CENTERED, TXT_Continue, OP_OPAQUE);
			
			if ( Selected == 1 && (Confirmed == 0 || Blinking < 2) )
				colour = ColourText2;
			else
				colour = ColourText1;
			Screen->DrawString(7, 128, MainFrameY+20 + 16*1, FONT_Z1, colour, -1, TF_CENTERED, TXT_SaveAndContinue, OP_OPAQUE);
			
			if ( Selected == 2 && (Confirmed == 0 || Blinking < 2) )
				colour = ColourText2;
			else
				colour = ColourText1;
			Screen->DrawString(7, 128, MainFrameY+20 + 16*2, FONT_Z1, colour, -1, TF_CENTERED, TXT_SaveAndQuit, OP_OPAQUE);
			
			// selectors
			
			if ( Selected == 0 ) {
				selectorX1 = 120-8 - strlen(TXT_Continue)*8/2;
				selectorX2 = 120+7 + strlen(TXT_Continue)*8/2;
			}
			if ( Selected == 1 ) {
				selectorX1 = 120-8 - strlen(TXT_SaveAndContinue)*8/2;
				selectorX2 = 120+7 + strlen(TXT_SaveAndContinue)*8/2;
			}
			if ( Selected == 2 ) {
				selectorX1 = 120-8 - strlen(TXT_SaveAndQuit)*8/2;
				selectorX2 = 120+7 + strlen(TXT_SaveAndQuit)*8/2;
			}
			Screen->FastTile(7, selectorX1, MainFrameY+16 + 16*Selected, 20064, 7, OP_OPAQUE);
			Screen->FastTile(7, selectorX2, MainFrameY+16 + 16*Selected, 20065, 7, OP_OPAQUE);
			
			// confirm
			
			if ( Confirmed > 0 ) {
				if ( Confirmed > 45 ) {
					if ( Selected == 0 || Selected == 1 ) {
						G[G_GameStopFreeze] = 0;
						if ( Selected == 1 )
							Game->Save();
						
						Screen->SetSideWarp(0, G[G_ContinueScreen], G[G_ContinueDMap], WT_IWARPOPENWIPE);
						this->Data = CMB_AWarpA;
						
						Link->DrawXOffset = 0;
						Link->DrawYOffset = 0;
						Link->CollDetection = true;
						Link->Invisible = false;
						Link->Dir = DIR_UP;
						
						Link->InputStart = false;
						Link->InputMap = false;
						WaitNoAction();
					}
					if ( Selected == 2 ) {
						G[G_GameStopFreeze] = 0;
						Game->Save();
						Game->End();
					}
				}
				Confirmed ++;
				Blinking ++;
				Blinking %= 4;
			}
			
			Waitframe();
		}
	}
}

ffc script FaroresWindScreen{
	void run(){
		G[G_GameStopFreeze] = 0;
		Screen->SetSideWarp(0, G[G_ContinueScreen], G[G_ContinueDMap], WT_IWARPOPENWIPE);
		this->Data = CMB_AWarpA;
	}
}

ffc script EnemiesSecret{
	void run(){
		if ( Screen->State[ST_SECRET] )
			Quit();
		while ( !EnemiesAlive() )
			Waitframe();
		while ( EnemiesAlive() )
			Waitframe();
		Secrets();
	}
	void Secrets() {
		Game->PlaySound(27);
		Screen->TriggerSecrets();
		Screen->State[ST_SECRET] = true;
		Quit();
	}
}

ffc script AreaNameDisplay{
	void run(int areaID){
		// declare strings
		int String0[] = "- Necluda -";
		int String1[] = "- Hylia -";
		int String2[] = "- Gerudo -";
		int String3[] = "- Zonai -";
		int String4[] = "- Faron -";
		int String5[] = "- Hebra -";
		int String6[] = "- Lanayru -";
		int String7[] = "- Akkala -";
		int String8[] = "- Zorana -";
		int String9[] = "- Eldin -";
		int String10[] = "- Hero's Sanctum -";
		int String11[] = "- Temple of Hylia -";
		int String12[] = "- Temple of Din -";
		int String13[] = "- Temple of Nayru -";
		int String14[] = "- Temple of Farore -";
		int String15[] = "- Trial of Beginnings -";
		int String16[] = "- Trial of Spikes -";
		int String17[] = "- Trial of Strength -";
		int String18[] = "";
		int String19[] = "";
		int String20[] = "";
		int String21[] = "";
		int String22[] = "";
		int String23[] = "";
		int String24[] = "";
		int String25[] = "";
		int String26[] = "";
		int String27[] = "";
		int String28[] = "";
		int String29[] = "";
		int String30[] = "";
		int String31[] = "";
		int String32[] = "";
		int String33[] = "";
		int String34[] = "";
		int String35[] = "";
		int String36[] = "";
		int String37[] = "";
		int String38[] = "";
		int String39[] = "";
		
		// put strings into an array
		int str[40];
		str[0] = String0;
		str[1] = String1;
		str[2] = String2;
		str[3] = String3;
		str[4] = String4;
		str[5] = String5;
		str[6] = String6;
		str[7] = String7;
		str[8] = String8;
		str[9] = String9;
		str[10] = String10;
		str[11] = String11;
		str[12] = String12;
		str[13] = String13;
		str[14] = String14;
		str[15] = String15;
		str[16] = String16;
		str[17] = String17;
		str[18] = String18;
		str[19] = String19;
		str[20] = String20;
		str[21] = String21;
		str[22] = String22;
		str[23] = String23;
		str[24] = String24;
		str[25] = String25;
		str[26] = String26;
		str[27] = String27;
		str[28] = String28;
		str[29] = String29;
		str[30] = String30;
		str[31] = String31;
		str[32] = String32;
		str[33] = String33;
		str[34] = String34;
		str[35] = String35;
		str[36] = String36;
		str[37] = String37;
		str[38] = String38;
		str[39] = String39;
		
		// display the name
		int w = strlen(str[areaID]) + 2;
		int x = 124 - w * 8 / 2;
		
		Screen->SetRenderTarget(6);
		Screen->Rectangle(0, 0, 0, 512, 512, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
		
		Screen->FastTile(0, x, 74, 20070, 7, OP_OPAQUE);
		Screen->FastTile(0, x, 74+16, 20070+20, 7, OP_OPAQUE);
		for (int i=1; i<w; ++i) {
			Screen->FastTile(0, x+i*8, 74, 20071, 7, OP_OPAQUE);
			Screen->FastTile(0, x+i*8, 74+16, 20071+20, 7, OP_OPAQUE);
		}
		Screen->FastTile(0, x+w*8, 74, 20072, 7, OP_OPAQUE);
		Screen->FastTile(0, x+w*8, 74+16, 20072+20, 7, OP_OPAQUE);
		Screen->SetRenderTarget(-1);
		
		for (int i=0; i<120; ++i) {
			Screen->DrawBitmap(7, 6, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
			Screen->DrawString(7, 128, 82, FONT_Z1, 0x01, -1, TF_CENTERED, str[areaID], OP_OPAQUE);
			Waitframe();
		}
		
		this->Data = 0;
		Quit();
	}
}

// The FFC is placed on the screen and given a combo and speed so it starts moving.
// It will then automatically bounce off walls.
// D0: 0 = back and forth or diagonal, -1 = turn countclockwise after hitting wall, 1 = turn clockwise after hitting wall
// D1: Delay before moving again after hitting wall.
ffc script Trap{
	void run(int type, int delay){
		if ( G[G_Timestop] == 1 )
			Quit();
		this->Flags[FFCF_ETHEREAL] = true;
		eweapon wpn = CreateEWeaponAt(EW_SCRIPT10, this->X, this->Y);
		wpn->Damage = 4;
		wpn->DrawXOffset = -1000;
		while(true){
			// check if walls are ahead
			if ( this->Vy > 0 && !CanWalk(this->X, this->Y, DIR_DOWN, 2, true) ) {
				this->Y = ComboY(ComboAt(this->X+8, this->Y+8)); // snap to Y grid
				int oldv = this->Vy;
				this->Vy = 0;
				Game->PlaySound(57);
				Waitframes(delay);
				if ( type == 0 )
					this->Vy = oldv * -1;
				else
					this->Vx = oldv * type * -1;
			}
			if ( this->Vx < 0 && !CanWalk(this->X, this->Y, DIR_LEFT, 2, true) ) {
				this->X = ComboX(ComboAt(this->X+8, this->Y+8)); // snap to X grid
				int oldv = this->Vx;
				this->Vx = 0;
				Game->PlaySound(57);
				Waitframes(delay);
				if ( type == 0 )
					this->Vx = oldv * -1;
				else
					this->Vy = oldv * type;
			}
			if ( this->Vy < 0 && !CanWalk(this->X, this->Y, DIR_UP, 2, true) ) {
				this->Y = ComboY(ComboAt(this->X+8, this->Y+8)); // snap to Y grid
				int oldv = this->Vy;
				this->Vy = 0;
				Game->PlaySound(57);
				Waitframes(delay);
				if ( type == 0 )
					this->Vy = oldv * -1;
				else
					this->Vx = oldv * type * -1;
			}
			if ( this->Vx > 0 && !CanWalk(this->X, this->Y, DIR_RIGHT, 2, true) ) {
				this->X = ComboX(ComboAt(this->X+8, this->Y+8)); // snap to X grid
				int oldv = this->Vx;
				this->Vx = 0;
				Game->PlaySound(57);
				Waitframes(delay);
				if ( type == 0 )
					this->Vx = oldv * -1;
				else
					this->Vy = oldv * type;
			}
			
			// maintain the weapon
			if ( !wpn->isValid() ) {
				wpn = CreateEWeaponAt(EW_SCRIPT10, this->X, this->Y);
				wpn->Damage = 4;
				wpn->DrawXOffset = -1000;
			}
			
			wpn->DeadState = WDS_ALIVE;
			wpn->X = this->X;
			wpn->Y = this->Y;
			
			if ( this->Vx > 0 )
				wpn->Dir = DIR_RIGHT;
			else if ( this->Vx < 0 )
				wpn->Dir = DIR_LEFT;
			else if ( this->Vy > 0 )
				wpn->Dir = DIR_DOWN;
			else if ( this->Vy < 0 )
				wpn->Dir = DIR_UP;
			Waitframe();
		}
	}
}

item script GoddessStone{
	void run(int Stone){
		if ( Stone == 1 ) {
			Screen->Message(3);
			Link->Item[143] = true;
		}
		if ( Stone == 2 ) {
			Screen->Message(6);
			Link->Item[144] = true;
		}
		if ( Stone == 3 ) {
			Screen->Message(9);
			Link->Item[145] = true;
		}
		if ( Stone == 4 ) {
			Screen->Message(13);
			Link->Item[146] = true;
		}
	}
}

ffc script CutsceneSorta{
	void run(int type, int arg1){
		if ( type == 1 ) { // goddess stone room
			if ( Screen->State[ST_SECRET] )
				Quit();
			while ( !Screen->State[ST_ITEM] )
				Waitframe();
			Waitframes(20);
			Screen->TriggerSecrets();
			Screen->State[ST_SECRET] = true;
		}
		if ( type == 2 ) { // 4 goddess stone check
			if ( Screen->State[ST_SECRET] || !Link->Item[143] || !Link->Item[144] || !Link->Item[145] || !Link->Item[146] )
				Quit();
			while ( Link->X > 176 || G[G_NayrusWaterState] > 0 )
				Waitframe();
			
			Game->PlaySound(60);
			lweapon Lights[4];
			for (int i=0; i<4; ++i) {
				Lights[i] = Screen->CreateLWeapon(LW_SCRIPT10);
				Lights[i]->DrawYOffset = 0;
				Lights[i]->UseSprite(108);
				Lights[i]->CollDetection = false;
			}
			Lights[0]->X = 128;
			Lights[0]->Y = 80;
			Lights[1]->X = 128;
			Lights[1]->Y = 48;
			Lights[2]->X = 96;
			Lights[2]->Y = 112;
			Lights[3]->X = 160;
			Lights[3]->Y = 112;
			WaitNoAction(60);
			
			for (int i=0; i<32; ++i) {
				Lights[1]->Y ++;
				Lights[2]->X ++;
				Lights[2]->Y --;
				Lights[3]->X --;
				Lights[3]->Y --;
				WaitNoAction();
			}
			Lights[1]->DeadState = WDS_DEAD;
			Lights[2]->DeadState = WDS_DEAD;
			Lights[3]->DeadState = WDS_DEAD;
			WaitNoAction(20);
			
			Game->PlaySound(48);
			for (int i=0; i<4; ++i) {
				if ( Lights[i]->isValid() )
					Lights[i]->DeadState = WDS_DEAD;
			}
			
			int r;
			for (int i=8; i<108; ++i) {
				r = Min(i, 48);
				if ( G[G_Tictoc16] < 8 )
					r ++;
				Screen->Circle(4, 136, 88, r, 0x87, 1, 0, 0, 0, true, 128);
				if ( i == 78 ) {
					Game->PlaySound(27);
					Screen->TriggerSecrets();
					Screen->State[ST_SECRET] = true;
				}
				WaitNoAction();
			}
			
			for (int i=48; i>0; i-=4) {
				r = i;
				if ( G[G_Tictoc16] < 8 )
					r ++;
				Screen->Circle(4, 136, 88, r, 0x87, 1, 0, 0, 0, true, 128);
				Waitframe();
			}
		}
		if ( type == 3 ) { // savepoint tutorial
			if ( Screen->D[0] == 1 )
				Quit();
			while ( Link->X <= 112 )
				Waitframe();
			Screen->Message(18);
			WaitNoAction();
			Screen->D[0] = 1;
		}
		if ( type == 4 ) { // map tutorial
			if ( Screen->D[0] == 1 )
				Quit();
			while ( !Screen->State[ST_CHEST] )
				Waitframe();
			WaitNoAction();
			Screen->Message(19);
			WaitNoAction();
			Screen->D[0] = 1;
		}
		if ( type == 5 ) { // intro A
			WaitNoAction(60);
			Screen->Message(arg1);
			WaitNoAction();
			this->Data = CMB_AWarpA;
			WaitNoAction();
		}
		if ( type == 6 ) { // intro B
			WaitNoAction(60);
			Screen->Message(33);
			WaitNoAction();
			for (int i=1; i<=3; ++i) {
				ffc f = Screen->LoadFFC(i);
				f->Data = 0;
			}
			WaitNoAction(30);
			
			Screen->Message(37);
			WaitNoAction();
			this->Data = CMB_AWarpA;
			WaitNoAction();
		}
		if ( type == 7 ) { // title screen
			WaitNoAction(30);
			int TXT_Creators[] = "Avaro and Shane";
			int TXT_Present[] = "present";
			int TXT_PressStart[] = "Press Start";
			for (int i=0; i<60; ++i) {
				Screen->DrawTile(7, 0, -56, 28080, 16, 14, 2, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
				WaitNoAction();
			}
			for (int i=0; i<240; ++i) {
				Screen->DrawTile(7, 0, -56, 28080, 16, 14, 2, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
				
				Screen->DrawString(7, 128, 64-6, FONT_Z1, 0x01, -1, TF_CENTERED, TXT_Creators, OP_OPAQUE);
				Screen->DrawString(7, 128, 64+6, FONT_Z1, 0x01, -1, TF_CENTERED, TXT_Present, OP_OPAQUE);
				WaitNoAction();
			}
			
			int Delay = 240;
			while(true){
				Screen->DrawTile(7, 0, -56, 28080, 16, 14, 2, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
				Screen->DrawTile(7, 0, 28, 28360, 16, 4, 8, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
				
				if ( Delay > 0 )
					Delay --;
				else if ( Delay == 0 ) {
					if ( G[G_Tictoc16] < 8 )
						Screen->DrawString(7, 128, 112, FONT_Z1, ColourText1, -1, TF_CENTERED, TXT_PressStart, OP_OPAQUE);
					else
						Screen->DrawString(7, 128, 112, FONT_Z1, ColourText2, -1, TF_CENTERED, TXT_PressStart, OP_OPAQUE);
					
					if ( Link->PressStart ) {
						Game->PlaySound(68);
						Delay = -1;
					}
				}
				else if ( Delay > -60 )
					Delay --;
				else
					break;
				WaitNoAction();
			}
			this->Data = CMB_AWarpA;
			WaitNoAction();
		}
		if ( type == 8 ) { // the hero arrives
			WaitNoAction(60);
			this->Data = 2688;
			this->CSet = 6;
			this->X = 120;
			this->Y = 192;
			this->Vy = -1;
			
			while ( this->Y > 80 )
				WaitNoAction();
			
			Link->Dir = DIR_UP;
			this->Data = CMB_AWarpA;
			WaitNoAction();
		}
		if ( type == 9 ) { // sanctum walk up
			while(true){
				NoAction();
				Link->InputUp = true;
				Waitframe();
			}
		}
		if ( type == 10 ) { // encounter with impa
			while ( Link->Y > 128 ) {
				NoAction();
				Link->InputUp = true;
				Waitframe();
			}
			WaitNoAction(30);
			
			Screen->Message(45);
			WaitNoAction(30);
			
			ffc f = Screen->LoadFFC(1);
			f->Data = 2686;
			f->Vx = 0.5;
			
			while ( f->X < 144 )
				WaitNoAction();
			
			f->Vx = 0;
			Screen->Message(51);
			WaitNoAction();
			
			while ( !Screen->State[ST_ITEM] ) {
				NoAction();
				Link->InputUp = true;
				Waitframe();
			}
			Link->Dir = DIR_DOWN;
			Screen->Message(52);
			WaitNoAction(30);
			
			f->Data = 2684;
			f->Vy = -1.5;
			
			while ( f->Y >= 32 )
				WaitNoAction();
			
			while(true){
				if ( f->Y < -16 )
					f->Data = 0;
				NoAction();
				Link->InputUp = true;
				Waitframe();
			}
		}
		if ( type == 11 ) { // sanctum jump down
			while ( Link->Y > 96 ) {
				NoAction();
				Link->InputUp = true;
				Waitframe();
			}
			Link->Y = 96;
			Link->Dir = DIR_RIGHT;
			WaitNoAction(30);
			
			ffc f = Screen->LoadFFC(1);
			f->Data = 2684;
			
			Screen->Message(59);
			WaitNoAction(60);
			
			while(true){
				NoAction();
				Link->InputUp = true;
				Waitframe();
			}
		}
		if ( type == 12 ) { // pedestal room
			if ( G[G_PedestalCutsceneState] == 0 ) {
				this->Data = CMB_AWarpA;
				WaitNoAction();
			}
		}
		if ( type == 13 ) { // end of sanctum
			while ( Link->Y < 96 ) {
				NoAction();
				Link->InputDown = true;
				Waitframe();
			}
			Link->Y = 96;
			Link->Dir = DIR_RIGHT;
			
			ffc f = Screen->LoadFFC(1);
			f->Data = 2686;
			WaitNoAction(30);
			
			Screen->Message(62);
			WaitNoAction(30);
			
			G[G_PedestalCutsceneState] = 1;
			this->Data = CMB_AWarpA;
			WaitNoAction();
		}
		if ( type == 14 ) { // no dont go
			while(true){
				if ( Link->Y == 160 ) {
					Screen->Message(17);
					WaitNoAction();
					for (int i=0; i<8; ++i) {
						NoAction();
						Link->InputUp = true;
						Waitframe();
					}
				}
				Waitframe();
			}
		}
		if ( type == 15 ) { // dungeon item room
			if ( Screen->State[ST_SECRET] )
				Quit();
			WaitNoAction(25);
			Screen->Message(77-1+arg1);
			NoAction();
			
			while ( !PointWithinRect(Link->X, Link->Y, 104, 72, 136, 88) || G[G_NayrusWaterState] > 0 || G[G_NayrusTimeActive] > 0 )
				Waitframe();
			
			Link->X = 120;
			Link->Y = 88;
			Link->DrawYOffset = -1000;
			for (int i=0; i<45; ++i) {
				Screen->FastTile(4, Link->X, Link->Y, 32073, 6, OP_OPAQUE);
				Screen->FastTile(4, Link->X, Link->Y-16, 23660-1+arg1, 8, OP_OPAQUE);
				WaitNoAction();
			}
			
			Game->PlaySound(60);
			lweapon Lights[2];
			for (int i=0; i<2; ++i) {
				Lights[i] = Screen->CreateLWeapon(LW_SCRIPT10);
				Lights[i]->DrawYOffset = 0;
				Lights[i]->UseSprite(108);
				Lights[i]->CollDetection = false;
			}
			Lights[0]->X = 64;
			Lights[0]->Y = 80;
			Lights[1]->X = 176;
			Lights[1]->Y = 80;
			for (int i=0; i<2; ++i) {
				Lights[i]->Misc[0] = Lights[i]->X;
				Lights[i]->Misc[1] = Lights[i]->Y;
			}
			
			for (int i=0; i<60; ++i) {
				Screen->FastTile(4, Link->X, Link->Y, 32073, 6, OP_OPAQUE);
				Screen->FastTile(4, Link->X, Link->Y-16, 23660-1+arg1, 8, OP_OPAQUE);
				WaitNoAction();
			}
			
			while ( !PointWithinRect(Lights[0]->X+8, Lights[0]->Y+8, 120, 72, 135, 87) ) {
				for (int i=0; i<2; ++i) {
					Lights[i]->Misc[0] += VectorX(1.5, Angle(Lights[i]->Misc[0], Lights[i]->Misc[1], Link->X, Link->Y-16));
					Lights[i]->Misc[1] += VectorY(1.5, Angle(Lights[i]->Misc[0], Lights[i]->Misc[1], Link->X, Link->Y-16));
					Lights[i]->X = Lights[i]->Misc[0];
					Lights[i]->Y = Lights[i]->Misc[1];
				}
				Screen->FastTile(4, Link->X, Link->Y, 32073, 6, OP_OPAQUE);
				Screen->FastTile(4, Link->X, Link->Y-16, 23660-1+arg1, 8, OP_OPAQUE);
				WaitNoAction();
			}
			for (int i=0; i<2; ++i) {
				if ( Lights[i]->isValid() )
					Lights[i]->DeadState = WDS_DEAD;
			}
			
			/*
			Game->PlaySound(48);
			for (int i=8; i<56; ++i) {
				Screen->Circle(5, 128, 80, i, 0x87, 1, 0, 0, 0, true, 128);
				
				Screen->FastTile(4, Link->X, Link->Y, 32073, 6, OP_OPAQUE);
				Screen->FastTile(4, Link->X, Link->Y-16, 23660-1+arg1, 8, OP_OPAQUE);
				WaitNoAction();
			}
			Screen->SetRenderTarget(0);
			Screen->Rectangle(0, 0, 0, 512, 512, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
			Screen->Circle(0, 128, 80, 56, 0x87, 1, 0, 0, 0, true, 128);
			for (int i=4; i<60; ++i) {
				Screen->SetRenderTarget(0);
				Screen->Circle(0, 128, 80, i, 0x00, 1, 0, 0, 0, true, 128);
				Screen->SetRenderTarget(-1);
				Screen->DrawBitmap(5, 0, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
				
				Screen->FastTile(4, Link->X, Link->Y, 32073, 6, OP_OPAQUE);
				Screen->FastTile(4, Link->X, Link->Y-16, 23660-1+arg1, 8, OP_OPAQUE);
				WaitNoAction();
			}
			*/
			
			Game->PlaySound(20);
			if ( arg1 == 1 ) {
				Link->Item[147-1+arg1] = true;
				Screen->Message(83);
				Screen->FastTile(4, Link->X, Link->Y, 32073, 6, OP_OPAQUE);
				Screen->FastTile(4, Link->X, Link->Y-16, 23660-1+arg1, 8, OP_OPAQUE);
				WaitNoAction();
			}
			if ( arg1 == 2 ) {
				Link->Item[147-1+arg1] = true;
				Screen->Message(85);
				Screen->FastTile(4, Link->X, Link->Y, 32073, 6, OP_OPAQUE);
				Screen->FastTile(4, Link->X, Link->Y-16, 23660-1+arg1, 8, OP_OPAQUE);
				WaitNoAction();
			}
			if ( arg1 == 3 ) {
				Link->Item[147-1+arg1] = true;
				Screen->Message(88);
				Screen->FastTile(4, Link->X, Link->Y, 32073, 6, OP_OPAQUE);
				Screen->FastTile(4, Link->X, Link->Y-16, 23660-1+arg1, 8, OP_OPAQUE);
				WaitNoAction();
			}
			if ( arg1 == 4 ) {
				Link->Item[147-1+arg1] = true;
				Screen->Message(90);
				Screen->FastTile(4, Link->X, Link->Y, 32073, 6, OP_OPAQUE);
				Screen->FastTile(4, Link->X, Link->Y-16, 23660-1+arg1, 8, OP_OPAQUE);
				WaitNoAction();
			}
			G[G_ButtonLockHoldA] = 1;
			G[G_ButtonLockHoldB] = 1;
			
			Link->DrawYOffset = 0;
			Waitframes(20);
			Screen->TriggerSecrets();
			Screen->State[ST_SECRET] = true;
		}
	}
}

ffc script LightSwitch{
	void run(){
		G[G_LightSwitchLocked] = 0;
		int Degrees;
		int Spread;
		int Radius;
		while(true){
			if ( SwitchHit(this) && G[G_LightSwitchLocked] == 0 ) {
				Game->PlaySound(36);
				G[G_LightSwitchLocked] = 1;
				if ( G[G_DungeonLightState] == 0 ) {
					G[G_DungeonLightAmbience] = 1;
					G[G_DungeonLightState] = 1;
					SetLightCombos();
					for (int i=0; i<176; ++i) {
						if ( GetLayerComboD(1, i) >= 1300 && GetLayerComboD(1, i) <= 1303 ) { // remove pits
							Screen->ComboD[i] = 0;
						}
					}
					
					Degrees = Rand(360);
					Spread = 1;
					for (int i=0; i<75; ++i) {
						for (int j=0; j<5; ++j) {
							Screen->Triangle(5, this->X+7, this->Y+7,
							this->X+7 + VectorX(300, Degrees-Spread + 360/5*j),
							this->Y+7 + VectorY(300, Degrees-Spread + 360/5*j),
							this->X+7 + VectorX(300, Degrees+Spread + 360/5*j),
							this->Y+7 + VectorY(300, Degrees+Spread + 360/5*j),
							1, 1, 0x01, 0, -1, PT_FLAT);
						}
						
						Degrees += 1.5;
						Degrees %= 360;
						if ( i < 63 ) {
							if ( Spread < 12 )
								Spread ++;
						}
						else {
							if ( Spread > 1 )
								Spread --;
						}
						Waitframe();
					}
				}
				else {
					G[G_DungeonLightAmbience] = 0;
					for (int i=0; i<176; ++i) {
						if ( GetLayerComboT(3, i) == CT_NOGROUNDENEMY ) { // add pits
							Screen->ComboD[i] = GetLayerComboD(3, i);
						}
					}
					
					Radius = 300;
					while ( Radius > 0 ) {
						for (int i=0; i<2; ++i) {
							for (int j=0; j<2; ++j) {
								Screen->Circle(5, this->X+7+i, this->Y+7+j, Radius, 0x01, 1, 0, 0, 0, false, OP_OPAQUE);
							}
						}
						Radius -= 10;
						Waitframe();
					}
					
					G[G_DungeonLightState] = 0;
					SetLightCombos();
				}
				G[G_LightSwitchLocked] = 0;
			}
			Waitframe();
		}
	}
	bool SwitchHit(ffc this) {
		for (int i = Screen->NumLWeapons(); i >= 1; --i) {
			lweapon wpn = Screen->LoadLWeapon(i);
			if ( wpn->ID == LW_SCRIPT1 ) {
				if ( wpn->Misc[0] == LWType_HyliasLight ) {
					if ( PointWithinRect(wpn->X+8, wpn->Y+8, this->X, this->Y, this->X+15, this->Y+15) ) {
						return true;
					}
				}
			}
		}
		return false;
	}
}

ffc script DungeonLightAmbience{
	void run(){
		while ( G[G_DungeonLightAmbience] == 0 || G[G_DungeonLightState] == 0 )
			Waitframe();
		int num;
		int delay;
		while(true){
			Waitframes(Rand(8, 45));
			
			while ( G[G_DungeonLightAmbience] == 0 )
				Waitframe();
			
			num = Choose(Rand(1, 4), Rand(6, 16), Rand(6, 20));
			delay = Choose(1, Rand(16), Rand(16));
			
			if ( num >= 6 && delay == 1 )
			delay = Rand(6, 16);
			int InARow = Rand(4);
			for(int i=0; i<num && G[G_DungeonLightAmbience] == 1; ++i){
				lweapon sparkle = Screen->CreateLWeapon(LW_SPARKLE);
				int rng = Rand(176);
				sparkle->X = Rand(240);
				sparkle->Y = Rand(160);
				sparkle->DrawYOffset = 0;
				sparkle->UseSprite(30);
				
				Waitframes(2);
				if ( InARow == 0 ) {
					Waitframes(delay+2);
					InARow = Rand(4);
				}
				else
					InARow --;
			}
		}
	}
}

// D0: 0 = circle, 1 = bar
// D1: number of ghosts
// D2: number of skipped ghosts
// D3: starting degrees (-1 = random)
// D4: speed (>0 = clockwise, <0 = counterclockwise)
// D5: radius when using circle, in tiles
ffc script GhostsRevolving{
	void run(int type, int arg1, int arg2, int arg3, int arg4, int arg5){
		if ( G[G_DungeonLightState] == 1 )
			Quit();
		
		int NumOfGhosts = arg1;
		int SkippedGhosts = arg2;
		int Degrees = arg3;
		if ( Degrees == -1 )
			Degrees = Rand(360);
		int Speed = arg4;
		int Radius = arg5*16;
		int SineOffset;
		
		int x; int y; int r; int d;
		eweapon Ghost[20];
		int GhostLastX[20];
		int GhostLastY[20];
		while(true){
			if ( type == 0 ) { // circle
				for (int i = SkippedGhosts; i < NumOfGhosts; ++i) {
					r = Radius+3*Sin(SineOffset);
					d = 360/NumOfGhosts*i + Degrees;
					x = this->X + r * Cos(d);
					y = this->Y + r * Sin(d);
					
					if ( !Ghost[i]->isValid() ) {
						Ghost[i] = Screen->CreateEWeapon(EW_SCRIPT10);
						Ghost[i]->DrawYOffset = 0;
						Ghost[i]->Tile = 14348;
						Ghost[i]->Damage = 6;
					}
					Ghost[i]->X = x;
					Ghost[i]->Y = y;
					Ghost[i]->Dir = Link->Dir;
					
					if ( G[G_Tictoc16] % 4 == 0 ) {
						if ( x < GhostLastX[i] )
							Ghost[i]->Tile = 14348;
						if ( x > GhostLastX[i] )
							Ghost[i]->Tile = 14349;
					}
					GhostLastX[i] = x;
					GhostLastY[i] = y;
				}
			}
			if ( type == 1 ) { // bar
				for (int i = SkippedGhosts; i < NumOfGhosts; ++i) {
					r = i*16;
					d = Degrees + 2*Sin(360/NumOfGhosts*i + SineOffset);
					x = this->X + r * Cos(d);
					y = this->Y + r * Sin(d);
					
					if ( !Ghost[i]->isValid() ) {
						Ghost[i] = Screen->CreateEWeapon(EW_SCRIPT10);
						Ghost[i]->DrawYOffset = 0;
						Ghost[i]->Tile = 14348;
						Ghost[i]->Damage = 6;
					}
					Ghost[i]->X = x;
					Ghost[i]->Y = y;
					Ghost[i]->Dir = Link->Dir;
					
					if ( x < GhostLastX[i] )
						if ( x < GhostLastX[i] )
							Ghost[i]->Tile = 14348;
						if ( x > GhostLastX[i] )
							Ghost[i]->Tile = 14349;
					GhostLastX[i] = x;
					GhostLastY[i] = y;
				}
			}
			
			SineOffset += 3;
			SineOffset %= 360;
			Degrees += Speed;
			if ( Degrees > 360 )
				Degrees -= 360;
			else if ( Degrees < 0 )
				Degrees += 360;
			
			Waitframe();
		}
	}
}

// originally by Dimi
ffc script LavaZora{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		Ghost_SetFlag(GHF_STUN);
		Ghost_SetFlag(GHF_CLOCK);
		int Store[18];
		int LASER_COMBO = Ghost_Data;
		Ghost_Data = LASER_COMBO+3;
		Ghost_StoreDefenses(ghost, Store);
		Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
		ghost->CollDetection = false;
		if ( G[G_Timestop] == 1 ) {
			while(true)
				Ghost_Waitframe(this, ghost, true, true);
		}
		int RNG = Rand(30);
		for (int i = 30+RNG; i > 0; --i)
		{
			Ghost_Waitframe(this, ghost, true, true);
		}
		while(true){
			int MehC = FindSpawnPoint(CT_NOGROUNDENEMY, 98);
			for (int i = 1000; i > 0; --i) {
				if ( Screen->ComboS[MehC] == 0000b )
					break;
				else
					MehC = FindSpawnPoint(CT_NOGROUNDENEMY, 98);
			}
			Ghost_X = ComboX(MehC);
			Ghost_Y = ComboY(MehC);
			Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
			Ghost_Data = LASER_COMBO+2;
			for (int i = 30; i > 0; --i)
			{
				Ghost_Waitframe(this, ghost, true, true);
			}
			ghost->CollDetection = true;
			Ghost_Data = LASER_COMBO;
			Ghost_SetDefenses(ghost, Store);
			for (int i = 30; i > 0; --i)
			{
				Ghost_Waitframe(this, ghost, true, true);
			}
			Ghost_Data = LASER_COMBO+1;
			
			FireAimedEWeapon(EW_FIREBALL, Ghost_X, Ghost_Y, 0, 200, ghost->WeaponDamage, -1, -1, 0);
			
			for (int i = 15; i > 0; --i)
			{
				Ghost_Waitframe(this, ghost, true, true);
			}
			Ghost_Data = LASER_COMBO;
			for (int i = 75; i > 0; --i)
			{
				Ghost_Waitframe(this, ghost, true, true);
			}
			Ghost_Data = LASER_COMBO+2;
			Ghost_StoreDefenses(ghost, Store);
			Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
			ghost->CollDetection = false;
			for (int i = 30; i > 0; --i)
			{
				Ghost_Waitframe(this, ghost, true, true);
			}
			Ghost_Data = LASER_COMBO+3;
			RNG = Rand(60);
			for (int i = 60+RNG; i > 0; --i)
			{
				Ghost_Waitframe(this, ghost, true, true);
			}
		}
	}
}

ffc script ProjectileKeese{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		Ghost_SpawnAnimationPuff(this, ghost);
		
		Ghost_SetFlag(GHF_8WAY);
		Ghost_SetFlag(GHF_SET_DIRECTION);
		Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
		Ghost_SetFlag(GHF_FLYING_ENEMY);
		Ghost_SetFlag(GHF_FAKE_Z);
		Ghost_SetFlag(GHF_NO_FALL);
		Ghost_Z = 12;
		Ghost_Y += 12;
		
		int angle = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y);
		while ( PointWithinRect(Ghost_X, Ghost_Y, 2, 2, 238, 158) ) {
			Ghost_X += VectorX(1.5, angle);
			Ghost_Y += VectorY(1.5, angle);
			Ghost_Waitframe(this, ghost, true, true);
		}
		
		Ghost_HP = -1000;
		ghost->HP = -1000;
		Ghost_X = -1000;
		ghost->X = -1000;
		Ghost_Waitframe(this, ghost, true, true);
	}
}

ffc script FireKeese{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		int LastX = ghost->X;
		int LastY = ghost->Y;
		while(true){
			if ( Distance(Ghost_X, Ghost_Y, LastX, LastY) > 8 ) {
				LastX = ghost->X;
				LastY = ghost->Y;
				
				eweapon wpn = FireEWeapon(EW_FIRE, ghost->X, ghost->Y+12, DirRad(ghost->Dir), 0, ghost->WeaponDamage, 80, 0, 0);
				wpn->Z = 12;
				SetEWeaponLifespan(wpn, EWL_TIMER, 75);
				SetEWeaponDeathEffect(wpn, EWD_VANISH, 0);
			}
			Ghost_Waitframe2(this, ghost, true, true);
		}
	}
}

ffc script Dodongo{
	void run(int enemyid){
		int i; int j;
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		Ghost_SpawnAnimationPuff(this, ghost);
		
		Ghost_SetFlag(GHF_4WAY);
		Ghost_SetFlag(GHF_SET_DIRECTION);
		Ghost_SetFlag(GHF_STUN);
		
		ghost->DrawXOffset = -8;
		ghost->DrawYOffset = -10;
		
		int attackCooldown = ghost->Haltrate*15 - Rand(ghost->Haltrate*4);
		bool attackCond;
		
		int walkcounter = -1;
		while(true){
			walkcounter = Ghost_ConstantWalk4(walkcounter, 50, ghost->Rate, ghost->Homing, ghost->Hunger);
			if(attackCooldown>0)
				attackCooldown--;
			else if(Rand(24)==0)
				attackCond = true;
			
			if ( attackCond ) {
				attackCond = false;
				attackCooldown = ghost->Haltrate*15 - Rand(ghost->Haltrate*4);
				
				Ghost_Data = ghost->Attributes[10]+4;
				Dodongo_Waitframes(this, ghost, 12);
				
				int angle = DirAngle(Ghost_Dir);
				for (i = 0; i < 4; ++i) {
					for (j = -12; j <= 12; j += 12) {
						FireEWeapon(EW_FIRE, Ghost_X+VectorX(8, DirAngle(Ghost_Dir)), Ghost_Y+VectorY(8, DirAngle(Ghost_Dir)),
						DegtoRad(angle+j), 40+i*40, ghost->WeaponDamage, -1, -1, 0);
					}
					Dodongo_Waitframes(this, ghost, 8);
				}
				
				Dodongo_Waitframes(this, ghost, 84);
				Ghost_Data = ghost->Attributes[10];
			}
			
			Dodongo_Waitframe(this, ghost);
		}
	}
	void Dodongo_Waitframe(ffc this, npc ghost){
		Ghost_ClearCombos();
		Ghost_AddCombo(Ghost_Data+2*4+Ghost_Dir, 16, 0);
		Ghost_AddCombo(Ghost_Data+4*4+Ghost_Dir, 0, 16);
		Ghost_AddCombo(Ghost_Data+6*4+Ghost_Dir, 16, 16);
		if ( Ghost_Dir == DIR_LEFT || Ghost_Dir == DIR_RIGHT )
			Dodongo_SetHitboxHorizontal(this, ghost);
		else
			Dodongo_SetHitboxVertical(this, ghost);
		Ghost_Waitframe(this, ghost, true, true);
	}
	void Dodongo_Waitframes(ffc this, npc ghost, int num){
		for (int i = num; i > 0; --i)
			Dodongo_Waitframe(this, ghost);
	}
	void Dodongo_SetHitboxHorizontal(ffc this, npc ghost){
		ghost->HitXOffset = -8;
		ghost->HitYOffset = 0;
		ghost->HitWidth = 32;
		ghost->HitHeight = 16;
	}
	void Dodongo_SetHitboxVertical(ffc this, npc ghost){
		ghost->HitXOffset = 0;
		ghost->HitYOffset = -8;
		ghost->HitWidth = 16;
		ghost->HitHeight = 32;
	}
}

ffc script Substitute{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		
		int SpawnID = ghost->Attributes[9];
		if ( SpawnID == 38 && G[G_Timestop] == 1 ) //timestopped keese
			SpawnID = 190;
			
		npc Body = CreateNPCAt(SpawnID, Ghost_X, Ghost_Y);
		
		if ( SpawnID == 190 )
			Body->CollDetection = false;
		
		ghost->CollDetection = false;
		ghost->HitXOffset = -1000;
		
		while ( Body->isValid() )
			Ghost_Waitframe(this, ghost, true, true);
		
		Ghost_HP = -1000;
		ghost->HP = -1000;
		Ghost_X = -1000;
		ghost->X = -1000;
		Ghost_Waitframe(this, ghost, true, true);
	}
}

ffc script FireSkull{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		Ghost_SpawnAnimationPuff(this, ghost);
		
		Ghost_SetFlag(GHF_SET_DIRECTION);
		Ghost_SetFlag(GHF_KNOCKBACK_4WAY);
		Ghost_SetFlag(GHF_STUN);
		
		int HP = Ghost_HP;
		
		int walkcounter = -1;
		while(true){
			walkcounter = Ghost_ConstantWalk4(walkcounter, 50, ghost->Rate, ghost->Homing, ghost->Hunger);
			
			if ( Ghost_HP < HP ) {
				Ghost_Waitframes(this, ghost, true, true, 30);
				
				int angle = RadianAngle(Ghost_X, Ghost_Y, Link->X, Link->Y);
				
				for (int i = 0; i < 3; ++i) {
					eweapon wpn = FireEWeapon(EW_FIREBALL, Ghost_X, Ghost_Y, angle, 250, ghost->WeaponDamage, -1, -1, 0);
					SetEWeaponMovement(wpn, EWM_SINE_WAVE, 6, 6);
					Ghost_Waitframes(this, ghost, true, true, 10);
				}
				
				Ghost_Waitframes(this, ghost, true, true, 20);
				HP = Ghost_HP;
			}
			
			Ghost_Waitframe(this, ghost, true, true);
		}
	}
}

ffc script FlamePad{
	void run(){
		int i; int j;
		while(true){
			if ( PointWithinRect(Link->X+8, Link->Y+12, this->X+8, this->Y+8, this->X+24, this->Y+24) && G[G_NayrusWaterState] == 0 && G[G_NayrusTimeActive] == 0 ) {
				if ( Screen->D[0] == 0 ) {
					if ( Game->Counter[CR_FlameToken] > 0 ) {
						if ( Link->PressA ) {
							G[G_ButtonLockHoldA] = 1;
							G[G_ButtonLockHoldB] = 1;
							Game->Counter[CR_FlameToken] --;
							Game->PlaySound(65);
							Screen->D[0] = 1;
							// add flame pad screen to the array
							G[G_FlamePadScreens+G[G_FlamePadNum]] = Game->GetCurScreen();
							if ( Game->GetCurMap() == 27 )
								G[G_FlamePadScreens+G[G_FlamePadNum]] += 128;
							G[G_FlamePadNum] ++;
							UpdateFlamePads();
						}
						else
							Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
					}
				}
				if ( Screen->D[0] == 1 ) {
					if ( Link->PressA ) {
						G[G_ButtonLockHoldA] = 1;
						G[G_ButtonLockHoldB] = 1;
						if ( G[G_LinkSacredFlameState] == 0 ) { // enabling flame state
							G[G_MP_RegenLock] = 1;
							int radius = 24;
							lweapon flames[10];
							int counter;
							int timer = 4;
							int degrees;
							while(true){
								for (i = 0; i < 5; ++i) {
									if ( i < counter ) {
										for (j = 0; j <= 5; j+=5) {
											if ( !flames[i+j]->isValid() ) {
												flames[i+j] = Screen->CreateLWeapon(LW_SCRIPT10);
												flames[i+j]->DrawYOffset = 0;
												flames[i+j]->UseSprite(12);
												flames[i+j]->CollDetection = false;
											}
											flames[i+j]->X = Link->X + radius * Cos(360/10*(i+j)+degrees);
											flames[i+j]->Y = Link->Y + radius * Sin(360/10*(i+j)+degrees);
										}
									}
								}
								degrees ++;
								if ( timer >= 4 && counter < 5 ) {
									Game->PlaySound(13);
									timer = 0;
									counter ++;
								}
								else if ( timer >= 20 && counter == 5 ) {
									radius -= 1 + ((timer-20)*0.2);
									if ( radius < 8 ) {
										Game->PlaySound(36);
										break;
									}
								}
								else
									timer ++;
								Waitframe();
							}
							for (i = 0; i < 10; ++i) {
								if ( flames[i]->isValid() )
									flames[i]->DeadState = WDS_DEAD;
							}
							G[G_MP_RegenLock] = 0;
							LoseMP(0);
							G[G_LinkSacredFlameState] = 1;
						}
						else { // disabling flame state
							Game->PlaySound(13);
							G[G_LinkSacredFlameState] = 2;
							int radius = 8;
							lweapon flames[10];
							int timer;
							int degrees;
							int x = Link->X;
							int y = Link->Y;
							while(true){
								for (i = 0; i < 10; ++i) {
									if ( !flames[i]->isValid() ) {
										flames[i] = Screen->CreateLWeapon(LW_SCRIPT10);
										flames[i]->DrawYOffset = 0;
										flames[i]->UseSprite(12);
										flames[i]->CollDetection = false;
									}
									flames[i]->X = x + radius * Cos(360/10*i+degrees);
									flames[i]->Y = y + radius * Sin(360/10*i+degrees);
								}
								degrees ++;
								if ( timer == 45 ) {
									for (i = 0; i < 10; ++i) {
										if ( flames[i]->isValid() )
											flames[i]->DrawStyle = DS_PHANTOM;
									}
								}
								if ( timer > 60 )
									break;
								radius += 1 + timer*0.05;
								timer ++;
								Waitframe();
							}
							for (i = 0; i < 10; ++i) {
								if ( flames[i]->isValid() )
									flames[i]->DeadState = WDS_DEAD;
							}
						}
					}
					else
						Screen->FastCombo(LAYER_NPC_CANTALK, Link->X, Link->Y-16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
				}
			}
			Waitframe();
		}
	}
}

// credits to Moosh for the majority of this script
ffc script Fan{
	void run(int dir){
		int i; int j; int k; int x; int y;
		
		if ( G[G_DungeonFanFloor] == Game->GetCurDMap() - 26 )
			this->Data ++;
		Waitframe();
		
		int ThisID;
		for(i=1; i<=32; i++){
			ffc f = Screen->LoadFFC(i);
			if(f==this) {
				ThisID = i;
				break;
			}
		}
		
		int windX1[16];
		int windY1[16];
		int windX2[16];
		int windY2[16];
		int windStep[16];
		int windLength[16];
		int windState[16];
		int windDir[16];
		
		int vars[16] = {dir, 0, 0, 0, windX1, windY1, windX2, windY2, windStep, windLength, windState, windDir};
		
		vars[15] = 60;
		while(true){
			BotWFan_Update(this, vars);
			
			if ( this->Data % 2 == 1 ) {
				x = this->X+8;
				y = this->Y+8;
				// repeating code haha yes
				if ( dir == DIR_UP ) {
					for(i=0; i<14; ++i){
						y -= 16;
						if ( BotWFan_IsSolid(this, x, y) )
							break;
						if ( PointWithinRect(Link->X+8, Link->Y+12, x-8, y-8, x+7, y+7) ) {
							if ( G[G_NayrusWaterState] == 0 ) {
								if ( G[G_NayrusTimeActive] == 0 && MooshPit[_MP_FALLSTATE] == 0 && Link->Z == 0 )
									LinkMovement_Push(0, -1.6*G[G_LinkExtraPush]);
							}
							else {
								if ( G[G_NayrusWaterState] == 4 && G[G_WaterModFFCID] != ThisID && G[G_WaterModPos] != ComboAt(x, y) && G[G_WaterModState] == 0 ) {
									G[G_WaterModFFCID] = ThisID;
									G[G_WaterModPos] = ComboAt(x, y);
									G[G_WaterModState] = 1;
									G[G_WaterModX] = this->X;
									G[G_WaterModY] = G[G_NayrusWaterY];
									G[G_NayrusWaterX] = Round(G[G_NayrusWaterX]);
									G[G_WaterModSpeed] = 0.5;
									G[G_NayrusWaterDir] = DIR_UP;
								}
							}
						}
					}
				}
				else if ( dir == DIR_DOWN ) {
					for(i=0; i<14; ++i){
						y += 16;
						if ( BotWFan_IsSolid(this, x, y) )
							break;
						if ( PointWithinRect(Link->X+8, Link->Y+12, x-8, y-8, x+7, y+7) ) {
							if ( G[G_NayrusWaterState] == 0 ) {
								if ( G[G_NayrusTimeActive] == 0 && MooshPit[_MP_FALLSTATE] == 0 && Link->Z == 0 )
									LinkMovement_Push(0, 1.6*G[G_LinkExtraPush]);
							}
							else {
								if ( G[G_NayrusWaterState] == 4 && G[G_WaterModFFCID] != ThisID && G[G_WaterModPos] != ComboAt(x, y) && G[G_WaterModState] == 0 ) {
									G[G_WaterModFFCID] = ThisID;
									G[G_WaterModPos] = ComboAt(x, y);
									G[G_WaterModState] = 1;
									G[G_WaterModX] = this->X;
									G[G_WaterModY] = G[G_NayrusWaterY];
									G[G_NayrusWaterX] = Round(G[G_NayrusWaterX]);
									G[G_WaterModSpeed] = 0.5;
									G[G_NayrusWaterDir] = DIR_DOWN;
								}
							}
						}
					}
				}
				else if ( dir == DIR_LEFT ) {
					for(i=0; i<14; ++i){
						x -= 16;
						if ( BotWFan_IsSolid(this, x, y) )
							break;
						if ( PointWithinRect(Link->X+8, Link->Y+12, x-8, y-8, x+7, y+7) ) {
							if ( G[G_NayrusWaterState] == 0 ) {
								if ( G[G_NayrusTimeActive] == 0 && MooshPit[_MP_FALLSTATE] == 0 && Link->Z == 0 )
									LinkMovement_Push(-1.6*G[G_LinkExtraPush], 0);
							}
							else {
								if ( G[G_NayrusWaterState] == 4 && G[G_WaterModFFCID] != ThisID && G[G_WaterModPos] != ComboAt(x, y) && G[G_WaterModState] == 0 ) {
									G[G_WaterModFFCID] = ThisID;
									G[G_WaterModPos] = ComboAt(x, y);
									G[G_WaterModState] = 1;
									G[G_WaterModX] = G[G_NayrusWaterX];
									G[G_WaterModY] = this->Y;
									G[G_NayrusWaterY] = Round(G[G_NayrusWaterY]);
									G[G_WaterModSpeed] = 0.5;
									G[G_NayrusWaterDir] = DIR_LEFT;
								}
							}
						}
					}
				}
				else { // right
					for(i=0; i<14; ++i){
						x += 16;
						if ( BotWFan_IsSolid(this, x, y) )
							break;
						if ( PointWithinRect(Link->X+8, Link->Y+12, x-8, y-8, x+7, y+7) ) {
							if ( G[G_NayrusWaterState] == 0 ) {
								if ( G[G_NayrusTimeActive] == 0 && MooshPit[_MP_FALLSTATE] == 0 && Link->Z == 0 )
									LinkMovement_Push(1.6*G[G_LinkExtraPush], 0);
							}
							else {
								if ( G[G_NayrusWaterState] == 4 && G[G_WaterModFFCID] != ThisID && G[G_WaterModPos] != ComboAt(x, y) && G[G_WaterModState] == 0 ) {
									G[G_WaterModFFCID] = ThisID;
									G[G_WaterModPos] = ComboAt(x, y);
									G[G_WaterModState] = 1;
									G[G_WaterModX] = G[G_NayrusWaterX];
									G[G_WaterModY] = this->Y;
									G[G_NayrusWaterY] = Round(G[G_NayrusWaterY]);
									G[G_WaterModSpeed] = 0.5;
									G[G_NayrusWaterDir] = DIR_RIGHT;
								}
							}
						}
					}
				}
			}
			if ( vars[15] == 0 )
				Waitframe();
			else
				vars[15] --;
		}
	}
	void BotWFan_Update(ffc this, int vars){
		int windX1 = vars[4];
		int windY1 = vars[5];
		int windX2 = vars[6];
		int windY2 = vars[7];
		int windStep = vars[8];
		int windLength = vars[9];
		int windState = vars[10];
		int windDir = vars[11];
		
		vars[2] = (vars[2]+1)%360;
		
		if(vars[2]%8==0&&vars[3]<15){
			if ( this->Data % 2 == 1 ) // if the fan is spinning
				BotWFan_CreateWind(this, vars);
		}
		int dist;
		int ang;
		for(int i=0; i<vars[3]; ++i){
			if ( vars[15] == 0 )
				Screen->Line(4, windX1[i], windY1[i], windX2[i], windY2[i], 0x01, 1, 0, 0, 0, OP_OPAQUE);
			
			if(windState[i]==0){
				if(windDir[i]==DIR_UP){
					windY1[i] -= windStep[i];
				}
				else if(windDir[i]==DIR_DOWN){
					windY1[i] += windStep[i];
				}
				else if(windDir[i]==DIR_LEFT){
					windX1[i] -= windStep[i];
				}
				else if(windDir[i]==DIR_RIGHT){
					windX1[i] += windStep[i];
				}
				
				dist = Distance(windX1[i], windY1[i], windX2[i], windY2[i]);
				if(dist>windLength[i])
					windState[i] = 1;
				else if(BotWFan_IsSolid(this, windX1[i], windY1[i]))
					windState[i] = 2;
			}
			else if(windState[i]==1){
				if(windDir[i]==DIR_UP){
					windY1[i] -= windStep[i];
					windY2[i] -= windStep[i];
				}
				else if(windDir[i]==DIR_DOWN){
					windY1[i] += windStep[i];
					windY2[i] += windStep[i];
				}
				else if(windDir[i]==DIR_LEFT){
					windX1[i] -= windStep[i];
					windX2[i] -= windStep[i];
				}
				else if(windDir[i]==DIR_RIGHT){
					windX1[i] += windStep[i];
					windX2[i] += windStep[i];
				}
				
				if(BotWFan_IsSolid(this, windX1[i], windY1[i]))
					windState[i] = 2;
			}
			else{
				dist = Distance(windX1[i], windY1[i], windX2[i], windY2[i]);
				ang = Angle(windX2[i], windY2[i], windX1[i], windY1[i]);
				if(dist>windStep[i]){
					windX2[i] += VectorX(windStep[i], ang);
					windY2[i] += VectorY(windStep[i], ang);
				}
				else{
					int j = vars[3]-1;
					windX1[i] = windX1[j];
					windY1[i] = windY1[j];
					windX2[i] = windX2[j];
					windY2[i] = windY2[j];
					windStep[i] = windStep[j];
					windLength[i] = windLength[j];
					windState[i] = windState[j];
					windDir[i] = windDir[j];
					vars[3]--;
					if ( vars[15] == 0 )
						Screen->Line(4, windX1[i], windY1[i], windX2[i], windY2[i], 0x01, 1, 0, 0, 0, OP_OPAQUE);
				}
			}
		}
	}
	void BotWFan_CreateWind(ffc this, int vars){
		int windX1 = vars[4];
		int windY1 = vars[5];
		int windX2 = vars[6];
		int windY2 = vars[7];
		int windStep = vars[8];
		int windLength = vars[9];
		int windState = vars[10];
		int windDir = vars[11];
		
		int x; int y;
		if(vars[0]==DIR_UP){
			x = this->X+1+Rand(14);
			y = this->Y+3;
		}
		else if(vars[0]==DIR_DOWN){
			x = this->X+1+Rand(14);
			y = this->Y+12;
		}
		else if(vars[0]==DIR_LEFT){
			x = this->X+3;
			y = this->Y+1+Rand(14);
		}
		else if(vars[0]==DIR_RIGHT){
			x = this->X+12;
			y = this->Y+1+Rand(14);
		}
		
		int i = vars[3];
		windX1[i] = x;
		windY1[i] = y;
		windX2[i] = x;
		windY2[i] = y;
		windStep[i] = Rand(4, 6);
		windLength[i] = Rand(60, 100);
		windState[i] = 0;
		windDir[i] = vars[0];
		vars[3]++;
	}
	bool BotWFan_IsSolid(ffc this, int x, int y){
		if ( PointWithinRect(x, y, this->X, this->Y, this->X+15, this->Y+15) )
			return false;
		if ( Screen->MovingBlockX != -1 ) {
			if ( PointWithinRect(x, y, Screen->MovingBlockX, Screen->MovingBlockY, Screen->MovingBlockX+15, Screen->MovingBlockY+15) )
				return true;
		}
		if(x<0||x>255||y<0||y>175)
			return true;
		return Screen->isSolid(x, y);
	}
}

ffc script WaterStream{
	void run(){
		int i; int j; int k; int x; int y;
		int pos = ComboAt(this->X+8, this->Y+8);
		bool LinkPlayedSFX;
		int SolidityPos = -1;
		int SolidityTimer;
		int dir = Screen->ComboD[pos] % 4;
		while(true){
			if ( Screen->ComboD[pos] < 1380 ) {
				x = this->X+8;
				y = this->Y+8;
				// tons of copy pasting because im rushing it and cant be bothered to change it O_o
				if ( dir == DIR_UP ) {
					for(i=0; i<14; ++i){
						y -= 16;
						if ( Screen->ComboD[ComboAt(x, y)] == 896 || Screen->ComboD[ComboAt(x, y)] == 897 ) {
							if ( CanWalk(x-8, y-8, dir, 1, true) ) {
								Game->PlaySound(49);
								lweapon Block = CreateLWeaponAt(LW_SCRIPT1, x-8, y-8);
								Block->DrawYOffset = 0;
								Block->CollDetection = false;
								Block->Tile = Game->ComboTile(Screen->ComboD[ComboAt(x, y)]);
								Block->CSet = 2;
								Block->Misc[0] = LWType_CarriedBlock;
								Block->Misc[1] = Block->Tile;
								Block->Dir = dir;
								Screen->ComboD[ComboAt(x, y)] = 1;
								SolidityPos = ComboAt(x, y);
								SolidityTimer = 10;
							}
						}
						if ( Screen->isSolid(x, y) )
							break;
						if ( PointWithinRect(Link->X+8, Link->Y+8, x-8, y-8, x+7, y+7) ) {
							if ( CanWalk(Link->X, Link->Y, DIR_UP, 1, false) ) {
								if ( G[G_NayrusWaterState] == 0 && G[G_NayrusTimeActive] == 0 && MooshPit[_MP_FALLSTATE] == 0 && Link->Z == 0 ) {
									NoAction();
									LinkMovement_Push(0, -2);
									if ( CanWalk(Link->X, Link->Y, DIR_UP, 8, false) ) {
										Link->Dir = DIR_DOWN;
										Link->HitDir = -1;
										Link->X = x-8;
										if ( !LinkPlayedSFX ) {
											LinkPlayedSFX = true;
											Game->PlaySound(49);
										}
									}
									else
										LinkPlayedSFX = false;
								}
							}
						}
					}
				}
				else if ( dir == DIR_DOWN ) {
					for(i=0; i<14; ++i){
						y += 16;
						if ( Screen->ComboD[ComboAt(x, y)] == 896 || Screen->ComboD[ComboAt(x, y)] == 897 ) {
							if ( CanWalk(x-8, y-8, dir, 1, true) ) {
								Game->PlaySound(49);
								lweapon Block = CreateLWeaponAt(LW_SCRIPT1, x-8, y-8);
								Block->DrawYOffset = 0;
								Block->CollDetection = false;
								Block->Tile = Game->ComboTile(Screen->ComboD[ComboAt(x, y)]);
								Block->CSet = 2;
								Block->Misc[0] = LWType_CarriedBlock;
								Block->Misc[1] = Block->Tile;
								Block->Dir = dir;
								Screen->ComboD[ComboAt(x, y)] = 1;
								SolidityPos = ComboAt(x, y);
								SolidityTimer = 10;
							}
						}
						if ( Screen->isSolid(x, y) )
							break;
						if ( PointWithinRect(Link->X+8, Link->Y+8, x-8, y-8, x+7, y+7) ) {
							if ( CanWalk(Link->X, Link->Y, DIR_DOWN, 1, false) ) {
								if ( G[G_NayrusWaterState] == 0 && G[G_NayrusTimeActive] == 0 && MooshPit[_MP_FALLSTATE] == 0 && Link->Z == 0 ) {
									NoAction();
									LinkMovement_Push(0, 2);
									if ( CanWalk(Link->X, Link->Y, DIR_DOWN, 8, false) ) {
										Link->Dir = DIR_UP;
										Link->HitDir = -1;
										Link->X = x-8;
										if ( !LinkPlayedSFX ) {
											LinkPlayedSFX = true;
											Game->PlaySound(49);
										}
									}
									else
										LinkPlayedSFX = false;
								}
							}
						}
					}
				}
				else if ( dir == DIR_LEFT ) {
					for(i=0; i<14; ++i){
						x -= 16;
						if ( Screen->ComboD[ComboAt(x, y)] == 896 || Screen->ComboD[ComboAt(x, y)] == 897 ) {
							if ( CanWalk(x-8, y-8, dir, 1, true) ) {
								Game->PlaySound(49);
								lweapon Block = CreateLWeaponAt(LW_SCRIPT1, x-8, y-8);
								Block->DrawYOffset = 0;
								Block->CollDetection = false;
								Block->Tile = Game->ComboTile(Screen->ComboD[ComboAt(x, y)]);
								Block->CSet = 2;
								Block->Misc[0] = LWType_CarriedBlock;
								Block->Misc[1] = Block->Tile;
								Block->Dir = dir;
								Screen->ComboD[ComboAt(x, y)] = 1;
								SolidityPos = ComboAt(x, y);
								SolidityTimer = 10;
							}
						}
						if ( Screen->isSolid(x, y) )
							break;
						if ( PointWithinRect(Link->X+8, Link->Y+8, x-8, y-8, x+7, y+7) ) {
							if ( CanWalk(Link->X, Link->Y, DIR_LEFT, 1, false) ) {
								if ( G[G_NayrusWaterState] == 0 && G[G_NayrusTimeActive] == 0 && MooshPit[_MP_FALLSTATE] == 0 && Link->Z == 0 ) {
									NoAction();
									LinkMovement_Push(-2, 0);
									if ( CanWalk(Link->X, Link->Y, DIR_LEFT, 8, false) ) {
										Link->Dir = DIR_RIGHT;
										Link->HitDir = -1;
										Link->Y = y-8;
										if ( !LinkPlayedSFX ) {
											LinkPlayedSFX = true;
											Game->PlaySound(49);
										}
									}
									else
										LinkPlayedSFX = false;
								}
							}
						}
					}
				}
				else { // right
					for(i=0; i<14; ++i){
						x += 16;
						if ( Screen->ComboD[ComboAt(x, y)] == 896 || Screen->ComboD[ComboAt(x, y)] == 897 ) {
							if ( CanWalk(x-8, y-8, dir, 1, true) ) {
								Game->PlaySound(49);
								lweapon Block = CreateLWeaponAt(LW_SCRIPT1, x-8, y-8);
								Block->DrawYOffset = 0;
								Block->CollDetection = false;
								Block->Tile = Game->ComboTile(Screen->ComboD[ComboAt(x, y)]);
								Block->CSet = 2;
								Block->Misc[0] = LWType_CarriedBlock;
								Block->Misc[1] = Block->Tile;
								Block->Dir = dir;
								Screen->ComboD[ComboAt(x, y)] = 1;
								SolidityPos = ComboAt(x, y);
								SolidityTimer = 10;
							}
						}
						if ( Screen->isSolid(x, y) )
							break;
						if ( PointWithinRect(Link->X+8, Link->Y+8, x-8, y-8, x+7, y+7) ) {
							if ( CanWalk(Link->X, Link->Y, DIR_RIGHT, 1, false) ) {
								if ( G[G_NayrusWaterState] == 0 && G[G_NayrusTimeActive] == 0 && MooshPit[_MP_FALLSTATE] == 0 && Link->Z == 0 ) {
									NoAction();
									LinkMovement_Push(2, 0);
									if ( CanWalk(Link->X, Link->Y, DIR_RIGHT, 8, false) ) {
										Link->Dir = DIR_LEFT;
										Link->HitDir = -1;
										Link->Y = y-8;
										if ( !LinkPlayedSFX ) {
											LinkPlayedSFX = true;
											Game->PlaySound(49);
										}
									}
									else
										LinkPlayedSFX = false;
								}
							}
						}
					}
				}
			}
			if ( SolidityTimer > 0 )
				SolidityTimer --;
			else if ( SolidityPos != -1 ) {
				Screen->ComboD[SolidityPos] = 0;
				SolidityPos = -1;
			}
			Waitframe();
		}
	}
}

// this was needed because secrets on FFCs with "draw over" enabled wouldn't appear on the spacebar map
ffc script EnableDrawOver{
	void run(){
		this->Flags[FFCF_OVERLAY] = true;
	}
}

void Boss_FaceLink(ffc this, npc ghost){
	Ghost_ForceDir(AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y)));
}
bool Boss_CanMoveAngle(int angle){
	int vx = VectorX(10, angle);
	int vy = VectorY(10, angle);
	if((vx<0&&!Ghost_CanMove(DIR_LEFT, 1, 0))||(vx>0&&!Ghost_CanMove(DIR_RIGHT, 1, 0)))
		return false;
	if((vy<0&&!Ghost_CanMove(DIR_UP, 1, 0))||(vy>0&&!Ghost_CanMove(DIR_DOWN, 1, 0)))
		return false;
	return true;
}
void Boss_DamageLink(int damage){
	eweapon e = FireEWeapon(EW_SCRIPT10, Link->X+InFrontX(Link->Dir, 12), Link->Y+InFrontY(Link->Dir, 12), 0, 0, damage, -1, -1, EWF_UNBLOCKABLE);
	e->Dir = Link->Dir;
	e->DrawYOffset = -1000;
	SetEWeaponLifespan(e, EWL_TIMER, 1);
	SetEWeaponDeathEffect(e, EWD_VANISH, 0);
}

const int Boss_Ghi_Combo = 0;
const int Boss_Ghi_MaxHP = 1;
const int Boss_Ghi_Type = 2;
const int Boss_Ghi_DiamondState = 3;
const int Boss_Ghi_DiamondX = 4;
const int Boss_Ghi_DiamondY = 5;
const int Boss_Ghi_DiamondVx = 6;
const int Boss_Ghi_DiamondVy = 7;
const int Boss_Ghi_DiamondTile = 8;

ffc script Boss_Ghi{
	void run(int enemyid){
		int rng;
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		
		int combo = ghost->Attributes[10];
		
		int HealthBar_Single[] = "HealthBar_Single";
		int args[8] = {ghost->ID, 0, 0, 1};
		RunFFCScript(Game->GetFFCScript(HealthBar_Single), args);
		
		Ghost_SetFlag(GHF_4WAY);
		Ghost_SetFlag(GHF_SET_DIRECTION);
		
		int BossArr[50];
		BossArr[Boss_Ghi_Combo] = ghost->Attributes[10];
		BossArr[Boss_Ghi_MaxHP] = Ghost_HP;
		BossArr[Boss_Ghi_Type] = ghost->Attributes[9];
		
		if ( BossArr[Boss_Ghi_Type] == 1 ) { // ghi 1
			while(true){
				Boss_Ghi_Walk(this, ghost, BossArr, 150);
				
				// attack A or B
				rng = Rand(2);
				if ( rng == 0 )
					Boss_Ghi_AttackA(this, ghost, BossArr);
				if ( rng == 1 )
					Boss_Ghi_AttackB(this, ghost, BossArr);
				
				Boss_Ghi_Walk(this, ghost, BossArr, 180);
				
				// warp
				Boss_Ghi_WarpOut(this, ghost);
				Boss_Ghi_Waitframes(this, ghost, BossArr, 45);
				Boss_Ghi_WarpInRandom(this, ghost, 0);
				
				// the other attack of A or B
				if ( rng == 1 )
					Boss_Ghi_AttackA(this, ghost, BossArr);
				if ( rng == 0 )
					Boss_Ghi_AttackB(this, ghost, BossArr);
				
				Boss_Ghi_Walk(this, ghost, BossArr, 180);
				
				// attack C
				Boss_Ghi_WarpOut(this, ghost);
				Boss_Ghi_Waitframes(this, ghost, BossArr, 75);
				Boss_Ghi_WarpInRandom(this, ghost, 80);
				Boss_Ghi_AttackC(this, ghost, BossArr);
				Boss_Ghi_WarpOut(this, ghost);
				Boss_Ghi_Waitframes(this, ghost, BossArr, 45);
				Boss_Ghi_WarpInRandom(this, ghost, 0);
			}
		}
		if ( BossArr[Boss_Ghi_Type] == 2 ) { // ghi 2
			Boss_Ghi_Walk(this, ghost, BossArr, 150);
			
			// summon diamond thing
			Game->PlaySound(73);
			Ghost_Data = BossArr[Boss_Ghi_Combo]+12;
			for(int i = 0; i < 80; ++i) {
				if ( i == 20 ) {
					BossArr[Boss_Ghi_DiamondState] = 1;
					BossArr[Boss_Ghi_DiamondX] = Ghost_X-4;
					BossArr[Boss_Ghi_DiamondY] = Ghost_Y-4;
					BossArr[Boss_Ghi_DiamondVx] = Choose(-0.8, 0.8);
					BossArr[Boss_Ghi_DiamondVy] = Choose(-0.6, 0.6);
					BossArr[Boss_Ghi_DiamondTile] = 7990;
				}
				lweapon wpn = CreateLWeaponAt(LW_SCRIPT10, Ghost_X, Ghost_Y);
				wpn->DrawYOffset = 0;
				wpn->CollDetection = false;
				wpn->Tile = 7886+Rand(2);
				wpn->Angular = true;
				wpn->Angle = Rand(360);
				wpn->Step = Rand(240, 300);
				Boss_Ghi_Waitframe(this, ghost, BossArr);
			}
			BossArr[Boss_Ghi_DiamondState] = 2;
			Boss_Ghi_Waitframes(this, ghost, BossArr, 40);
			Ghost_Data = BossArr[Boss_Ghi_Combo];
			
			while(true){
				Boss_Ghi_Walk(this, ghost, BossArr, 150);
				
				// attack A or B
				rng = Rand(2);
				if ( rng == 0 )
					Boss_Ghi_AttackA(this, ghost, BossArr);
				if ( rng == 1 )
					Boss_Ghi_AttackB(this, ghost, BossArr);
				
				// attack C
				Boss_Ghi_WarpOut(this, ghost);
				Boss_Ghi_Waitframes(this, ghost, BossArr, 45);
				Boss_Ghi_WarpInRandom(this, ghost, 80);
				Boss_Ghi_AttackC(this, ghost, BossArr);
				Boss_Ghi_WarpOut(this, ghost);
				Boss_Ghi_Waitframes(this, ghost, BossArr, 45);
				Boss_Ghi_WarpInRandom(this, ghost, 0);
				
				Boss_Ghi_Walk(this, ghost, BossArr, 180);
				
				// the other attack of A or B
				if ( rng == 1 )
					Boss_Ghi_AttackA(this, ghost, BossArr);
				if ( rng == 0 )
					Boss_Ghi_AttackB(this, ghost, BossArr);
				
				// warp
				Boss_Ghi_WarpOut(this, ghost);
				Boss_Ghi_Waitframes(this, ghost, BossArr, 30);
				Boss_Ghi_WarpInRandom(this, ghost, 80);
				
				// repeat attack
				if ( rng == 1 )
					Boss_Ghi_AttackA(this, ghost, BossArr);
				if ( rng == 0 )
					Boss_Ghi_AttackB(this, ghost, BossArr);
				
				Boss_Ghi_Walk(this, ghost, BossArr, 180);
				
				// attack D + multiple C
				Boss_Ghi_WarpOut(this, ghost);
				Boss_Ghi_Waitframes(this, ghost, BossArr, 75);
				Boss_Ghi_WarpInRandom(this, ghost, 80);
				Boss_Ghi_AttackD(this, ghost, BossArr);
				Boss_Ghi_AttackC(this, ghost, BossArr);
				Boss_FaceLink(this, ghost);
				Boss_Ghi_Waitframes(this, ghost, BossArr, 10);
				Boss_Ghi_AttackC(this, ghost, BossArr);
				Boss_FaceLink(this, ghost);
				Boss_Ghi_Waitframes(this, ghost, BossArr, 10);
				Boss_Ghi_AttackC(this, ghost, BossArr);
				Boss_Ghi_WarpOut(this, ghost);
				Boss_Ghi_Waitframes(this, ghost, BossArr, 45);
				Boss_Ghi_WarpInRandom(this, ghost, 0);
			}
		}
	}
}

void Boss_Ghi_Waitframe(ffc this, npc ghost, int BossArr){
	if ( BossArr[Boss_Ghi_DiamondState] > 0 ) {
		// bouncing diamond
		if ( BossArr[Boss_Ghi_DiamondState] == 2 ) {
			BossArr[Boss_Ghi_DiamondX] += BossArr[Boss_Ghi_DiamondVx];
			BossArr[Boss_Ghi_DiamondY] += BossArr[Boss_Ghi_DiamondVy];
			if ( Screen->isSolid(BossArr[Boss_Ghi_DiamondX]+12, BossArr[Boss_Ghi_DiamondY]) ) {
				if ( BossArr[Boss_Ghi_DiamondVy] < 0 )
					BossArr[Boss_Ghi_DiamondVy] *= -1;
			}
			if ( Screen->isSolid(BossArr[Boss_Ghi_DiamondX]+12, BossArr[Boss_Ghi_DiamondY]+23) ) {
				if ( BossArr[Boss_Ghi_DiamondVy] > 0 )
					BossArr[Boss_Ghi_DiamondVy] *= -1;
			}
			if ( Screen->isSolid(BossArr[Boss_Ghi_DiamondX], BossArr[Boss_Ghi_DiamondY]+12) ) {
				if ( BossArr[Boss_Ghi_DiamondVx] < 0 )
					BossArr[Boss_Ghi_DiamondVx] *= -1;
			}
			if ( Screen->isSolid(BossArr[Boss_Ghi_DiamondX]+23, BossArr[Boss_Ghi_DiamondY]+12) ) {
				if ( BossArr[Boss_Ghi_DiamondVx] > 0 )
					BossArr[Boss_Ghi_DiamondVx] *= -1;
			}
		}
		// collision
		if ( RectCollision(Link->X+2, Link->Y+4, Link->X+13, Link->Y+13, BossArr[Boss_Ghi_DiamondX]+4, BossArr[Boss_Ghi_DiamondY]+4, BossArr[Boss_Ghi_DiamondX]+19, BossArr[Boss_Ghi_DiamondY]+19) )
			Boss_DamageLink(ghost->Damage);
		// animation
		if ( G[G_Tictoc16] % 4 == 0 ) {
			BossArr[Boss_Ghi_DiamondTile] += 2;
			if ( BossArr[Boss_Ghi_DiamondTile] > 7906 )
				BossArr[Boss_Ghi_DiamondTile] = 7900;
			// spawn diamonds
			lweapon wpn = CreateLWeaponAt(LW_SCRIPT1, BossArr[Boss_Ghi_DiamondX]+4, BossArr[Boss_Ghi_DiamondY]+4);
			wpn->DrawYOffset = 0;
			wpn->CollDetection = false;
			wpn->Tile = 7886+Rand(2);
			wpn->Angular = true;
			wpn->Angle = Rand(360);
			wpn->Step = Rand(20, 60);
			wpn->Misc[15] = Rand(10, 30);
		}
		Screen->DrawTile(1, BossArr[Boss_Ghi_DiamondX], BossArr[Boss_Ghi_DiamondY], BossArr[Boss_Ghi_DiamondTile], 2, 2, 8, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
	}
	if(!Ghost_Waitframe(this, ghost, false, false)) {
		for (int i = Screen->NumEWeapons(); i >= 1; --i) {
			eweapon wpn = Screen->LoadEWeapon(i);
			if ( wpn->ID == EW_BEAM )
				wpn->DeadState = WDS_DEAD;
		}
		Quit();
	}
}
void Boss_Ghi_Waitframes(ffc this, npc ghost, int BossArr, int num){
	for(int i = 0; i < num; ++i)
		Boss_Ghi_Waitframe(this, ghost, BossArr);
}

void Boss_Ghi_DiamondExplosion(int x, int y){
	for(int i = 0; i < 20; ++i) {
		lweapon wpn = CreateLWeaponAt(LW_SCRIPT1, x, y);
		wpn->DrawYOffset = 0;
		wpn->CollDetection = false;
		wpn->Tile = Rand(7880, 7885);
		wpn->Angular = true;
		wpn->Angle = DegtoRad(Rand(360));
		wpn->Step = Rand(20, 60);
		wpn->Misc[15] = Rand(10, 30);
	}
}

void Boss_Ghi_WarpOut(ffc this, npc ghost){
	Game->PlaySound(70);
	Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
	ghost->CollDetection = false;
	ghost->DrawXOffset = -1000;
	Boss_Ghi_DiamondExplosion(Ghost_X, Ghost_Y);
}

void Boss_Ghi_WarpIn(ffc this, npc ghost, int x, int y){
	Game->PlaySound(71);
	Ghost_X = x;
	Ghost_Y = y;
	Ghost_SetAllDefenses(ghost, NPCDT_NONE);
	ghost->CollDetection = true;
	ghost->DrawXOffset = 0;
	Boss_FaceLink(this, ghost);
	Boss_Ghi_DiamondExplosion(Ghost_X, Ghost_Y);
}

void Boss_Ghi_WarpInRandom(ffc this, npc ghost, int minDist){
	int p = FindSpawnPoint(true, false, false, false);
	for(int i = 0; i < 1000; ++i) {
		if ( Distance(ComboX(p), ComboY(p), Link->X, Link->Y) < minDist )
			p = FindSpawnPoint(true, false, false, false);
		else
			break;
	}
	int x = ComboX(p);
	int y = ComboY(p);
	Boss_Ghi_WarpIn(this, ghost, x, y);
}

void Boss_Ghi_Walk(ffc this, npc ghost, int BossArr, int num){
	for(int i = 0; i < num; ++i) {
		Ghost_MoveAtAngle(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y), 0.4, 4);
		Boss_Ghi_Waitframe(this, ghost, BossArr);
	}
}

void Boss_Ghi_AttackA(ffc this, npc ghost, int BossArr){
	Boss_Ghi_Waitframes(this, ghost, BossArr, 12);
	Boss_FaceLink(this, ghost);
	Ghost_Data = BossArr[Boss_Ghi_Combo]+4;
	
	Game->PlaySound(72);
	int a = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y);
	for(int i=0; i<3; i++){
		eweapon wpn = FireEWeapon(EW_BEAM, Ghost_X, Ghost_Y, DegtoRad(a-90), 20+40*i, ghost->WeaponDamage, 113, -1, EWF_ROTATE_360);
		SetEWeaponLifespan(wpn, EWL_TIMER, 30);
		SetEWeaponDeathEffect(wpn, EWD_AIM_AT_LINK, 16);
	}
	for(int i=0; i<3; i++){
		eweapon wpn = FireEWeapon(EW_BEAM, Ghost_X, Ghost_Y, DegtoRad(a+90), 20+40*i, ghost->WeaponDamage, 113, -1, EWF_ROTATE_360);
		SetEWeaponLifespan(wpn, EWL_TIMER, 30);
		SetEWeaponDeathEffect(wpn, EWD_AIM_AT_LINK, 16);
	}
	
	Boss_Ghi_Waitframes(this, ghost, BossArr, 32);
	Ghost_Data = BossArr[Boss_Ghi_Combo];
}

void Boss_Ghi_AttackB(ffc this, npc ghost, int BossArr){
	Boss_Ghi_Waitframes(this, ghost, BossArr, 12);
	Boss_FaceLink(this, ghost);
	Ghost_Data = BossArr[Boss_Ghi_Combo]+4;
	
	Game->PlaySound(72);
	eweapon wpn[4];
	int a = Rand(360);
	for(int i=0; i<4; i++){
		wpn[i] = FireEWeapon(EW_BEAM, Ghost_X, Ghost_Y, 0, 0, ghost->WeaponDamage, 113, -1, EWF_ROTATE_360);
	}
	
	for(int j=8; j>0; j-=0.1){
		for(int i=0; i<4; i++){
			if ( !wpn[i]->isValid() ) {
				wpn[i] = FireEWeapon(EW_BEAM, Ghost_X, Ghost_Y, 0, 0, ghost->WeaponDamage, 113, -1, EWF_ROTATE_360);
			}
			if ( wpn[i]->isValid() ) {
				wpn[i]->X = Link->X + 56 * Cos(360/4*i+a);
				wpn[i]->Y = Link->Y + 56 * Sin(360/4*i+a);
				wpn[i]->Angle = RadianAngle(wpn[i]->X, wpn[i]->Y, Link->X, Link->Y);
			}
		}
		a -= j-1;
		Boss_FaceLink(this, ghost);
		Boss_Ghi_Waitframe(this, ghost, BossArr);
	}
	int x = Link->X;
	int y = Link->Y;
	for(int i=0; i<24; i++){
		for(int i=0; i<4; i++){
			if ( !wpn[i]->isValid() ) {
				wpn[i] = FireEWeapon(EW_BEAM, Ghost_X, Ghost_Y, 0, 0, ghost->WeaponDamage, 113, -1, EWF_ROTATE_360);
			}
			if ( wpn[i]->isValid() ) {
				wpn[i]->X = x + 56 * Cos(360/4*i+a);
				wpn[i]->Y = y + 56 * Sin(360/4*i+a);
				wpn[i]->Angle = RadianAngle(wpn[i]->X, wpn[i]->Y, x, y);
			}
		}
		a -= -1+0.04*i;
		Boss_FaceLink(this, ghost);
		Boss_Ghi_Waitframe(this, ghost, BossArr);
	}
	for(int i=0; i<4; i++){
		if ( wpn[i]->isValid() ) {
			wpn[i]->Step = 300;
			SetEWeaponLifespan(wpn[i], EWL_TIMER, 18);
			SetEWeaponDeathEffect(wpn[i], EWD_VANISH, 0);
		}
	}
	
	Boss_Ghi_Waitframes(this, ghost, BossArr, 12);
	Ghost_Data = BossArr[Boss_Ghi_Combo];
}

void Boss_Ghi_AttackC(ffc this, npc ghost, int BossArr){
	Boss_Ghi_Waitframes(this, ghost, BossArr, 12);
	Boss_FaceLink(this, ghost);
	Ghost_Data = BossArr[Boss_Ghi_Combo]+4;
	
	Game->PlaySound(1);
	int a = Angle(Ghost_X, Ghost_Y, Link->X, Max(34, Link->Y));
	int s = 1;
	eweapon wpn = FireEWeapon(EW_BEAM, Ghost_X+VectorX(12, a), Ghost_Y+VectorY(14, a), DegtoRad(a), 0, ghost->WeaponDamage, 113, -1, EWF_ROTATE_360);
	while(Boss_CanMoveAngle(a)){
		s = Min(s+0.2, 2.6);
		Ghost_MoveAtAngle(a, s, 0);
		wpn->X = Ghost_X+VectorX(12, a);
		wpn->Y = Ghost_Y+VectorY(12, a);
		wpn->DeadState = WDS_ALIVE;
		Boss_Ghi_Waitframe(this, ghost, BossArr);
	}
	wpn->DeadState = WDS_DEAD;
	
	Boss_Ghi_Waitframes(this, ghost, BossArr, 4);
	Ghost_Data = BossArr[Boss_Ghi_Combo];
}

void Boss_Ghi_AttackD(ffc this, npc ghost, int BossArr){
	Boss_Ghi_Waitframes(this, ghost, BossArr, 12);
	Boss_FaceLink(this, ghost);
	Ghost_Data = BossArr[Boss_Ghi_Combo]+4;
	
	Game->PlaySound(72);
	int a = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y);
	for(int i=0; i<5; i++){
		eweapon wpn = FireEWeapon(EW_BEAM, Ghost_X, Ghost_Y, DegtoRad(a), 120, ghost->WeaponDamage, 113, -1, EWF_ROTATE_360);
		SetEWeaponMovement(wpn, EWM_HOMING_REAIM, 4, 60);
	}
	
	Boss_Ghi_Waitframes(this, ghost, BossArr, 24);
	Ghost_Data = BossArr[Boss_Ghi_Combo];
}

ffc script TimestopCrystal{
	void run(){
		if ( G[G_Timestop] == 1 )
			this->Data = 1293;
		Waitframe();
		int i; int j;
		while(true){
			if ( Hit(this) ) {
				if ( G[G_Timestop] == 0 ) {
					for(i=0; i<5; i++){
						Screen->Rectangle(6, 0, 0, 256, 176, 0x01, 1, 0, 0, 0, true, OP_TRANS);
						Waitframe();
					}
					for(i=0; i<5; i++){
						Screen->Rectangle(6, 0, 0, 256, 176, 0x01, 1, 0, 0, 0, true, OP_OPAQUE);
						if ( i == 4 ) {
							for(int i=1; i<=32; i++){
								ffc f = Screen->LoadFFC(i);
								if ( f->Script == 33 )
									f->Data = 1293;
							}
							Game->PlaySound(35);
							G[G_Timestop] = 1;
							SetTimestop();
						}
						Waitframe();
					}
					
					for(i=0; i<60; i++){
						if ( i < 5 )
							Screen->Rectangle(6, 0, 0, 256, 176, 0x01, 1, 0, 0, 0, true, OP_TRANS);
						Screen->Wavy = (60-i)*0.5;
						Waitframe();
					}
					Screen->Wavy = 0;
				}
				else {
					for(i=0; i<45; i++){
						Screen->Wavy = i*0.5;
						if ( i == 10 )
							Game->PlaySound(75);
						if ( i >= 40 )
							Screen->Rectangle(6, 0, 0, 256, 176, 0x01, 1, 0, 0, 0, true, OP_TRANS);
						Waitframe();
					}
					Screen->Wavy = 0;
					
					for(i=0; i<5; i++){
						Screen->Rectangle(6, 0, 0, 256, 176, 0x01, 1, 0, 0, 0, true, OP_OPAQUE);
						if ( i == 4 ) {
							for(int i=1; i<=32; i++){
								ffc f = Screen->LoadFFC(i);
								if ( f->Script == 33 )
									f->Data = 1292;
							}
							G[G_Timestop] = 0;
							SetTimestop();
						}
						Waitframe();
					}
					for(i=0; i<5; i++){
						Screen->Rectangle(6, 0, 0, 256, 176, 0x01, 1, 0, 0, 0, true, OP_TRANS);
						Waitframe();
					}
				}
			}
			Waitframe();
		}
	}
	bool Hit(ffc this) {
		for (int i = Screen->NumLWeapons(); i >= 1; --i) {
			lweapon wpn = Screen->LoadLWeapon(i);
			if ( wpn->ID == LW_SWORD ) {
				if ( RectCollision(wpn->X+3, wpn->Y+3, wpn->X+12, wpn->Y+12, this->X, this->Y, this->X+15, this->Y+31) ) {
					return true;
				}
			}
		}
		return false;
	}
}

ffc script HotRoom{
	void run(){
		if ( G[G_HotRoomFrames] == 0 && G[G_LinkSacredFlameState] == 0 ) {
			Screen->Message(96);
			WaitNoAction();
		}
		int TimeLeft;
		int DrawnNumber;
		int Colour;
		while(true){
			Screen->Wavy = 2;
			
			if ( G[G_LinkSacredFlameState] == 0 ) {
				TimeLeft = 180 - G[G_HotRoomFrames];
				if ( TimeLeft <= 0 )
					DrawnNumber = 0;
				else if ( TimeLeft <= 60 )
					DrawnNumber = 1;
				else if ( TimeLeft <= 120 )
					DrawnNumber = 2;
				else if ( TimeLeft <= 180 )
					DrawnNumber = 3;
				if ( DrawnNumber > 0 || (G[G_Tictoc16] % 8) < 4 )
					Colour = 0x01;
				else
					Colour = 0x82;
				
				Screen->DrawInteger(5, Link->X+5, Link->Y-12, FONT_Z1, Colour, -1, -1, -1, DrawnNumber, 0, OP_OPAQUE);
				
				if ( G[G_HotRoomFrames] < 180 )
					G[G_HotRoomFrames] ++;
				else {
					Game->PlaySound(23);
					Link->HP -= 4;
				}
			}
			Waitframe();
		}
	}
}

int CMB_HFlower1 = 1472;
int CMB_HFlower2 = 1473;
int CMB_HFlower3 = 1474;
int CMB_HFlower4 = 1475;
ffc script HamiltonianFlowers{
	void run(){
		int i;
		if ( Screen->State[ST_SECRET] ) {
			for(i=0; i<176; i++){
				if ( Screen->ComboD[i] == CMB_HFlower1 )
					Screen->ComboD[i] = CMB_HFlower3;
			}
			Quit();
		}
		Waitframe();
		int LastFlowerPos = -1;
		int LinkTrackerX = Link->X;
		int LinkTrackerY = Link->Y;
		while(true){
			for(i=0; i<1000; i++){
				if ( Link->X < LinkTrackerX ) {
					LinkTrackerX --;
					LastFlowerPos = Hamiltonian(LinkTrackerX, LinkTrackerY, LastFlowerPos);
				}
				else if ( Link->X > LinkTrackerX ) {
					LinkTrackerX ++;
					LastFlowerPos = Hamiltonian(LinkTrackerX, LinkTrackerY, LastFlowerPos);
				}
				else if ( Link->Y < LinkTrackerY ) {
					LinkTrackerY --;
					LastFlowerPos = Hamiltonian(LinkTrackerX, LinkTrackerY, LastFlowerPos);
				}
				else if ( Link->Y > LinkTrackerY ) {
					LinkTrackerY ++;
					LastFlowerPos = Hamiltonian(LinkTrackerX, LinkTrackerY, LastFlowerPos);
				}
				else
					break;
			}
			Waitframe();
		}
	}
	int Hamiltonian(int x, int y, int LastFlowerPos){
		if ( G[G_NayrusTimeActive] == 0 ) {
			int LinkPos = ComboAt(x+8, y+12);
			if ( Screen->ComboD[LinkPos] == CMB_HFlower3 ) {
				Game->PlaySound(64);
				for(int i=0; i<176; i++){
					if ( Screen->ComboD[i] == CMB_HFlower2 || Screen->ComboD[i] == CMB_HFlower3 )
						Screen->ComboD[i] = CMB_HFlower4;
				}
				Quit();
			}
			if ( Screen->ComboD[LinkPos] == CMB_HFlower1 ) {
				Game->PlaySound(60);
				Screen->ComboD[LinkPos] = CMB_HFlower2;
				if ( LastFlowerPos > -1 )
					Screen->ComboD[LastFlowerPos] = CMB_HFlower3;
				LastFlowerPos = LinkPos;
				bool win = true;
				for(int i=0; i<176; i++){
					if ( Screen->ComboD[i] == CMB_HFlower1 )
						win = false;
				}
				if ( win ) {
					Screen->ComboD[LinkPos] = CMB_HFlower3;
					Game->PlaySound(27);
					Screen->TriggerSecrets();
					Screen->State[ST_SECRET] = true;
					Quit();
				}
			}
		}
		return LastFlowerPos;
	}
}

ffc script ShopItem{
	void run(int String, int ShopItem, int ShopPrice, int Limited, int ScreenD){
		if ( Limited == 1 && Screen->D[ScreenD] == 1 ) {
			this->Data = 1;
			Quit();
		}
		Waitframe();
		int String1[100];
		int Buffer[100];
		int Info[] = "Info";
		int BuyFor[] = "Buy for ";
		
		strcat(String1, BuyFor);
		itoa(Buffer, ShopPrice);
		strcat(String1, Buffer);
		
		int DigitOffset = 8;
		if ( ShopPrice > 9 )
			DigitOffset = 4;
		if ( ShopPrice > 99 )
			DigitOffset = 0;
		while(true){
			if ( PointWithinRect(Link->X+8, Link->Y+12, this->X, this->Y, this->X+15, this->Y+15) ) {
				if ( Link->PressL ){
					Link->InputL = false;
					Link->PressL = false;
					if ( Game->Counter[CR_RUPEES] >= ShopPrice ) {
						Game->DCounter[CR_RUPEES] -= ShopPrice;
						item drop = CreateItemAt(ShopItem, Link->X, Link->Y);
						SetItemPickup(drop, IP_HOLDUP, true);
						
						if ( Limited == 1 ) {
							this->Data = 1;
							Screen->D[ScreenD] = 1;
							WaitNoAction();
							G[G_ButtonLockHoldA] = 1;
							G[G_ButtonLockHoldB] = 1;
							Quit();
						}
						
						WaitNoAction();
						G[G_ButtonLockHoldA] = 1;
						G[G_ButtonLockHoldB] = 1;
					}
					else {
						Game->PlaySound(64);
						Screen->Message(98);
					}
				}
				else if( Link->PressA ){
					Link->InputA = false;
					Link->PressA = false;
					Screen->Message(String);
				}
				else {
					int x = Link->X-64;
					int y = Link->Y-Link->Z-48;
					
					Screen->DrawTile(LAYER_NPC_CANTALK, x, y, 20200, 9, 3, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
					
					Screen->FastCombo(LAYER_NPC_CANTALK, x+8+DigitOffset, y+8, 2574, 7, 128);
					Screen->FastCombo(LAYER_NPC_CANTALK, x+8+36, y+8+16, CMB_NPC_CANTALK, CS_NPC_CANTALK, 128);
					Screen->FastCombo(LAYER_NPC_CANTALK, x+120-DigitOffset, y+8, 1467, 7, 128);
					
					Screen->DrawString(LAYER_NPC_CANTALK, x+8+20+DigitOffset, y+12, FONT_Z1, 0x82, -1, TF_NORMAL, String1, OP_OPAQUE);
					Screen->DrawString(LAYER_NPC_CANTALK, x+8+20+DigitOffset, y+12, FONT_Z1, 0x01, -1, TF_NORMAL, BuyFor, OP_OPAQUE);
					Screen->DrawString(LAYER_NPC_CANTALK, x+8+36+20, y+12+16, FONT_Z1, 0x01, -1, TF_NORMAL, Info, OP_OPAQUE);
				}
			}
			Waitframe();
		}
	}
}

ffc script EndlessPath{
	void run(int type){
		G[G_LinksCurrDMap] = -1;
		G[G_LinksCurrScreen] = -1;
		Waitframe();
		
		if ( G[G_EndlessPaths] == -1 ) // dont count the first entering
			G[G_EndlessPaths] = 1000;
		else {
			int EnteredDir;
			if ( Link->Y > 152 )
				EnteredDir = DIR_UP;
			if ( Link->Y < 8 )
				EnteredDir = DIR_DOWN;
			if ( Link->X > 232 )
				EnteredDir = DIR_LEFT;
			if ( Link->X < 8 )
				EnteredDir = DIR_RIGHT;
			
			G[G_EndlessPaths + 2] = G[G_EndlessPaths + 1];
			G[G_EndlessPaths + 1] = G[G_EndlessPaths];
			G[G_EndlessPaths] = EnteredDir;
		}
		
		if ( type == 0 ) { // faron
			if ( Link->Item[164] )
				if ( G[G_EndlessPaths + 2] == DIR_LEFT && G[G_EndlessPaths + 1] == DIR_UP && G[G_EndlessPaths] == DIR_LEFT )
					Screen->SetSideWarp(0, 0x71, -1, -1);
			if ( Link->Item[165] )
				if ( G[G_EndlessPaths + 2] == DIR_DOWN && G[G_EndlessPaths + 1] == DIR_LEFT && G[G_EndlessPaths] == DIR_UP )
					Screen->SetSideWarp(1, 0x60, -1, -1);
			while(true){
				if ( Link->Item[164] )
					Screen->DrawTile(6, 8, 0, 19525, 4, 2, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
				if ( Link->Item[165] ) {
					if ( !Link->Item[164] )
						Screen->DrawTile(6, 8, 0, 19529, 4, 2, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
					else
						Screen->DrawTile(6, 8, 32, 19529, 4, 2, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
				}
				Waitframe();
			}
		}
		else { // akkala
			if ( Link->Item[166] )
				if ( G[G_EndlessPaths + 2] == DIR_LEFT && G[G_EndlessPaths + 1] == DIR_DOWN && G[G_EndlessPaths] == DIR_UP )
					Screen->SetSideWarp(0, 0x0B, -1, -1);
			while(true){
				if ( Link->Item[166] )
					Screen->DrawTile(6, 8, 0, 19533, 4, 2, 8, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
				Waitframe();
			}
		}
	}
}

ffc script EndlessPathEntrances{
	void run(int type){
		bool PlaySound;
		if ( type == 1 ) // faron
			if ( G[G_EndlessPaths + 2] == DIR_LEFT && G[G_EndlessPaths + 1] == DIR_UP && G[G_EndlessPaths] == DIR_LEFT )
				PlaySound = true;
		if ( type == 2 ) // to hebra
			if ( G[G_EndlessPaths + 2] == DIR_DOWN && G[G_EndlessPaths + 1] == DIR_LEFT && G[G_EndlessPaths] == DIR_UP )
				PlaySound = true;
		if ( type == 3 ) // akkala
			if ( G[G_EndlessPaths + 2] == DIR_LEFT && G[G_EndlessPaths + 1] == DIR_DOWN && G[G_EndlessPaths] == DIR_UP )
				PlaySound = true;
		
		// reset path vars
		for(int i=0; i<3; i++)
			G[G_EndlessPaths + i] = -1;
		
		Waitframe();
		if ( PlaySound )
			Game->PlaySound(27);
	}
}

// unused menu design
/*
ffc script FairyFountain{
	void run(){
		int FrameX = 24;
		int FrameY = 16;
		
		int Row1Y = FrameY+24 + 34*0;
		int Row2Y = FrameY+24 + 34*1;
		int Row3Y = FrameY+24 + 34*2;
		int FinalRowY = FrameY + 122;
		
		int CircleFrameX = FrameX + 8;
		int CircleItemX = FrameX + 16;
		
		int LeftValueX = CircleFrameX + 32 + 12;
		int ArrowX = LeftValueX + 9;
		int RightValueX = LeftValueX + 34;
		
		int UnitTextX = RightValueX + 16;
		
		int PotentialX = FrameX + 160;
		
		int BButtonX = FrameX + 32;
		int BTextX = BButtonX + 20;
		int AButtonX = BTextX + 48;
		int ATextX = AButtonX + 20;
		
		int Buffer[30];
		int Text_Power[] = "Power";
		int Text_Magic[] = "Magic";
		int Text_Hearts[] = "Hearts";
		int Text_BButton[] = "Exit";
		int Text_AButton[] = "Upgrade";
		while(true){
			while ( Link->Y > 104 || Link->X < 96 || Link->X > 144 || !LinkCanAttack() )
				Waitframe();
			
			while ( Link->HP < Link->MaxHP ) {
				Game->PlaySound(22);
				Link->HP += 2;
				if ( Link->HP >= Link->MaxHP )
					Link->HP = Link->MaxHP;
				WaitNoAction();
			}
			
			Screen->Message(118);
			WaitNoAction();
			
			while(true){
				// frame
				Screen->DrawTile(7, FrameX, FrameY, 19840, 13, 9, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
				
				// circle frames
				Screen->DrawTile(7, CircleFrameX, Row1Y - 12, 20110, 2, 2, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
				Screen->DrawTile(7, CircleFrameX, Row2Y - 12, 20110, 2, 2, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
				Screen->DrawTile(7, CircleFrameX, Row3Y - 12, 20110, 2, 2, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
				
				// items
				Screen->FastTile(7, CircleItemX, Row1Y - 4, 23668, 8, OP_OPAQUE);
				Screen->FastTile(7, CircleItemX, Row2Y - 4, 23668, 7, OP_OPAQUE);
				Screen->FastTile(7, CircleItemX, Row3Y - 4, 23668, 5, OP_OPAQUE);
				
				// item counters
				remchr(Buffer, 0);
				itoa(Buffer, Game->Counter[CR_SpiritGemPower]);
				Screen->DrawString(7, CircleItemX + 9, Row1Y + 14, FONT_Z1, 0x01, -1, TF_CENTERED, Buffer, OP_OPAQUE);
				
				remchr(Buffer, 0);
				itoa(Buffer, Game->Counter[CR_SpiritGemWisdom]);
				Screen->DrawString(7, CircleItemX + 9, Row2Y + 14, FONT_Z1, 0x01, -1, TF_CENTERED, Buffer, OP_OPAQUE);
				
				remchr(Buffer, 0);
				itoa(Buffer, Game->Counter[CR_SpiritGemCourage]);
				Screen->DrawString(7, CircleItemX + 9, Row3Y + 14, FONT_Z1, 0x01, -1, TF_CENTERED, Buffer, OP_OPAQUE);
				
				// left numbers
				remchr(Buffer, 0);
				itoa(Buffer, G[G_LinkPower]);
				Screen->DrawString(7, LeftValueX, Row1Y, FONT_Z1, 0x01, -1, TF_CENTERED, Buffer, OP_OPAQUE);
				
				remchr(Buffer, 0);
				itoa(Buffer, Link->MaxMP / 32);
				Screen->DrawString(7, LeftValueX, Row2Y, FONT_Z1, 0x01, -1, TF_CENTERED, Buffer, OP_OPAQUE);
				
				remchr(Buffer, 0);
				itoa(Buffer, Link->MaxHP / 16);
				Screen->DrawString(7, LeftValueX, Row3Y, FONT_Z1, 0x01, -1, TF_CENTERED, Buffer, OP_OPAQUE);
				
				// arrows
				Screen->FastTile(7, ArrowX, Row1Y - 4, 20064, 7, OP_OPAQUE);
				Screen->FastTile(7, ArrowX, Row2Y - 4, 20064, 7, OP_OPAQUE);
				Screen->FastTile(7, ArrowX, Row3Y - 4, 20064, 7, OP_OPAQUE);
				
				// right numbers
				remchr(Buffer, 0);
				itoa(Buffer, G[G_LinkPower] + 1);
				Screen->DrawString(7, RightValueX, Row1Y, FONT_Z1, 0x82, -1, TF_CENTERED, Buffer, OP_OPAQUE);
				
				remchr(Buffer, 0);
				itoa(Buffer, Link->MaxMP / 32 + 1);
				Screen->DrawString(7, RightValueX, Row2Y, FONT_Z1, 0x82, -1, TF_CENTERED, Buffer, OP_OPAQUE);
				
				remchr(Buffer, 0);
				itoa(Buffer, Link->MaxHP / 16 + 1);
				Screen->DrawString(7, RightValueX, Row3Y, FONT_Z1, 0x82, -1, TF_CENTERED, Buffer, OP_OPAQUE);
				
				// unit text
				Screen->DrawString(7, UnitTextX, Row1Y, FONT_Z1, 0x01, -1, TF_NORMAL, Text_Power, OP_OPAQUE);
				Screen->DrawString(7, UnitTextX, Row2Y, FONT_Z1, 0x01, -1, TF_NORMAL, Text_Magic, OP_OPAQUE);
				Screen->DrawString(7, UnitTextX, Row3Y, FONT_Z1, 0x01, -1, TF_NORMAL, Text_Hearts, OP_OPAQUE);
				
				// potential
				remchr(Buffer, 0);
				Buffer[0] = CHAR_LPAREN;
				itoa(Buffer, 1, G[G_PowerPotential]);
				Buffer[2] = CHAR_FSLASH;
				Buffer[3] = CHAR_6;
				Buffer[4] = CHAR_RPAREN;
				Screen->DrawString(7, PotentialX, Row1Y, FONT_Z1, 0x01, -1, TF_NORMAL, Buffer, OP_OPAQUE);
				
				remchr(Buffer, 0);
				Buffer[0] = CHAR_LPAREN;
				itoa(Buffer, 1, G[G_WisdomPotential]);
				Buffer[2] = CHAR_FSLASH;
				Buffer[3] = CHAR_6;
				Buffer[4] = CHAR_RPAREN;
				Screen->DrawString(7, PotentialX, Row2Y, FONT_Z1, 0x01, -1, TF_NORMAL, Buffer, OP_OPAQUE);
				
				remchr(Buffer, 0);
				Buffer[0] = CHAR_LPAREN;
				itoa(Buffer, 1, G[G_CouragePotential]);
				Buffer[2] = CHAR_FSLASH;
				Buffer[3] = CHAR_6;
				Buffer[4] = CHAR_RPAREN;
				Screen->DrawString(7, PotentialX, Row3Y, FONT_Z1, 0x01, -1, TF_NORMAL, Buffer, OP_OPAQUE);
				
				// final row
				Screen->FastTile(7, BButtonX, FinalRowY - 5, 20067, 8, OP_OPAQUE);
				Screen->DrawString(7, BTextX, FinalRowY, FONT_Z1, 0x01, -1, TF_NORMAL, Text_BButton, OP_OPAQUE);
				Screen->FastTile(7, AButtonX, FinalRowY - 5, 20066, 7, OP_OPAQUE);
				Screen->DrawString(7, ATextX, FinalRowY, FONT_Z1, 0x01, -1, TF_NORMAL, Text_AButton, OP_OPAQUE);
				
				if ( Link->PressB ) {
					G[G_ButtonLockHoldB] = 1;
					break;
				}
				
				WaitNoAction();
			}
			
			while ( Link->Y <= 112 )
				Waitframe();
		}
	}
}
*/

ffc script FairyFountain{
	void run(){
		int Circle1X = 76;
		int Circle2X = 112;
		int Circle3X = 148;
		int CircleY = 112;
		
		int Buffer[30];
		int C;
		while(true){ // main loop
			while ( Link->Y > 104 || Link->X < 96 || Link->X > 144 || !LinkCanAttack() )
				Waitframe();
			
			while ( Link->HP < Link->MaxHP ) {
				Game->PlaySound(22);
				Link->HP += 2;
				if ( Link->HP >= Link->MaxHP )
					Link->HP = Link->MaxHP;
				WaitNoAction();
			}
			
			// seperate message for when you can't upgrade
			if ( Game->Counter[CR_SpiritGemPower] < 3 && Game->Counter[CR_SpiritGemWisdom] < 3 && Game->Counter[CR_SpiritGemCourage] < 3 ) {
				Screen->Message(129);
				WaitNoAction();
			}
			else {
				Screen->Message(118);
				WaitNoAction();
				
				while(true){ // fairy interaction loop
					int Selection;
					int InitDelay = 30;
					while(true){ // menu loop
						// selection stuff
						if ( InitDelay == 0 ) {
							if ( Link->PressLeft ) {
								Game->PlaySound(5);
								Selection --;
							}
							else if ( Link->PressRight ) {
								Game->PlaySound(5);
								Selection ++;
							}
							if ( Selection < 0 )
								Selection = 2;
							else if ( Selection > 2 )
								Selection = 0;
							
							if ( Link->PressA || Link->PressStart ) {
								if ( (Selection == 0 && Game->Counter[CR_SpiritGemPower] >= 3)
								|| (Selection == 1 && Game->Counter[CR_SpiritGemWisdom] >= 3)
								|| (Selection == 2 && Game->Counter[CR_SpiritGemCourage] >= 3) ) {
									Game->PlaySound(68);
									break;
								}
							}
						}
						else
							InitDelay --;
						
						// draw stuff
						Screen->DrawTile(7, Circle1X, CircleY, 20110, 2, 2, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
						Screen->DrawTile(7, Circle2X, CircleY, 20110, 2, 2, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
						Screen->DrawTile(7, Circle3X, CircleY, 20110, 2, 2, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
						
						Screen->FastTile(7, Circle1X + 8, CircleY + 8, 23668, 8, OP_OPAQUE);
						Screen->FastTile(7, Circle2X + 8, CircleY + 8, 23668, 7, OP_OPAQUE);
						Screen->FastTile(7, Circle3X + 8, CircleY + 8, 23668, 5, OP_OPAQUE);
						
						if ( Game->Counter[CR_SpiritGemPower] >= 3 ) C = 0x82;
						else C = 0x01;
						remchr(Buffer, 0);
						itoa(Buffer, Game->Counter[CR_SpiritGemPower]);
						Screen->DrawString(7, Circle1X + 8 + 8, CircleY + 8 + 24, FONT_Z1, C, -1, TF_CENTERED, Buffer, OP_OPAQUE);
						
						if ( Game->Counter[CR_SpiritGemWisdom] >= 3 ) C = 0x82;
						else C = 0x01;
						remchr(Buffer, 0);
						itoa(Buffer, Game->Counter[CR_SpiritGemWisdom]);
						Screen->DrawString(7, Circle2X + 8 + 8, CircleY + 8 + 24, FONT_Z1, C, -1, TF_CENTERED, Buffer, OP_OPAQUE);
						
						if ( Game->Counter[CR_SpiritGemCourage] >= 3 ) C = 0x82;
						else C = 0x01;
						remchr(Buffer, 0);
						itoa(Buffer, Game->Counter[CR_SpiritGemCourage]);
						Screen->DrawString(7, Circle3X + 8 + 8, CircleY + 8 + 24, FONT_Z1, C, -1, TF_CENTERED, Buffer, OP_OPAQUE);
						
						if ( InitDelay == 0 ) {
							if ( Selection == 0 )
								Screen->DrawTile(7, Circle1X, CircleY, 20112, 2, 2, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
							if ( Selection == 1 )
								Screen->DrawTile(7, Circle2X, CircleY, 20112, 2, 2, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
							if ( Selection == 2 )
								Screen->DrawTile(7, Circle3X, CircleY, 20112, 2, 2, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
						}
						
						if ( Link->PressB ) {
							Selection = -1;
							G[G_ButtonLockHoldB] = 1;
							break;
						}
						WaitNoAction();
					}
					if ( Selection < 0 )
						break;
					
					// give upgrade
					if ( Selection == 0 ) {
						item itm = CreateItemAt(167, Link->X, Link->Y);
						SetItemPickup(itm, IP_HOLDUP, true);
					}
					if ( Selection == 1 ) {
						item itm = CreateItemAt(168, Link->X, Link->Y);
						SetItemPickup(itm, IP_HOLDUP, true);
					}
					if ( Selection == 2 ) {
						item itm = CreateItemAt(169, Link->X, Link->Y);
						SetItemPickup(itm, IP_HOLDUP, true);
					}
					WaitNoAction();
					
					// re-open the menu only if there's potential for another upgrade
					if ( Game->Counter[CR_SpiritGemPower] < 3 && Game->Counter[CR_SpiritGemWisdom] < 3 && Game->Counter[CR_SpiritGemCourage] < 3 )
						break;
				}
			}
			
			while ( Link->Y <= 112 )
				Waitframe();
		}
	}
}

ffc script FairyFountainSparkles{
	void run(){
		while(true){
			lweapon sparkle = CreateLWeaponAt(LW_SPARKLE, Rand(96, 144), Rand(56, 80));
			sparkle->UseSprite(116);
			sparkle->CSet = Choose(5, 7, 8);
			sparkle->Dir = DIR_UP;
			sparkle->Step = 30;
			Waitframes(Rand(6, 12));
		}
	}
}

item script FairyUpgrade{
	void run(int type){
		if ( type == 1 ) {
			Game->Counter[CR_SpiritGemPower] -= 3;
			G[G_LinkPower] ++;
			
			itemdata Sword1 = Game->LoadItemData(6);
			Sword1->Power ++;
			itemdata Sword2 = Game->LoadItemData(7);
			Sword2->Power ++;
			itemdata Sword3 = Game->LoadItemData(161);
			Sword3->Power ++;
			
			Screen->Message(120 + G[G_LinkPower] - 5);
		}
		if ( type == 2 ) {
			Game->Counter[CR_SpiritGemWisdom] -= 3;
			
			Link->MaxMP += 32;
			RestoreMP(32);
			G[G_MPBaseCDReduction] += 10;
			Screen->Message(126);
		}
		if ( type == 3 ) {
			Game->Counter[CR_SpiritGemCourage] -= 3;
			
			Link->MaxHP += 16;
			Link->HP += 16;
			Screen->Message(128);
		}
	}
}

ffc script FireballShooter{
	void run(){
		Waitframes(Rand(60, 150));
		while(true){
			FireEWeapon(EW_FIREBALL, this->X, this->Y, RadianAngle(this->X, this->Y, Link->X, Link->Y), 180, 4, -1, -1, 0);
			Waitframes(Rand(150, 240));
		}
	}
}

ffc script BouncyTornado{
	void run(){
		while(true){
			if ( Link->Z == 0 ) {
				// same collision check as moosh pit's script does for checking if link is on ffcs
				if ( RectCollision(Link->X+4, Link->Y+9, Link->X+11, Link->Y+14, this->X, this->Y, this->X+15, this->Y+15) ) {
					Game->PlaySound(45);
					if ( this->Data == 960 )
						Link->Jump = 3;
					if ( this->Data == 961 )
						Link->Jump = 4.5;
				}
			}
			Waitframe();
		}
	}
}

//-----------------------
// DATABASE SCRIPTS
//-----------------------

int MooshPit[16];
const int _MP_LASTX = 0;
const int _MP_LASTY = 1;
const int _MP_LASTDMAP = 2;
const int _MP_LASTSCREEN = 3;
const int _MP_ENTRYX = 4;
const int _MP_ENTRYY = 5;
const int _MP_ENTRYDMAP = 6;
const int _MP_ENTRYSCREEN = 7;
const int _MP_FALLX = 8;
const int _MP_FALLY = 9;
const int _MP_FALLTIMER = 10;
const int _MP_FALLSTATE = 11;
const int _MP_DAMAGETYPE = 12;
const int _MP_SLIDETIMER = 13;

const int MOOSHPIT_NO_GRID_SNAP = 1; //Set to 1 to prevent Link's falling sprite from snapping to the combo grid.
const int MOOSHPIT_ENABLE_SLIDEYPITS = 0; //Set to 1 if Link should slide into pits he's partially on
const int MOOSHPIT_NO_MOVE_WHILE_FALLING = 1; //Set to 1 if you don't want Link able to move while falling
const int MOOSHPIT_NO_REENTER_STAIRS = 1; //Set to 1 to prevent Link reentering stairs when respawning from a pit. This uses an FFC slot to run the script
const int MOOSHPIT_STUN_ENEMIES_WHILE_FALLING = 1; //Set to 1 to stun stunnable enemies while falling in a pit

const int CT_HOLELAVA = 128; //Combo type for pits (No Ground Enemies by default)
const int CF_LAVA = 98; //Combo flag marking pits as lava (Script 1 by default)

const int SPR_FALLHOLE = 93; //Sprite for Link falling in a hole
const int SPR_FALLLAVA = 94; //Sprite for Link falling in lava

const int SFX_FALLHOLE = 38; //Sound for falling in a hole
const int SFX_FALLLAVA = 0; //Sound for falling in lava

const int DAMAGE_FALLHOLE = 8; //How much damage pits deal (1/2 heart default)
const int DAMAGE_FALLLAVA = 8; //How much damage lava deals (1 heart default)

const int FFC_MOOSHPIT_AUTOWARPA = 32; //FFC that turns into an auto side warp combo when you fall in a pit
const int CMB_MOOSHPIT_AUTOWARPA = 2560; //Combo number of an invisible Auto Side Warp A combo
const int SF_MISC_MOOSHPITWARP = 2; //Number of the screen flag under the Misc. section that makes pits warp (Script 1 by default)
									//All pit warps use Side Warp A

const int MOOSHPIT_MIN_FALL_TIME = 60; //Minimum time for the pit's fall animation, to prevent repeated falling in pits
const int MOOSHPIT_EXTRA_FALL_TIME = 0; //Extra frames at the end of the falling animation before Link respawns

//Width and height of Link's hitbox for colliding with pits
const int MOOSHPIT_LINKHITBOXWIDTH = 2;
const int MOOSHPIT_LINKHITBOXHEIGHT = 2;

//Width and height of Link's hitbox for colliding with pits/lava in sideview
const int MOOSHPIT_SIDEVIEW_LINKHITBOXWIDTH = 2;
const int MOOSHPIT_SIDEVIEW_LINKHITBOXHEIGHT = 2;

const int MOOSHPIT_SLIDEYPIT_FREQ = 3; //Link will be pushed into slideypits every 1/n frames
const int MOOSHPIT_SLIDEYPIT_MAXTIME = 20; //Link will be pushed into slideypits more intensely after n frames
const int MOOSHPIT_SLIDEYPIT_ACCELFREQ = 8; //How often Link accelerates when falling in the pit
						
int MooshPit_OnPit(int LinkX, int LinkY, bool countFFCs){
	if(Link->Action==LA_FROZEN||Link->Action==LA_RAFTING||Link->Action==LA_INWIND)
		return -1;
	if ( G[G_NayrusWaterState] > 0 || G[G_NayrusTimeActive] > 0 )
		return -1;
	
	if(countFFCs){
		if(MooshPit_OnFFC(LinkX, LinkY))
			return -1;
	}
	
	bool sideview;
	if(Screen->Flags[SF_ROOMTYPE]&100b)
		sideview = true;
	//wew lad
	int width = MOOSHPIT_LINKHITBOXWIDTH;
	int height = MOOSHPIT_LINKHITBOXHEIGHT;
	
	int total;
	int solidTotal;
	
	for(int x=0; x<2; x++){
		for(int y=0; y<2; y++){
			int X; int Y;
			if(sideview){ //Hitbox functions differently in sideview
				width = MOOSHPIT_SIDEVIEW_LINKHITBOXWIDTH;
				height = MOOSHPIT_SIDEVIEW_LINKHITBOXHEIGHT;
				X = Floor(LinkX+7-width/2+(width-1)*x)+1;
				Y = Floor(LinkY+7-height/2+(height-1)*y)+1;
			}
			else{
				X = Floor(LinkX+7-width/2+(width-1)*x)+1;
				Y = Floor(LinkY+11-height/2+(height-1)*y)+1;
			}
			
			//If one corner of Link's hitbox is on a pit, flag that corner as covered
			if(Screen->ComboT[ComboAt(X, Y)]==CT_HOLELAVA){
				total |= 1<<(1+(x+y*2));
			}
			//If Link is on a solid combo, count that corner as a pit
			if(Screen->isSolid(X, Y)){
				solidTotal |= 1<<(x+y*2);
			}
		}
	}
	if(total>0) //Assuming Link is on at least one actual pit, add up the solid and nonsolid pits
		return (total>>1)|(solidTotal<<4);
	return -1;
}

bool MooshPit_OnFFC(int LinkX, int LinkY){
	for(int i=1; i<=32; ++i){ //Cycle through every FFC
		ffc f = Screen->LoadFFC(i);
		//Check if the FFC is solid
		if(f->Data>0&&!f->Flags[FFCF_CHANGER]&&!f->Flags[FFCF_ETHEREAL]){
			//Check if Link collides with the FFC
			if(RectCollision(LinkX+4, LinkY+9, LinkX+11, LinkY+14, f->X, f->Y, f->X+f->EffectWidth-1, f->Y+f->EffectHeight-1)){
				return true;
			}
		}
	}
	//If Link doesn't collide with any FFC, return false
	return false;
}

void MooshPit_StunEnemies(){
	for(int i=Screen->NumNPCs(); i>=1; --i){ //Cycle through every enemy
		npc n = Screen->LoadNPC(i);
		//Make it so the enemy's stun never falls below 1
		n->Stun = Max(n->Stun, 1);
	}
}

void MooshPit_Init(){
	MooshPit[_MP_LASTX] = Link->X;
	MooshPit[_MP_LASTY] = Link->Y;
	MooshPit[_MP_LASTDMAP] = Game->GetCurDMap();
	MooshPit[_MP_LASTSCREEN] = Game->GetCurDMapScreen();
	MooshPit[_MP_ENTRYX] = Link->X;
	MooshPit[_MP_ENTRYY] = Link->Y;
	MooshPit[_MP_ENTRYDMAP] = Game->GetCurDMap();
	MooshPit[_MP_ENTRYSCREEN] = Game->GetCurDMapScreen();
	MooshPit[_MP_FALLSTATE] = 0;
	MooshPit[_MP_FALLTIMER] = 0;
	Link->CollDetection = true;
	Link->Invisible = false;
}

void MooshPit_Update(){
	int i;
	bool isWarp;
	if(Screen->Flags[SF_MISC]&(1<<SF_MISC_MOOSHPITWARP))
		isWarp = true;
	
	bool sideview;
	if(Screen->Flags[SF_ROOMTYPE]&100b)
		sideview = true;
	
	if(Link->Action!=LA_SCROLLING){
		//Update the entry point whenever the screen changes
		if(MooshPit[_MP_ENTRYDMAP]!=Game->GetCurDMap()||MooshPit[_MP_ENTRYSCREEN]!=Game->GetCurDMapScreen()){
			MooshPit[_MP_ENTRYX] = Link->X;
			MooshPit[_MP_ENTRYY] = Link->Y;
			MooshPit[_MP_ENTRYDMAP] = Game->GetCurDMap();
			MooshPit[_MP_ENTRYSCREEN] = Game->GetCurDMapScreen();
		}
		
		if(MooshPit[_MP_FALLSTATE]==0){ //Not falling in pit
			int onPit = MooshPit_OnPit(Link->X, Link->Y, true);
			//Check if slidey pits are enabled and it's not sideview
			if(MOOSHPIT_ENABLE_SLIDEYPITS&&!IsSideview()){
				if(Link->Z<=0&&onPit>-1){ //If Link is partially on a pit
					int slideVx; int slideVy;
					int reps = 1;
					//Check if it's a frame Link should be moved
					if(MooshPit[_MP_SLIDETIMER]%MOOSHPIT_SLIDEYPIT_FREQ==0||MooshPit[_MP_SLIDETIMER]>=MOOSHPIT_SLIDEYPIT_MAXTIME){
						if((onPit&0111b)==0111b){ //Going up-left
							slideVx = -1;
							slideVy = -1;
						}
						else if((onPit&1011b)==1011b){ //Going up-right
							slideVx = 1;
							slideVy = -1;
						}
						else if((onPit&1101b)==1101b){ //Going down-left
							slideVx = -1;
							slideVy = 1;
						}
						else if((onPit&1110b)==1110b){ //Going down-right
							slideVx = 1;
							slideVy = 1;
						}
						else if((onPit&0011b)==0011b){ //Going up
							slideVy = -1;
						}
						else if((onPit&1100b)==1100b){ //Going down
							slideVy = 1;
						}
						else if((onPit&0101b)==0101b){ //Going left
							slideVx = -1;
						}
						else if((onPit&1010b)==1010b){ //Going right
							slideVx = 1;
						}
						else if((onPit&0001b)==0001b){ //Going up-left
							slideVx = -1;
							slideVy = -1;
						}
						else if((onPit&0010b)==0010b){ //Going up-right
							slideVx = 1;
							slideVy = -1;
						}
						else if((onPit&0100b)==0100b){ //Going down-left
							slideVx = -1;
							slideVy = 1;
						}
						else if((onPit&1000b)==1000b){ //Going down-right
							slideVx = 1;
							slideVy = 1;
						}
						
						//DEBUG DRAWS
						//VX
						// Screen->DrawInteger(6, 0, 0, FONT_Z1, 0x01, 0x0F, -1, -1, slideVx, 0, 128);
						//VY
						// Screen->DrawInteger(6, 0, 8, FONT_Z1, 0x01, 0x0F, -1, -1, slideVy, 0, 128);
						//ONPIT BITS
						// Screen->DrawInteger(6, 0, 16, FONT_Z1, 0x01, 0x0F, -1, -1, (onPit&1000b)>>3, 0, 128);
						// Screen->DrawInteger(6, 8, 16, FONT_Z1, 0x01, 0x0F, -1, -1, (onPit&0100b)>>2, 0, 128);
						// Screen->DrawInteger(6, 16, 16, FONT_Z1, 0x01, 0x0F, -1, -1, (onPit&0010b)>>1, 0, 128);
						// Screen->DrawInteger(6, 24, 16, FONT_Z1, 0x01, 0x0F, -1, -1, (onPit&0001b), 0, 128);
						
						//If Link is over the max slide time, increase the speed every 4 frames
						if(MooshPit[_MP_SLIDETIMER]>=MOOSHPIT_SLIDEYPIT_MAXTIME)
							reps += Floor((MooshPit[_MP_SLIDETIMER]-MOOSHPIT_SLIDEYPIT_MAXTIME)/MOOSHPIT_SLIDEYPIT_ACCELFREQ);
					}
					
					for(i=0; i<reps; ++i){
						if(slideVx<0&&CanWalk(Link->X, Link->Y, DIR_LEFT, 1, false)){
							Link->X--;
						}
						else if(slideVx>0&&CanWalk(Link->X, Link->Y, DIR_RIGHT, 1, false)){
							Link->X++;
						}
						if(slideVy<0&&CanWalk(Link->X, Link->Y, DIR_UP, 1, false)){
							Link->Y--;
						}
						else if(slideVy>0&&CanWalk(Link->X, Link->Y, DIR_DOWN, 1, false)){
							Link->Y++;
						}
					}
					MooshPit[_MP_SLIDETIMER]++;
				}
				else{
					MooshPit[_MP_SLIDETIMER] = 0;
				}
			}
			if(onPit>-1){
				//Combine solid combo bits with pit bits
				onPit |= (onPit>>4);
				//Remove non pit bits
				onPit &= 1111b;
			}
			if(Link->Z<=0&&onPit==15){ //If Link steps on a pit
				int underLink;
				if(!sideview){
					underLink = ComboAt(Link->X+8, Link->Y+12);
					if(Screen->ComboT[underLink]!=CT_HOLELAVA){
						for(i=0; i<4; ++i){
							underLink = ComboAt(Link->X+15*(i%2), Link->Y+8+7*Floor(i/2));
							if(Screen->ComboT[underLink]==CT_HOLELAVA)
								break;
						}
					}
				}
				else{
					underLink = ComboAt(Link->X+8, Link->Y+8);
					if(Screen->ComboT[underLink]!=CT_HOLELAVA){
						for(i=0; i<4; ++i){
							underLink = ComboAt(Link->X+15*(i%2), Link->Y+15*Floor(i/2));
							if(Screen->ComboT[underLink]==CT_HOLELAVA)
								break;
						}
					}
				}
			
				lweapon fall;
				
				//Check if the combo is lava
				if(ComboFI(underLink, CF_LAVA)){
					//Play sound and display animation
					Game->PlaySound(SFX_FALLLAVA);
					fall = CreateLWeaponAt(LW_SCRIPT10, Link->X, Link->Y);
					if(!MOOSHPIT_NO_GRID_SNAP){
						fall->X = ComboX(underLink);
						fall->Y = ComboY(underLink);
					}
					fall->UseSprite(SPR_FALLLAVA);
					fall->CollDetection = false;
					fall->DeadState = fall->ASpeed*fall->NumFrames;
				
					//Mark as lava damage
					MooshPit[_MP_DAMAGETYPE] = 1;
				}
				//Otherwise it's a pit
				else{
					//Play sound and display animation
					Game->PlaySound(SFX_FALLHOLE);
					fall = CreateLWeaponAt(LW_SCRIPT10, Link->X, Link->Y);
					if(!MOOSHPIT_NO_GRID_SNAP){
						fall->X = ComboX(underLink);
						fall->Y = ComboY(underLink);
						if(isWarp){
							Link->X = ComboX(underLink);
							Link->Y = ComboY(underLink);
						}
					}
					fall->UseSprite(SPR_FALLHOLE);
					fall->CollDetection = false;
					fall->DeadState = fall->ASpeed*fall->NumFrames;
				
					//Mark as hole damage
					MooshPit[_MP_DAMAGETYPE] = 0;
				}
				
				MooshPit[_MP_FALLX] = Link->X;
				MooshPit[_MP_FALLY] = Link->Y;
				
				//Cooldown should last as long as the fall animation
				MooshPit[_MP_FALLSTATE] = 1;
				MooshPit[_MP_FALLTIMER] = Max(MOOSHPIT_MIN_FALL_TIME, fall->DeadState+MOOSHPIT_EXTRA_FALL_TIME);
				
				//Render Link invisible and intangible
				Link->Invisible = true;
				Link->CollDetection = false;
				
				NoAction();
			}
			else if(MooshPit_OnPit(Link->X, Link->Y, false)==-1&&Link->Action!=LA_FROZEN){ //All other times, while Link is on solid ground, record Link's last position
				if ( G[G_NayrusWaterState] == 0 && G[G_NayrusTimeActive] == 0 ) {
					if(sideview){
						//Link has no Z value in sideview, so we check if he's on a platform instead
						if(OnSidePlatform(Link->X, Link->Y)){
							MooshPit[_MP_LASTDMAP] = Game->GetCurDMap();
							MooshPit[_MP_LASTSCREEN] = Game->GetCurDMapScreen();
							MooshPit[_MP_LASTX] = Link->X;
							MooshPit[_MP_LASTY] = Link->Y;
						}
					}
					else{
						if(Link->Z<=0){
							MooshPit[_MP_LASTDMAP] = Game->GetCurDMap();
							MooshPit[_MP_LASTSCREEN] = Game->GetCurDMapScreen();
							MooshPit[_MP_LASTX] = Link->X;
							MooshPit[_MP_LASTY] = Link->Y;
						}
					}
				}
			}
		}
		else if(MooshPit[_MP_FALLSTATE]==1){ //Falling animation
			if(MooshPit[_MP_FALLTIMER]>0)
				MooshPit[_MP_FALLTIMER]--;
		
			//if(MOOSHPIT_STUN_ENEMIES_WHILE_FALLING)
			//	MooshPit_StunEnemies();
			
			Link->Jump = 0;
			Link->Z = 0;
			
			//Keep Link invisible just in case
			Link->Invisible = true;
			Link->CollDetection = false;
			NoAction();
			if(MooshPit[_MP_FALLTIMER]==0){
				MooshPit[_MP_SLIDETIMER] = 0;
				if(!isWarp||MooshPit[_MP_DAMAGETYPE]==1){ //If the pit isn't a warp, deal damage and move Link back to the return point
					//If the entry would dump Link back in the pit, dump him out at the failsafe position
					if(MooshPit_OnPit(MooshPit[_MP_ENTRYX], MooshPit[_MP_ENTRYY], false)==15){
						if(MOOSHPIT_NO_REENTER_STAIRS){
							//Call a script to place an FFC under Link to prevent reentering stairs
							int scriptName[] = "MooshPit_StairsFix";
							int ffcNum = RunFFCScript(Game->GetFFCScript(scriptName), 0);
							if(ffcNum>0){
								ffc f = Screen->LoadFFC(ffcNum);
								f->Flags[FFCF_ETHEREAL] = false;
								f->X = MooshPit[_MP_LASTX];
								f->Y = MooshPit[_MP_LASTY];
							}
						}
						
						Link->X = MooshPit[_MP_LASTX];
						Link->Y = MooshPit[_MP_LASTY];
						
						//If the failsafe position was on a different screen, warp there
						if(Game->GetCurDMap()!=MooshPit[_MP_LASTDMAP]||Game->GetCurDMapScreen()!=MooshPit[_MP_LASTSCREEN]){
							Link->PitWarp(MooshPit[_MP_LASTDMAP], MooshPit[_MP_LASTSCREEN]);
						}
				
						Link->Invisible = false;
						Link->CollDetection = true;
					}
					else{
						if(MOOSHPIT_NO_REENTER_STAIRS){
							//Call a script to place an FFC under Link to prevent reentering stairs
							int scriptName[] = "MooshPit_StairsFix";
							int ffcNum = RunFFCScript(Game->GetFFCScript(scriptName), 0);
							if(ffcNum>0){
								ffc f = Screen->LoadFFC(ffcNum);
								f->Flags[FFCF_ETHEREAL] = false;
								f->X = MooshPit[_MP_ENTRYX];
								f->Y = MooshPit[_MP_ENTRYY];
							}
						}
						
						//Move Link to the entry and make him visible
						Link->X = MooshPit[_MP_ENTRYX];
						Link->Y = MooshPit[_MP_ENTRYY];
						
						Link->Invisible = false;
						Link->CollDetection = true;
					}
					
					//Subtract HP based on damage type
					if(MooshPit[_MP_DAMAGETYPE]==1)
						Link->HP -= DAMAGE_FALLLAVA;
					else
						Link->HP -= DAMAGE_FALLHOLE;
					//Play hurt sound and animation
					Link->Action = LA_GOTHURTLAND;
					Link->HitDir = -1;
					Game->PlaySound(SFX_OUCH);
					
					MooshPit[_MP_FALLSTATE] = 0;
				}
				else{
					MooshPit[_MP_FALLSTATE] = 2;
					MooshPit[_MP_FALLTIMER] = 1;
					ffc warp = Screen->LoadFFC(FFC_MOOSHPIT_AUTOWARPA);
					warp->Data = CMB_MOOSHPIT_AUTOWARPA;
					warp->Flags[FFCF_CARRYOVER] = false;
					Link->DrawZOffset = 1000;
				}
			}
		}
		else if(MooshPit[_MP_FALLSTATE]==2){ //Just warped
			if(sideview){
				Link->X = MooshPit[_MP_FALLX];
				Link->Y = 0;
			}
			else{
				Link->DrawZOffset = 0;
				//Link->X = MooshPit[_MP_FALLX];
				//Link->Y = MooshPit[_MP_FALLY];
				Link->Z = 176;
			}
			Link->Invisible = false;
			Link->CollDetection = true;
			
			if(MOOSHPIT_NO_MOVE_WHILE_FALLING){
				MooshPit[_MP_FALLSTATE] = 3;
				NoAction();
			}
			else
				MooshPit[_MP_FALLSTATE] = 0;
			MooshPit[_MP_FALLTIMER] = 0;
		}
		else if(MooshPit[_MP_FALLSTATE]==3){ //Falling into a new room (no action)
			if(MOOSHPIT_STUN_ENEMIES_WHILE_FALLING)
				MooshPit_StunEnemies();
			
			NoAction();
			if(IsSideview()){
				if(OnSidePlatform(Link->X, Link->Y))
					MooshPit[_MP_FALLSTATE] = 0;
			}
			else{
				if(Link->Z<=0)
					MooshPit[_MP_FALLSTATE] = 0;
			}
		}
	}
}

void MooshPit_ResetEntry(){
	MooshPit[_MP_ENTRYX] = Link->X;
	MooshPit[_MP_ENTRYY] = Link->Y;
	MooshPit[_MP_ENTRYDMAP] = Game->GetCurDMap();
	MooshPit[_MP_ENTRYSCREEN] = Game->GetCurDMapScreen();
}

ffc script MooshPit_StairsFix{
	void run(){
		this->Flags[FFCF_ETHEREAL] = false;
		while(LinkCollision(this)){
			Waitframe();
		}
		this->X = 0;
		this->Y = 0;
		this->Data = 0;
	}
}

const int SFX_SWITCH_PRESS = 65; //SFX when a switch is pressed
const int SFX_SWITCH_RELEASE = 66; //SFX when a switch is released
const int SFX_SWITCH_ERROR = 62; //SFX when the wrong switch is pressed

int Switch_Pressed(int x, int y, bool noLink){
	if ( G[G_Timestop] == 1 )
		return 0;
	int xOff = 0;
	int yOff = 4;
	int xDist = 8;
	int yDist = 8;
	if ( Link->Z == 0 && !noLink && G[G_NayrusWaterState] == 0 && G[G_NayrusTimeActive] == 0 ) {
		if(Abs(Link->X+xOff-x)<=xDist&&Abs(Link->Y+yOff-y)<=yDist)
			return 1;
	}
	if(Screen->MovingBlockX>-1 && !noLink){
		if(Abs(Screen->MovingBlockX-x)<=8&&Abs(Screen->MovingBlockY-y)<=8)
			return 1;
	}
	if ( G[G_HyliasSpiritState] == 2 && !noLink ) {
		if(Abs(G[G_HyliasArmosX]+xOff-x)<=xDist&&Abs(G[G_HyliasArmosY]+yOff-y)<=yDist)
			return 1;
	}
	if(Screen->isSolid(x+4, y+4)||
		Screen->isSolid(x+12, y+4)||
		Screen->isSolid(x+4, y+12)||
		Screen->isSolid(x+12, y+12)){
		return 2;
	}
	return 0;
}

ffc script Switch_Secret{
	void run(int perm, int id, int sfx){
		int d;
		int db;
		if(id>0){
			d = Floor((id-1)/16);
			db = 1<<((id-1)%16);
		}
		if(perm){
			if(id>0){
				if(Screen->D[d]&db){
					this->Data++;
					Screen->TriggerSecrets();
					Quit();
				}
			}
			else if(Screen->State[ST_SECRET]){
				this->Data++;
				Quit();
			}
		}
		Waitframe();
		while(!Switch_Pressed(this->X, this->Y, false)){
			Waitframe();
		}
		this->Data++;
		Screen->TriggerSecrets();
		Game->PlaySound(SFX_SWITCH_PRESS);
		if(sfx==0)
			Game->PlaySound(SFX_SECRET);
		else if(sfx>0)
			Game->PlaySound(sfx);
		if(perm){
			if(id>0)
				Screen->D[d]|=db;
			else
				Screen->State[ST_SECRET] = true;
		}
	}
}

ffc script Switch_Remote{
	void run(int pressure, int id, int flag, int sfx){
		bool noLink;
		if(pressure==2){
			pressure = 1;
			noLink = true;
		}
		
		int data = this->Data;
		int i; int j; int k;
		int d;
		int db;
		if(id>0){
			d = Floor((id-1)/16);
			db = 1<<((id-1)%16);
		}
		int comboD[176];
		for(i=0; i<176; ++i){
			if(Screen->ComboF[i]==flag){
				comboD[i] = Screen->ComboD[i];
				Screen->ComboF[i] = 0;
			}
		}
		if(id>0){
			if(Screen->D[d]&db){
				this->Data = data+1;
				for(i=0; i<176; ++i){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i]+1;
					}
				}
				Quit();
			}
		}
		Waitframe();
		if(pressure){
			while(true){
				while(!Switch_Pressed(this->X, this->Y, noLink)){
					Waitframe();
				}
				this->Data = data+1;
				Game->PlaySound(SFX_SWITCH_PRESS);
				for(i=0; i<176; ++i){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i]+1;
					}
				}
				while(Switch_Pressed(this->X, this->Y, noLink)){
					Waitframe();
				}
				this->Data = data;
				Game->PlaySound(SFX_SWITCH_RELEASE);
				for(i=0; i<176; ++i){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i];
					}
				}
			}
		}
		else{
			while(!Switch_Pressed(this->X, this->Y, noLink)){
				Waitframe();
			}
			this->Data = data+1;
			Game->PlaySound(SFX_SWITCH_PRESS);
			if(sfx>0)
				Game->PlaySound(sfx);
			else if ( sfx == 0 )
				Game->PlaySound(SFX_SECRET);
			for(i=0; i<176; ++i){
				if(comboD[i]>0){
					Screen->ComboD[i] = comboD[i]+1;
				}
			}
			if(id>0){
				Screen->D[d] |= db;
			}
		}
	}
}

ffc script Switch_HitAll{
	void run(int switchCmb, int pressure, int perm, int id, int flag, int sfx, int switchID){
		int switchCS;
		bool noLink;
		if(pressure==2){
			pressure = 1;
			noLink = true;
		}
	   
		int i; int j; int k;
		int d;
		int db;
		if(flag==0)
			id = 0;
		int comboD[176];
		if(id>0){
			d = Floor((id-1)/16);
			db = 1<<((id-1)%16);
			for(i=0; i<176; ++i){
				if(Screen->ComboF[i]==flag){
					comboD[i] = Screen->ComboD[i];
					Screen->ComboF[i] = 0;
				}
			}
		}
		int switches[34];
		int switchD[34];
		int switchDB[34];
		switchD[0] = switchID;
		bool switchesPressed[34];
		k = SizeOfArray(switches)-2;
		for(i=0; i<176&&switches[0]<k; ++i){
			if(Screen->ComboD[i]==switchCmb){
				switchCS = Screen->ComboC[i];
				j = 2+switches[0];
				switches[j] = i;
				if(!pressure&&switchID>0){
					switchD[j] = Floor((switchID+switches[0]-1)/16);
					switchDB[j] = 1<<((switchID+switches[0]-1)%16);
					if(Screen->D[switchD[j]]&switchDB[j]){
						switchesPressed[j] = true;
						Screen->ComboD[i] = switchCmb+1;
						switches[1]++;
					}
				}
				switches[0]++;
			}
		}
		Waitframe();
		if(perm){
			if(id>0){
				if(Screen->D[d]&db){
					for(i=2; i<switches[0]+2; ++i){
						Screen->ComboD[switches[i]] = switchCmb+1;
						switchesPressed[i] = true;
					}
					for(i=0; i<176; ++i){
						if(comboD[i]>0){
							Screen->ComboD[i] = comboD[i]+1;
						}
					}
					while(true){
						Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, switchCS, false, noLink);
						Waitframe();
					}
				}
			}
			if(Screen->State[ST_SECRET]){
				for(i=2; i<switches[0]+2; ++i){
					Screen->ComboD[switches[i]] = switchCmb+1;
					switchesPressed[i] = true;
				}
				while(true){
					Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, switchCS, false, noLink);
					Waitframe();
				}
			}
		}
		if(pressure){
			while(switches[1]<switches[0]){
				Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, switchCS, true, noLink);
				Waitframe();
			}
			if(id>0){
				if(sfx>0)
					Game->PlaySound(sfx);
				else
					Game->PlaySound(SFX_SECRET);
				for(i=0; i<176; ++i){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i]+1;
					}
				}
			}
			else{
				if(sfx>0)
					Game->PlaySound(sfx);
				else
					Game->PlaySound(SFX_SECRET);
				Screen->TriggerSecrets();
			}
			if(perm){
				if(id>0)
					Screen->D[d] |= db;
				else
					Screen->State[ST_SECRET] = true;
			}
		}
		else{
			while(switches[1]<switches[0]){
				Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, switchCS, false, noLink);
				Waitframe();
			}
			if(id>0){
				if(sfx>0)
					Game->PlaySound(sfx);
				else
					Game->PlaySound(SFX_SECRET);
				for(i=0; i<176; ++i){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i]+1;
					}
				}
			}
			else{
				if(sfx>0)
					Game->PlaySound(sfx);
				else
					Game->PlaySound(SFX_SECRET);
				Screen->TriggerSecrets();
			}
			if(perm){
				if(id>0)
					Screen->D[d] |= db;
				else
					Screen->State[ST_SECRET] = true;
			}
		}
		while(true){
			Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, switchCS, false, noLink);
			Waitframe();
		}
	}
	void Switches_Update(int switches, int switchD, int switchDB, bool switchesPressed, int switchCmb, int switchCS, bool pressure, bool noLink){
		if(pressure)
			switches[1] = 0;
		for(int i=0; i<switches[0]; ++i){
			int j = i+2;
			int k = switches[j];
			int p = Switch_Pressed(ComboX(k), ComboY(k), noLink);
			if(p){
				if(p!=2){
					Screen->ComboD[k] = switchCmb+1;
					Screen->ComboC[k] = switchCS;
				}
				if(!switchesPressed[j]){
					if ( !noLink )
						Game->PlaySound(SFX_SWITCH_PRESS);
					if(switchD[0]>0){
						Screen->D[switchD[j]] |= switchDB[j];
					}
					switchesPressed[j] = true;
					if(!pressure)
						switches[1]++;
				}
				if(pressure)
					switches[1]++;
			}
			else{
				if(switchesPressed[j]){
					if(pressure){
						if ( !noLink )
							Game->PlaySound(SFX_SWITCH_RELEASE);
						Screen->ComboD[k] = switchCmb;
						Screen->ComboC[k] = switchCS;
						switchesPressed[j] = false;
					}
					else{
						if(Screen->ComboD[k]!=switchCmb+1){
							Screen->ComboD[k] = switchCmb+1;
							Screen->ComboC[k] = switchCS;
						}
					}
				}
			}
		}
	}
}

ffc script Switch_Sequential{
	void run(int flag, int perm, int sfx){
		int i; int j; int k;
		int switches[34];
		int switchCmb[34];
		int switchMisc[8];
		bool switchesPressed[34];
		k = SizeOfArray(switches)-2;
		for(i=0; i<176&&switches[0]<k; ++i){
			if(Screen->ComboF[i]==flag){
				j = 2+switches[0];
				switches[j] = i;
				switchCmb[j] = Screen->ComboD[i];
				switches[0]++;
			}
		}
		int switchOrder[34];
		Switches_Organize(switches, switchOrder);
		if(perm&&Screen->State[ST_SECRET]){
			for(i=0; i<switches[0]; ++i){
				switchesPressed[i+2] = true;
			}
			while(true){
				Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, false);
				Waitframe();
			}
		}
		while(switches[1]<switches[0]){
			Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, true);
			if(switchMisc[0]==1){
				switchMisc[0] = 0;
				for(i=0; i<30; ++i){
					Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, false);
					Waitframe();
				}
				while(Switches_LinkOn(switches)){
					Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, false);
					Waitframe();
				}
			}
			Waitframe();
		}
		if(sfx>0)
			Game->PlaySound(sfx);
		else
			Game->PlaySound(SFX_SECRET);
		Screen->TriggerSecrets();
		if(perm)
			Screen->State[ST_SECRET] = true;
		for(i=0; i<switches[0]; ++i){
			switchesPressed[i+2] = true;
		}
		while(true){
			Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, false);
			Waitframe();
		}
		
	}
	void Switches_Organize(int switches, int switchOrder){
		bool banned[34];
		for(int j=0; j<switches[0]; ++j){
			int lowest = -1;
			int lowestIndex = -1;
			for(int i=0; i<switches[0]; ++i){
				int c = Screen->ComboD[switches[i+2]];
				if(c!=-1&&!banned[i+2]){
					if(lowest==-1||c<lowest){
						lowest = c;
						lowestIndex = i+2;
					}
				}
			}
			switchOrder[j] = lowestIndex;
			banned[lowestIndex] = true;
		}
	}
	bool Switches_LinkOn(int switches){
		for(int i=0; i<switches[0]; ++i){
			int j = i+2;
			int k = switches[j];
			int p = Switch_Pressed(ComboX(k), ComboY(k), false);
			if(p==1)
				return true;
		}
		return false;
	}
	void Switches_Update(int switches, bool switchesPressed, int switchOrder, int switchCmb, int switchMisc, bool canPress){
		bool reset;
		for(int i=0; i<switches[0]; ++i){
			int j = i+2;
			int k = switches[j];
			int p = Switch_Pressed(ComboX(k), ComboY(k), false);
			if(!switchesPressed[j]){
				if(p!=2)
					Screen->ComboD[k] = switchCmb[j];
				if(p&&canPress){
					if(j==switchOrder[switches[1]]){
						switches[1]++;
						Game->PlaySound(SFX_SWITCH_PRESS);
						switchesPressed[j] = true;
					}
					else{
						switches[1] = 0;
						Game->PlaySound(SFX_SWITCH_ERROR);
						reset = true;
					}
				}
			}
			else{
				if(p!=2)
					Screen->ComboD[k] = switchCmb[j]+1;
				if(p==0&&canPress){
					Game->PlaySound(SFX_SWITCH_RELEASE);
					switchesPressed[j] = false;
				}
			}
		}
		if(reset){
			switchMisc[0] = 1;
			for(int i=0; i<switches[0]; ++i){
				int j = i+2;
				int k = switches[j];
				int p = Switch_Pressed(ComboX(k), ComboY(k), false);
				switchesPressed[j] = false;
			}
		}
	}
}

//Three colors used for the lasers
const int C_EZB_LASER1 = 0x73;
const int C_EZB_LASER2 = 0x72;
const int C_EZB_LASER3 = 0x71;

//Three colors used for shockwaves
const int C_EZB_SHOCKWAVE1 = 0x83;
const int C_EZB_SHOCKWAVE2 = 0x82;
const int C_EZB_SHOCKWAVE3 = 0x81;

const int SFX_EZB_TELEPORT = 0; //Sound when a boss teleports
const int SFX_EZB_LASER = 37; //Sound when a laser is fired
const int SFX_EZB_SUMMON = 56; //Sound for summoning enemies
const int SFX_EZB_DASH = 1; //Sound when dashing
const int SFX_EZB_BACKSTEP = 1; //Sound when backstepping
const int SFX_EZB_SHOCKWAVE = 2; //Sound of the boss's shockwaves
const int SFX_EZB_SHAKE = 3; //Sound of the ground shaking after a big jump
const int SFX_EZB_BARRIERSHIFT = 56; //Sound of the enemy changing forms

const int EZB_SUMMON_CAP = 3; //Max number of enemies summoned by each instance of the script
const int EZB_TOTAL_SUMMON_CAP = 20; //Max number of enemies onscreen at a time

const int EZB_DONT_REPEAT_LAST_ATTACK = 1; //If 1, the enemy will try not to repeat attacks
const int EZB_DO_WINDUP_SHAKE = 0; //0 - no shake, 1 - shake on strong attack, 2 - shake on medium attack
const int EZB_TELEPORT_TYPE = 1; //0 - Flicker, 1 - Sprite stretch, 2 - Combo offset
const int EZB_ENABLE_SPEEDTRAILS = 0; //If 1, faster movement attacks will have speed trails behind the enemy
const int EZB_ALWAYS_FAKE_Z = 1; //If 1, the Fake Z axis flag will always be set

const int EZB_WINDUP_ATTACK = 16; //Delay before a weak attack
const int EZB_WINDUP_ATTACK_MED = 32; //Delay before a medium attack
const int EZB_WINDUP_ATTACK_STRONG = 64; //Delay before a stronger attack (the boss shakes)

const int EZB_FLYING_ZPOS = 8; //Z position for flying bosses

const int LAYER_EZB_LASER = 4; //Layer lasers are drawn to

const int SPR_EZB_DEATHEXPLOSION = 0; //Sprite to use for death explosions (0 for ZC default)
const int WIDTH_EZB_DEATHEXPLOSION = 2; //Tile width for death explosions
const int HEIGHT_EZB_DEATHEXPLOSION = 2; //Tile height for death explosions
const int EZB_DEATH_FLASH = 1; //Set to 1 to make the enemy flash during death animations
const int LW_EZB_DEATHEXPLOSION = 40; //LWeapon type used for death explosions. Script 10 by default

const int EZBF_4WAY		 = 00000000001b; //1
const int EZBF_8WAY		 = 00000000010b; //2
const int EZBF_FLYING	   = 00000000100b; //4
const int EZBF_AQUATIC	  = 00000001000b; //8
const int EZBF_NOFALL	   = 00000010000b; //16
const int EZBF_EXPLODEEATH  = 00000100000b; //32
const int EZBF_FACELINK	 = 00001000000b; //64
const int EZBF_UNBLOCKABLE  = 00010000000b; //128
const int EZBF_KNOCKBACK	= 00100000000b; //256
const int EZBF_NOCOLL	   = 01000000000b; //512
const int EZBF_NOSTUN	   = 10000000000b; //1024

ffc script EZBoss{
	void run(int enemyid){
		int i; int j; int k; int m; int angle; int dist; int x; int y;
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		
		if ( G[G_Timestop] == 1 ) {
			if ( ghost->ID >= 182 && ghost->ID <= 184 ) { //wizzrobes
				Ghost_Data = 3;
				Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
				ghost->CollDetection = false;
				while(true)
					Ghost_Waitframe(this, ghost, true, true);
			}
			if ( ghost->ID == 185 ) {
				Ghost_SpawnAnimationPuff(this, ghost);
				Ghost_Data = 2900;
				Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
				ghost->CollDetection = false;
				while(true)
					Ghost_Waitframe(this, ghost, true, true);
			}
			if ( ghost->ID == 177 ) {
				Ghost_SpawnAnimationPuff(this, ghost);
				Ghost_Data = 2908;
				Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
				ghost->CollDetection = false;
				while(true)
					Ghost_Waitframe(this, ghost, true, true);
			}
			if ( ghost->ID == 178 ) {
				Ghost_SpawnAnimationPuff(this, ghost);
				Ghost_Data = 2912;
				Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
				ghost->CollDetection = false;
				while(true)
					Ghost_Waitframe(this, ghost, true, true);
			}
		}
		
		Ghost_SpawnAnimationPuff(this, ghost);
		npc summons[256];
		npc enem;
		eweapon e;
		
		int barrierShift[312];
		
		for(i=0; i<12; ++i){
			barrierShift[300+i] = ghost->Attributes[i];
		}
		int movementStyle = barrierShift[300];
		int attack1 = barrierShift[301];
		int attack2 = barrierShift[302];
		int attack3 = barrierShift[303];
		int shaveHitbox = barrierShift[304];
		int special = barrierShift[305];
		int size = barrierShift[306];
		int fireSFX = barrierShift[307];
		int fireSPR = barrierShift[308];
		int flags = barrierShift[309];
		
		int constantAttack;
		int doConstantAttack;
		
		int SummonSFX = SFX_EZB_SUMMON;
		if ( ghost->ID == 178 || ghost->ID == 162 || ghost->ID == 52 ) // zol or vire
			SummonSFX = 0;
		
		//Certain attacks in Attack 1 do a constant attack instead
		//This is triggered at certain parts of the enemy's walk pattern
		if(attack1==44)
			constantAttack = 44;
		else if(attack1==45)
			constantAttack = 45;
		else if(attack1==46)
			constantAttack = 46;
		else if(attack1==47)
			constantAttack = 47;
		else if(attack1==48)
			constantAttack = 48;
		
		if(attack1==50||attack1==51){
			EZB_Barriershift_Store(ghost, special, barrierShift);
			if(attack1==51)
				barrierShift[200] = 2;
		}
		
		//If there's a constant attack, shift all other attacks down
		if(constantAttack>0||barrierShift[200]){
			attack1 = attack2;
			attack2 = attack3;
			attack3 = 0;
		}
		
		int shaveX = shaveHitbox&1111b;
		int shaveY = Floor(shaveHitbox>>4)&1111b;
		
		//An enemy with no collision uses stun to turn it off and so cannot be stunned normally
		if(!(flags&EZBF_NOCOLL)&&!(flags&EZBF_NOSTUN)){
			Ghost_SetFlag(GHF_STUN);
			Ghost_SetFlag(GHF_CLOCK);
		}
		
		int w = size&1111b;
		int h = (size>>4)&1111b;
		if(h==0)
			h = w;
		w = Clamp(w, 1, 4);
		h = Clamp(h, 1, 4);
		
		barrierShift[310] = ghost->Attributes[10];
		int combo = barrierShift[310];
		Ghost_Transform(this, ghost, -1, -1, w, h);
		Ghost_SetHitOffsets(ghost, shaveY, shaveY, shaveX, shaveX);
		
		if(flags&EZBF_8WAY)
			Ghost_SetFlag(GHF_8WAY);
		else if(flags&EZBF_4WAY)
			Ghost_SetFlag(GHF_4WAY);
		if(flags&EZBF_NOFALL)
			Ghost_SetFlag(GHF_NO_FALL);
		if(flags&EZBF_FLYING){
			Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
			Ghost_SetFlag(GHF_FLYING_ENEMY);
			this->Flags[FFCF_OVERLAY] = true;
			if(EZB_FLYING_ZPOS&&(flags&EZBF_NOFALL)&&!IsSideview()){
				Ghost_SetFlag(GHF_FAKE_Z);
				Ghost_Z = 8;
			}
		}
		else if(flags&EZBF_AQUATIC){
			Ghost_SetFlag(GHF_WATER_ONLY);
		}
		if(flags&EZBF_KNOCKBACK){
			Ghost_SetFlag(GHF_KNOCKBACK);
		}
		if(EZB_ALWAYS_FAKE_Z && ghost->ID != 30) // not a lynel
			Ghost_SetFlag(GHF_FAKE_Z);
		
		if ( w == 1 && h == 1 ) // non boss enemies can be stunned
			Ghost_SetFlag(GHF_STUN);
		
		int stepCounter = -1;
		int attackCooldown = ghost->Haltrate*15 - Rand(ghost->Haltrate*4);
		int stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
		int stepCooldown = ghost->Rate;
		int vX; int vY;
		int lastAttack = -1;
		
		if(movementStyle==4){
			angle = Rand(360);
			vX = VectorX(ghost->Step/100, angle);
			vY = VectorY(ghost->Step/100, angle);
		}
		if(movementStyle==11){
			stepAngle = Rand(4);
		}
		if(movementStyle==8){
			stepAngle *= 0.5;
		}
		
		while(true){
			bool attackCond = false;
			//Handle Movement
			if(movementStyle==0){ //4 Way Halting Walk
				stepCounter = Ghost_HaltingWalk4(stepCounter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger, ghost->Haltrate, 48);
				if(stepCounter==16)
					attackCond = true;
			}
			else if(movementStyle==1){ //4 Way Constant Walk
				stepCounter = Ghost_ConstantWalk4(stepCounter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==2){ //8 Way Constant Walk
				stepCounter = Ghost_ConstantWalk8(stepCounter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==3){ //Homing in on Link
				if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>8){
					EZB_FaceLink(this, ghost, barrierShift);
					Ghost_MoveAtAngle(Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), ghost->Step/100, 0);
				}
				if(ghost->Homing>0&&Link->Action==LA_ATTACKING&&Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())<ghost->Homing){
					if(attackCooldown<ghost->Haltrate*5)
						attackCond = true;
				}
				
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==4){ //Wall Bounce
				Ghost_MoveXY(vX, vY, 0);
				if((vX<0&&!Ghost_CanMove(DIR_LEFT, 1, 0)) || (vX>0&&!Ghost_CanMove(DIR_RIGHT, 1, 0))){
					vX = -vX;
					doConstantAttack = 1;
				}
				if((vY<0&&!Ghost_CanMove(DIR_UP, 1, 0)) || (vY>0&&!Ghost_CanMove(DIR_DOWN, 1, 0))){
					vY = -vY;
					if(doConstantAttack==0)
						doConstantAttack = 1;
				}
					
				Ghost_Dir = EZB_AngleDir(this, ghost, barrierShift, Angle(0, 0, vX*10, vY*10));
				if(flags&EZBF_FACELINK)
					EZB_FaceLink(this, ghost, barrierShift);
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==5){ //Periodic Reaim
				Ghost_MoveAtAngle(stepAngle, ghost->Step/100, 0);
				Ghost_Dir = EZB_AngleDir(this, ghost, barrierShift, stepAngle);
				if(flags&EZBF_FACELINK)
					EZB_FaceLink(this, ghost, barrierShift);
					
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
					
				stepCounter++;
				if(stepCounter>80&&Rand(10)==0){
					stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					stepCounter = 0;
					if(doConstantAttack==0)
						doConstantAttack = 1;
				}
			}
			else if(movementStyle==6){ //Lazy chase
				float homing = ghost->Homing*0.001;
				float topSpeed = ghost->Step*0.01;
				vX = Clamp(vX+Sign(CenterLinkX()-CenterX(ghost))*homing, -topSpeed, topSpeed);
				vY = Clamp(vY+Sign(CenterLinkY()-CenterY(ghost))*homing, -topSpeed, topSpeed);
				Ghost_MoveXY(vX, vY, 0);
				if((vX<0&&!Ghost_CanMove(DIR_LEFT, 1, 0)) || (vX>0&&!Ghost_CanMove(DIR_RIGHT, 1, 0))){
					vX = -vX;
					if(doConstantAttack==0)
						doConstantAttack = 1;
				}
				if((vY<0&&!Ghost_CanMove(DIR_UP, 1, 0)) || (vY>0&&!Ghost_CanMove(DIR_DOWN, 1, 0))){
					vY = -vY;
					if(doConstantAttack==0)
						doConstantAttack = 1;
				}
					
				Ghost_Dir = EZB_AngleDir(this, ghost, barrierShift, Angle(0, 0, vX*10, vY*10));
				if(flags&EZBF_FACELINK)
					EZB_FaceLink(this, ghost, barrierShift);
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==7){ //Hopping
				EZB_Waitframes(this, ghost, barrierShift, ghost->Haltrate*8+Choose(0, 8, 16));
				if(ghost->Homing==0)
					stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+Rand(-30, 30);
				else
					stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+Rand(-ghost->Homing, ghost->Homing);
				stepAngle = WrapDegrees(stepAngle);
				//Game->PlaySound(SFX_JUMP);
				Ghost_Jump = 2.2;
				if ( ghost->ID == 177 || ghost->ID == 178 || ghost->ID == 161 || ghost->ID == 162 ) { // gel or zol
					Ghost_Jump = 1.8;
					if ( ghost->ID == 161 )
						FireEWeapon(EW_FIRE, Ghost_X, Ghost_Y, 0, 0, ghost->WeaponDamage, 115, 0, 0);
				}
				while(Ghost_Jump>0||Ghost_Z>0){
					Ghost_Dir = EZB_AngleDir(this, ghost, barrierShift, stepAngle);
					Ghost_MoveAtAngle(stepAngle, ghost->Step/100, 0);
					if(flags&EZBF_FACELINK)
						EZB_FaceLink(this, ghost, barrierShift);
					EZB_Waitframe(this, ghost, barrierShift);
				}
				if(stepCooldown>0)
					stepCooldown--;
				if(stepCooldown<=0||Rand(Max(Ceiling(ghost->Rate*0.5), 2))==0){
					attackCond = true;
					stepCooldown = ghost->Rate;
				}
				if(!attackCond)
					doConstantAttack = 1;
			}
			else if(movementStyle==8){ //Teleport
				EZB_Waitframes(this, ghost, barrierShift, ghost->Haltrate*15-Rand(ghost->Haltrate*4)+Choose(0, 8, 16));
				EZB_Teleport(this, ghost, barrierShift);
				if(stepCooldown>0)
					stepCooldown--;
				if(stepCooldown<=0||Rand(Max(Ceiling(ghost->Rate*0.5), 2))==0){
					attackCond = true;
					stepCooldown = ghost->Rate;
				}
				if(!attackCond)
					doConstantAttack = 1;
			}
			else if(movementStyle==9){ //Rapid hop
				stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+Rand(-ghost->Haltrate, ghost->Haltrate);
				Game->PlaySound(SFX_JUMP);
				if(ghost->Homing==0)
					Ghost_Jump = 2.6;
				else
					Ghost_Jump = 0.01*ghost->Homing;
				if(ghost->Rate>0){
					k = Ghost_Jump * Clamp(0.01*ghost->Rate, 0, 80);
					Ghost_Jump += Rand(-100, 100)*0.01*k;
				}
				while(Ghost_Jump>0||Ghost_Z>0){
					Ghost_Dir = EZB_AngleDir(this, ghost, barrierShift, stepAngle);
					Ghost_MoveAtAngle(stepAngle, ghost->Step/100, 0);
					if(flags&EZBF_FACELINK)
						EZB_FaceLink(this, ghost, barrierShift);
					
					if(attackCooldown>0)
						attackCooldown--;
					else if(Rand(24)==0)
						attackCond = true;
					
					EZB_Waitframe(this, ghost, barrierShift);
					
					if(attackCond){
						while(Ghost_Z>0){
							Ghost_Dir = EZB_AngleDir(this, ghost, barrierShift, stepAngle);
							Ghost_MoveAtAngle(stepAngle, ghost->Step/100, 0);
							if(flags&EZBF_FACELINK)
								EZB_FaceLink(this, ghost, barrierShift);
							EZB_Waitframe(this, ghost, barrierShift);
						}
					}
				}
				if(!attackCond)
					doConstantAttack = 1;
			}
			else if(movementStyle==10){ //Run away
				if(ghost->Homing==0||Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())<ghost->Homing){
					angle = Angle(CenterLinkX(), CenterLinkY(), CenterX(ghost), CenterY(ghost));
					x = Ghost_X+VectorX(6, angle);
					y = Ghost_Y+VectorY(6, angle);
					if(stepCounter>0&&stepAngle!=-1000){
						stepCounter--;
						EZB_FaceAngle(this, ghost, barrierShift, stepAngle);
						Ghost_MoveAtAngle(stepAngle, ghost->Step/100, 0);
					}
					else if(EZB_CanPlace(this, ghost, x, y)){
						if(stepCounter>0)
							stepCounter--;
						stepAngle = -1000;
						EZB_FaceAngle(this, ghost, barrierShift, angle);
						Ghost_MoveAtAngle(angle, ghost->Step/100, 0);
					}
					else{
						stepAngle = WrapDegrees(angle + Choose(-140, 140));
						stepCounter = Floor(32/(ghost->Step*0.01));
						if(doConstantAttack==0)
							doConstantAttack = 1;
					}
				}
				else if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>ghost->Homing+32){
					EZB_FaceLink(this, ghost, barrierShift);
					Ghost_MoveAtAngle(Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), ghost->Step/100, 0);
				}
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==11){ //Turn at wall
				if(ghost->Homing>0)
					stepAngle = Ghost_Dir;
				if(!Ghost_CanMove(stepAngle, 1, 0)){
					if(ghost->Rate==0){
						if(stepAngle==DIR_UP)
							stepAngle = DIR_RIGHT;
						else if(stepAngle==DIR_DOWN)
							stepAngle = DIR_LEFT;
						else if(stepAngle==DIR_LEFT)
							stepAngle = DIR_UP;
						else if(stepAngle==DIR_RIGHT)
							stepAngle = DIR_DOWN;
					}
					else if(ghost->Rate==1){
						if(stepAngle==DIR_UP)
							stepAngle = DIR_LEFT;
						else if(stepAngle==DIR_DOWN)
							stepAngle = DIR_RIGHT;
						else if(stepAngle==DIR_LEFT)
							stepAngle = DIR_DOWN;
						else if(stepAngle==DIR_RIGHT)
							stepAngle = DIR_UP;
					}
					else if(ghost->Rate==2){
						if(stepAngle==DIR_UP)
							stepAngle = DIR_DOWN;
						else if(stepAngle==DIR_DOWN)
							stepAngle = DIR_UP;
						else if(stepAngle==DIR_LEFT)
							stepAngle = DIR_RIGHT;
						else if(stepAngle==DIR_RIGHT)
							stepAngle = DIR_LEFT;
					}
					else{
						if(stepAngle==DIR_UP)
							stepAngle = Choose(DIR_LEFT, DIR_RIGHT);
						else if(stepAngle==DIR_DOWN)
							stepAngle = Choose(DIR_LEFT, DIR_RIGHT);
						else if(stepAngle==DIR_LEFT)
							stepAngle = Choose(DIR_UP, DIR_DOWN);
						else if(stepAngle==DIR_RIGHT)
							stepAngle = Choose(DIR_UP, DIR_DOWN);
					}
					if(doConstantAttack==0)
						doConstantAttack = 1;
				}
				Ghost_Dir = stepAngle;
				Ghost_Move(Ghost_Dir, ghost->Step/100, 0);
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			
			if(doConstantAttack==1){
				if(constantAttack==44){ //Fireball (Directional)
					EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir), 150);
				}
				else if(constantAttack==45){ //Fireball (Angular)
					EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 150);
				}
				else if(constantAttack==46){ //Summon
					if ( Screen->NumNPCs() < EZB_TOTAL_SUMMON_CAP && EZB_NumSummons(summons) < EZB_SUMMON_CAP ) {
						Game->PlaySound(SummonSFX);
						enem = CreateNPCAt(special, CenterX(ghost)-8, CenterY(ghost)-8);
						EZB_AddSummon(enem, summons);
					}
				}
				else if(constantAttack==47){ //4 Way (HV)
					for(i=0; i<4; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, 90*i, 150);
					}
				}
				else if(constantAttack==48){ //4 Way (Diag)
					for(i=0; i<4; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, 45+90*i, 150);
					}
				}
				doConstantAttack = -8;
			}
			if(doConstantAttack<0)
				++doConstantAttack;
			
			if(attackCond&&(attack1||barrierShift[200])){
				//Select an attack
				int attack;
				if(attack2==0)
					attack = attack1;
				else if(attack3==0)
					attack = Choose(attack1, attack2);
				else
					attack = Choose(attack1, attack2, attack3);
				
				if(EZB_DONT_REPEAT_LAST_ATTACK&&attack==lastAttack){
					if(attack2==0){
					}
					else if(attack3==0){
						for(i=0; i<32&&attack==lastAttack; ++i)
							attack = Choose(attack1, attack2);
					}
					else{
						for(i=0; i<32&&attack==lastAttack; ++i)
							attack = Choose(attack1, attack2, attack3);
					}
				}
				
				if(attack==1){ //Dash
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = 1;
					Ghost_Data = combo;
					Game->PlaySound(SFX_EZB_DASH);
					Ghost_UnsetFlag(GHF_KNOCKBACK);
					while(EZB_CanMoveAngle(angle)){
						k = Min(k+0.2, 3);
						Ghost_MoveAtAngle(angle, k, 0);
						EZB_Trail(this, ghost, barrierShift);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					if(flags&EZBF_KNOCKBACK){
						Ghost_SetFlag(GHF_KNOCKBACK);
					}
				}
				if(attack==2){ //Shoot (Directional)
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir), 180);
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==3){ //Shoot (Angular)
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 180);
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==4){ //Tri Shot (Directional)
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=-1; i<=1; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir)+30*i, 250);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==5){ //Tri Shot (Angular)
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=-1; i<=1; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+30*i, 250);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==6){ //Stream (Directional)
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = EZB_DirAngle(Ghost_Dir);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					for(i=0; i<10; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 350);
						EZB_Waitframes(this, ghost, barrierShift, 8);
					}
					EZB_Waitframes(this, ghost, barrierShift, 12);
				}
				if(attack==7){ //Stream (Angular)
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					for(i=0; i<10; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 350);
						EZB_Waitframes(this, ghost, barrierShift, 8);
					}
					EZB_Waitframes(this, ghost, barrierShift, 12);
				}
				if(attack==8){ //Breath (Directional)
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = EZB_DirAngle(Ghost_Dir);
					EZB_Waitframes(this, ghost, barrierShift, 24);
					for(i=0; i<24; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+Rand(-10, 10), 250);
						EZB_Waitframes(this, ghost, barrierShift, 4);
					}
				}
				if(attack==9){ //Breath (Angular)
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 24);
					for(i=0; i<24; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+Rand(-10-i, 10+i), 250);
						EZB_Waitframes(this, ghost, barrierShift, 4);
					}
				}
				if(attack==10){ //Sweep (Directional)
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					k = Choose(-1, 1);
					angle = EZB_DirAngle(Ghost_Dir)-75*k;
					for(i=0; i<7; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 150);
						angle += k*25;
						EZB_Waitframes(this, ghost, barrierShift, 4);
					}
					EZB_Waitframes(this, ghost, barrierShift, 48);
				}
				if(attack==11){ //Sweep (Angular)
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					k = Choose(-1, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())-75*k;
					for(i=0; i<7; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 150);
						angle += k*25;
						EZB_Waitframes(this, ghost, barrierShift, 2);
					}
					EZB_Waitframes(this, ghost, barrierShift, 48);
				}
				if(attack==12){ //Bullet Barrage
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())-45;
					for(i=0; i<3; ++i){
						for(j=-4; j<=4; j+=2){
							EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+16*j, 150);
						}
						EZB_Waitframes(this, ghost, barrierShift, 16);
						for(j=-5; j<=5; j+=2){
							EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+16*j, 150);
						}
						EZB_Waitframes(this, ghost, barrierShift, 24);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==13){ //Bullet Swirl
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					k = Choose(-1, 1);
					angle = Rand(360);
					for(i=0; i<15; ++i){
						for(j=0; j<5; ++j){
							EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+72*j, 150);
						}
						angle += 4*k;
						EZB_Waitframes(this, ghost, barrierShift, 4);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==14){ //Bullet Rings
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					for(i=0; i<3; ++i){
						angle = Rand(360);
						for(j=0; j<10; ++j){
							EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+360/10*j, 180);
						}
						EZB_Waitframes(this, ghost, barrierShift, 45);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==15){ //Laser
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=0; i<30; ++i){
						if(i%4<2){
							EZB_DrawLaser(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 8, angle, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_LASER);
					for(i=0; i<20; ++i){
						EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 8, angle, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==16){ //Big Laser
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					for(i=0; i<60; ++i){
						if(i%4<2){
							EZB_DrawLaser(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 40, angle, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_LASER);
					for(i=0; i<40; ++i){
						EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 40, angle, ghost->WeaponDamage*2, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==17){ //Laser Spread
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = (w*8+h*8)/2;
					for(i=0; i<40; ++i){
						for(j=-2; j<=2; ++j){
							if(i%4<2){
								x = CenterX(ghost)+VectorX(k, angle+30*j);
								y = CenterY(ghost)+VectorY(k, angle+30*j);
								EZB_DrawLaser(LAYER_EZB_LASER, x, y, 6, angle+30*j, C_EZB_LASER3);
							}
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_LASER);
					for(i=0; i<25; ++i){
						for(j=-2; j<=2; ++j){
							x = CenterX(ghost)+VectorX(k, angle+30*j);
							y = CenterY(ghost)+VectorY(k, angle+30*j);
							EZB_Laser3Color(LAYER_EZB_LASER, x, y, 6, angle+30*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==18){ //Laser Cross
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					k = Choose(-1, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+45;
					Game->PlaySound(SFX_EZB_LASER);
					for(i=0; i<40; ++i){
						if(Distance(CenterX(ghost), CenterY(ghost), 128, 88)>8){
							Ghost_MoveAtAngle(Angle(CenterX(ghost), CenterY(ghost), 128, 88), 0.8, 0);
						}
						for(j=0; j<4; ++j){
							if(i%4<2){
								EZB_DrawLaser(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 6, angle+90*j, C_EZB_LASER3);
							}
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(i=0; i<30; ++i){
						for(j=0; j<4; ++j){
							EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 6, angle+90*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(i=0; i<30; ++i){
						for(j=0; j<4; ++j){
							EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 6, angle+90*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						angle += k;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(i=0; i<120; ++i){
						for(j=0; j<4; ++j){
							EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 6, angle+90*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						angle += k*1.25;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(i=0; i<30; ++i){
						for(j=0; j<4; ++j){
							EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 6, angle+90*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						angle += k;
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==19){ //Summon 1 Enemy
					if ( Screen->NumNPCs() < EZB_TOTAL_SUMMON_CAP && EZB_NumSummons(summons) < EZB_SUMMON_CAP ) {
						EZB_FiringAnim(this, ghost, barrierShift, 0);
						Game->PlaySound(SummonSFX);
						enem = CreateNPCAt(special, CenterX(ghost)-8, CenterY(ghost)-8);
						EZB_AddSummon(enem, summons);
						EZB_Waitframes(this, ghost, barrierShift, 24);
					}
				}
				if(attack==20){ //Summon 2 Enemies
					if ( Screen->NumNPCs() < EZB_TOTAL_SUMMON_CAP && EZB_NumSummons(summons) < EZB_SUMMON_CAP ) {
						EZB_FiringAnim(this, ghost, barrierShift, 0);
						Game->PlaySound(SummonSFX);
						for(i=0; i<2; ++i){
							enem = CreateNPCAt(special, CenterX(ghost)-8+Rand(-4, 4), CenterY(ghost)-8+Rand(-4, 4));
							EZB_AddSummon(enem, summons);
						}
						EZB_Waitframes(this, ghost, barrierShift, 24);
					}
				}
				if(attack==21){ //Summon 3 Enemies
					if ( Screen->NumNPCs() < EZB_TOTAL_SUMMON_CAP && EZB_NumSummons(summons) < EZB_SUMMON_CAP ) {
						EZB_FiringAnim(this, ghost, barrierShift, 0);
						Game->PlaySound(SummonSFX);
						for(i=0; i<3; ++i){
							enem = CreateNPCAt(special, CenterX(ghost)-8+Rand(-4, 4), CenterY(ghost)-8+Rand(-4, 4));
							EZB_AddSummon(enem, summons);
						}
						EZB_Waitframes(this, ghost, barrierShift, 24);
					}
				}
				if(attack==22){ //Homing Shot
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					eweapon wpn = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 100);
					SetEWeaponMovement(wpn, EWM_HOMING, DegtoRad(2), 120);
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==23){ //5 Aimed Shots (With Delays)
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=0; i<5; ++i){
						EZB_FaceLink(this, ghost, barrierShift);
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 200);
						EZB_Waitframes(this, ghost, barrierShift, 25);
					}
				}
				if(attack==24){ //10 Aimed Shots (Quick)
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=0; i<10; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 200);
						EZB_Waitframes(this, ghost, barrierShift, 6);
					}
				}
				if(attack==25){ //Aimed Bullet Circle
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					for(i=0; i<12; ++i){
						eweapon wpn = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, 360/12*i, 200);
						SetEWeaponMovement(wpn, EWM_HOMING_REAIM, 1, 30);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==26){ //4 Way Shot (Normal)
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=0; i<4; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, 90*i, 150);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==27){ //4 Way Shot (Diagonal)
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=0; i<4; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, 45+90*i, 150);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==28){ //8 Way Shot
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					for(i=0; i<8; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, 45*i, 150);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==29){ //Bullet Storm
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = 0;
					if ( CenterLinkX() < 128 )
						angle = 180;
					for(i=0; i<20; ++i){
						if ( angle == 0 )
							EZB_Fire(this, ghost, barrierShift, 0, Rand(8, 152), angle, 250);
						else
							EZB_Fire(this, ghost, barrierShift, 240, Rand(8, 152), angle, 250);
						EZB_Waitframes(this, ghost, barrierShift, 8);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==30){ //Laser Storm
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					k = Rand(8, 152);
					for(i=0; i<35; ++i){
						if(i%4<2){
							EZB_DrawLaser(LAYER_EZB_LASER, -32, k, 8, 0, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(j=0; j<8; ++j){
						Game->PlaySound(SFX_EZB_LASER);
						y = k;
						k = Rand(8, 152);
						while(k-y > -40 && k-y < 40) { //make sure next laser is not too close to current laser
							k = Rand(8, 152);
						}
						for(i=0; i<35; ++i){
							if(i<20){
								EZB_Laser3Color(LAYER_EZB_LASER, -32, y, 8, 0, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
							}
							if(j<7){ //dont show the last laser
								if(i%4<2){
									EZB_DrawLaser(LAYER_EZB_LASER, -32, k, 8, 0, C_EZB_LASER3);
								}
							}
							EZB_Waitframe(this, ghost, barrierShift);
						}
					}
				}
				if(attack==31){ //Laser Expansion
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					k = 0;
					while(true){
						for(i=0; i<30; ++i){
							for(j=-1; j<=1; j+=2){
								if(i%4<2){
									EZB_DrawLaser(LAYER_EZB_LASER, CenterX(ghost)+24*k*j, -32, 12, 90, C_EZB_LASER3);
								}
							}
							EZB_Waitframe(this, ghost, barrierShift);
						}
						Game->PlaySound(SFX_EZB_LASER);
						for(i=0; i<20; ++i){
							for(j=-1; j<=1; j+=2){
								EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost)+24*k*j, -32, 12, 90, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
							}
							EZB_Waitframe(this, ghost, barrierShift);
						}
						++k;
						if ( CenterX(ghost)+24*k*-1 < 16 && CenterX(ghost)+24*k > 224 || k > 10 )
							break;
						//stop if Link has crossed the attack
						if ( k > 2 && Link->X+8-16 > CenterX(ghost)+24*k*-1 && Link->X+8+16 < CenterX(ghost)+24*k )
							break;
					}
				}
				if(attack==32){ //2 Shot Spread 40 degrees
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=0; i<2; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())-20+40*i, 250);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==33){ //Bash
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = 1;
					Ghost_Data = combo;
					Game->PlaySound(SFX_EZB_DASH);
					Ghost_UnsetFlag(GHF_KNOCKBACK);
					for(i=0; i<10; ++i){
						k = Min(k+0.5, 5);
						Ghost_MoveAtAngle(angle, k, 0);
						EZB_Trail(this, ghost, barrierShift);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					if(flags&EZBF_KNOCKBACK){
						Ghost_SetFlag(GHF_KNOCKBACK);
					}
				}
				if(attack==34){ //Shooting Dash
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = 2;
					Game->PlaySound(SFX_EZB_DASH);
					i = 0;
					Ghost_Data = combo;
					Ghost_UnsetFlag(GHF_KNOCKBACK);
					while(EZB_CanMoveAngle(angle)){
						++i;
						k = Min(k+0.2, 3);
						Ghost_MoveAtAngle(angle, k, 0);
						if(i%4==0){
							if(ghost->Weapon==WPN_ENEMYFLAME||ghost->Weapon==WPN_ENEMYFIRETRAIL){
								EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 0);
							}
							else{
								EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 150);
							}
						}
						EZB_Trail(this, ghost, barrierShift);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					if(flags&EZBF_KNOCKBACK){
						Ghost_SetFlag(GHF_KNOCKBACK);
					}
				}
				if(attack==35){ //Double Dash
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = 2;
					Game->PlaySound(SFX_EZB_DASH);
					i = 0;
					Ghost_Data = combo;
					Ghost_UnsetFlag(GHF_KNOCKBACK);
					for(i=0; i<40; ++i){
						k = Min(k+0.1, 4);
						Ghost_MoveAtAngle(angle, k, 0);
						EZB_Trail(this, ghost, barrierShift);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_FaceLink(this, ghost, barrierShift);
					k = 2;
					Game->PlaySound(SFX_EZB_DASH);
					i = 0;
					Ghost_Data = combo;
					for(i=0; i<40; ++i){
						j = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
						if(i<20){
							if(Abs(EZB_AngDiff(angle, j))>1)
								angle = WrapDegrees(angle+1*Sign(EZB_AngDiff(angle, j)));
						}
						k = Min(k+0.1, 4);
						Ghost_MoveAtAngle(angle, k, 0);
						EZB_Trail(this, ghost, barrierShift);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					if(flags&EZBF_KNOCKBACK){
						Ghost_SetFlag(GHF_KNOCKBACK);
					}
				}
				if(attack==36){ //Jump
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					Game->PlaySound(SFX_JUMP);
					Ghost_Jump = 2.6;
					dist = Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = 2;
					if(dist<32)
						k = 0.5;
					else if(dist<64)
						k = 1;
					else if(dist<96)
						k = 2;
					else if(dist<128)
						k = 3;
					else
						k = 4;
					while(Ghost_Jump>0||Ghost_Z>0){
						Ghost_MoveAtAngle(angle, k, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==37){ //Double Jump
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					Game->PlaySound(SFX_JUMP);
					Ghost_Jump = 2.6;
					dist = Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = 2;
					if(dist<32)
						k = 0.5;
					else if(dist<64)
						k = 1;
					else if(dist<96)
						k = 2;
					else if(dist<128)
						k = 3;
					else
						k = 4;
					Ghost_Data = combo;
					while(Ghost_Jump>0||Ghost_Z>0){
						Ghost_MoveAtAngle(angle, k, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					
					Game->PlaySound(SFX_JUMP);
					Ghost_Jump = 2.6;
					while(Ghost_Jump>0||Ghost_Z>0){
						Ghost_MoveAtAngle(angle, k/2, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==38){ //Jump, Shockwave
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					
					Game->PlaySound(SFX_JUMP);
					Ghost_Jump = 3.2;
					dist = Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					k = 2;
					if(dist<32)
						k = 0.5;
					else if(dist<64)
						k = 1;
					else if(dist<96)
						k = 2;
					else if(dist<128)
						k = 3;
					else
						k = 4;
					
					Ghost_Data = combo;
					while(Ghost_Jump>0||Ghost_Z>0){
						Ghost_MoveAtAngle(angle, k, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_SHOCKWAVE);
					for(i=0; i<40+32; i+=3){
						EZB_Shockwave(2, CenterX(ghost), CenterY(ghost), i, 40, 12, ghost->WeaponDamage, C_EZB_SHOCKWAVE1, C_EZB_SHOCKWAVE2, C_EZB_SHOCKWAVE3);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					
				}
				if(attack==39){ //High Jump, Shockwave
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					EZB_FaceLink(this, ghost, barrierShift);
					
					Ghost_Data = combo;
					Game->PlaySound(SFX_JUMP);
					for(i=0; i<176; i+=4){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost));
							y = Sign(CenterLinkY()-CenterY(ghost));
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z += 4;
						Ghost_Jump = 0;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(i=0; i<180; ++i){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.5;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.5;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Jump = 0;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_FALL);
					while(Ghost_Z>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.2;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.2;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z = Max(Ghost_Z-4, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_SHAKE);
					Screen->Quake = 20;
					Game->PlaySound(SFX_EZB_SHOCKWAVE);
					for(i=0; i<80+48; i+=6){
						EZB_Shockwave(2, CenterX(ghost), CenterY(ghost), i, 80, 16, ghost->WeaponDamage, C_EZB_SHOCKWAVE1, C_EZB_SHOCKWAVE2, C_EZB_SHOCKWAVE3);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==40){ //High Jump, Rocks Fall
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					EZB_FaceLink(this, ghost, barrierShift);
					
					Ghost_Data = combo;
					Game->PlaySound(SFX_JUMP);
					for(i=0; i<176; i+=4){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost));
							y = Sign(CenterLinkY()-CenterY(ghost));
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z += 4;
						Ghost_Jump = 0;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(i=0; i<120; ++i){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.5;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.5;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Jump = 0;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_FALL);
					while(Ghost_Z>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.2;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.2;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z = Max(Ghost_Z-4, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_SHAKE);
					Screen->Quake = 20;
					for(i=0; i<30; ++i){
						e = EZB_Fire(this, ghost, barrierShift, Rand(16, 224), Rand(16, 144), Rand(360), Rand(50), EWF_SHADOW);
						SetEWeaponMovement(e, EWM_FALL, 176, EWMF_DIE);
						SetEWeaponDeathEffect(e, EWD_EXPLODE, e->Damage);
						EZB_Waitframes(this, ghost, barrierShift, Rand(2, 6));
					}
				}
				if(attack==41){ //High Jump, Enemies Fall
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					EZB_FaceLink(this, ghost, barrierShift);
					
					Ghost_Data = combo;
					Game->PlaySound(SFX_JUMP);
					for(i=0; i<176; i+=4){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost));
							y = Sign(CenterLinkY()-CenterY(ghost));
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z += 4;
						Ghost_Jump = 0;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					for(i=0; i<120; ++i){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.5;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.5;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Jump = 0;
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_FALL);
					while(Ghost_Z>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.2;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.2;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z = Max(Ghost_Z-4, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_SHAKE);
					Screen->Quake = 20;
					k = Rand(4, 7);
					for(i=0; i<k&&(Screen->NumNPCs() < EZB_TOTAL_SUMMON_CAP && EZB_NumSummons(summons) < EZB_SUMMON_CAP); ++i){
						j = Rand(176);
						for(m=0; m<352&&!EZB_CanPlace(this, ghost, ComboX(j), ComboY(j), 16, 16); m++){
							if(k<176)
								j = Rand(176);
							else
								j = m-176;
						}
						Game->PlaySound(SFX_FALL);
						enem = CreateNPCAt(special, ComboX(j), ComboY(j));
						EZB_AddSummon(enem, summons);
						enem->Z = 176;
						EZB_Waitframes(this, ghost, barrierShift, Rand(6, 17));
					}
				}
				if(attack==42){ //Chase
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					Ghost_Data = combo;
					for(i=0; i<300; ++i){
						angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
						Ghost_MoveAtAngle(angle, 1, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==43){ //Backstep
					EZB_FaceLink(this, ghost, barrierShift);
					angle = Angle(CenterLinkX(), CenterLinkY(), CenterX(ghost), CenterY(ghost));
					x = Ghost_X+VectorX(32, angle);
					y = Ghost_Y+VectorY(32, angle);
					if(EZB_CanPlace(this, ghost, x, y)){
						k = 3;
						Ghost_Data = combo;
						Game->PlaySound(SFX_EZB_BACKSTEP);
						Ghost_UnsetFlag(GHF_KNOCKBACK);
						for(i=0; i<10&&EZB_CanMoveAngle(angle); ++i){
							angle = Angle(CenterLinkX(), CenterLinkY(), CenterX(ghost), CenterY(ghost));
							k = Min(k+0.5, 5);
							Ghost_MoveAtAngle(angle, k, 0);
							EZB_FaceLink(this, ghost, barrierShift);
							EZB_Trail(this, ghost, barrierShift);
							EZB_Waitframe(this, ghost, barrierShift);
						}
					}
					else{
						EZB_FaceLink(this, ghost, barrierShift);
						EZB_FiringAnim(this, ghost, barrierShift, 1);
						EZB_FaceLink(this, ghost, barrierShift);
						angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
						k = 2;
						Ghost_Data = combo;
						Game->PlaySound(SFX_EZB_DASH);
						Ghost_UnsetFlag(GHF_KNOCKBACK);
						while(EZB_CanMoveAngle(angle)){
							k = Min(k+0.2, 3);
							Ghost_MoveAtAngle(angle, k, 0);
							EZB_Trail(this, ghost, barrierShift);
							EZB_Waitframe(this, ghost, barrierShift);
						}
					}
					if(flags&EZBF_KNOCKBACK){
						Ghost_SetFlag(GHF_KNOCKBACK);
					}
				}
				//attack == 44 //Constant Attack (Fireball, Directional)
				//attack == 45 //Constant Attack (Fireball, Angular)
				//attack == 46 //Constant Attack (Summon)
				//attack == 47 //Constant Attack (4 Way, HV)
				//attack == 48 //Constant Attack (4 Way, Diag)
				if(attack==49){ //Mega Laser
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					for(i=0; i<90; ++i){
						if(i%4<2){
							EZB_DrawLaser(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 64, angle, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_LASER);
					for(i=0; i<40; ++i){
						for(j=0; j<4; ++j){
							x = Ghost_X+Sign(VectorX(1, angle+180));
							y = Ghost_Y+Sign(VectorY(1, angle+180));
							if(EZB_CanPlace(this, ghost, x, y)){
								Ghost_MoveAtAngle(angle+180, 1, 0);
							}
						}
						EZB_Laser3Color(LAYER_EZB_LASER, CenterX(ghost), CenterY(ghost), 64, angle, ghost->WeaponDamage*2, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				//attack = 50 //Barrier Shift
				//attack = 51 //Enemy Shift
				if(attack==52){ //Flying Slam, Shockwave
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					EZB_FaceLink(this, ghost, barrierShift);
					
					Ghost_Jump = 4;
					Ghost_Data = combo;
					Game->PlaySound(SFX_JUMP);
					while(Ghost_Jump>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*1.3;
							y = Sign(CenterLinkY()-CenterY(ghost))*1.3;
							Ghost_MoveXY(x, y, 0);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					k = Ghost_Z;
					for(i=0; i<90; ++i){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.7;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.7;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Jump = 0;
						Ghost_Z = k+2*Sin(16*i);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_FALL);
					while(Ghost_Z>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.3;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.3;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z = Max(Ghost_Z-4, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_SHAKE);
					Screen->Quake = 4;
					Game->PlaySound(SFX_EZB_SHOCKWAVE);
					for(i=0; i<48+48; i+=6){
						EZB_Shockwave(2, CenterX(ghost), CenterY(ghost), i, 48, 16, ghost->WeaponDamage, C_EZB_SHOCKWAVE1, C_EZB_SHOCKWAVE2, C_EZB_SHOCKWAVE3);
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==53){ //Flying Slam, Rocks Fall
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					EZB_FaceLink(this, ghost, barrierShift);
					
					Ghost_Jump = 4;
					Ghost_Data = combo;
					Game->PlaySound(SFX_JUMP);
					while(Ghost_Jump>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*1.3;
							y = Sign(CenterLinkY()-CenterY(ghost))*1.3;
							Ghost_MoveXY(x, y, 0);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					k = Ghost_Z;
					for(i=0; i<90; ++i){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.7;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.7;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Jump = 0;
						Ghost_Z = k+2*Sin(16*i);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_FALL);
					while(Ghost_Z>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.3;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.3;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z = Max(Ghost_Z-4, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_SHAKE);
					Screen->Quake = 4;
					for(i=0; i<10; ++i){
						e = EZB_Fire(this, ghost, barrierShift, Rand(16, 224), Rand(16, 144), Rand(360), Rand(50), EWF_SHADOW);
						SetEWeaponMovement(e, EWM_FALL, 176, EWMF_DIE);
						SetEWeaponDeathEffect(e, EWD_EXPLODE, e->Damage);
						EZB_Waitframes(this, ghost, barrierShift, Rand(4, 12));
					}
				}
				if(attack==54){ //Flying Slam, Enemies Fall
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 2);
					EZB_FaceLink(this, ghost, barrierShift);
					
					Ghost_Jump = 4;
					Ghost_Data = combo;
					Game->PlaySound(SFX_JUMP);
					while(Ghost_Jump>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*1.3;
							y = Sign(CenterLinkY()-CenterY(ghost))*1.3;
							Ghost_MoveXY(x, y, 0);
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
					k = Ghost_Z;
					for(i=0; i<90; ++i){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.7;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.7;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Jump = 0;
						Ghost_Z = k+2*Sin(16*i);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_FALL);
					while(Ghost_Z>0){
						if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>2){
							x = Sign(CenterLinkX()-CenterX(ghost))*0.3;
							y = Sign(CenterLinkY()-CenterY(ghost))*0.3;
							Ghost_MoveXY(x, y, 0);
						}
						Ghost_Z = Max(Ghost_Z-4, 0);
						EZB_Waitframe(this, ghost, barrierShift);
					}
					Game->PlaySound(SFX_EZB_SHAKE);
					Screen->Quake = 4;
					k = Rand(2, 3);
					for(i=0; i<k&&(Screen->NumNPCs() < EZB_TOTAL_SUMMON_CAP && EZB_NumSummons(summons) < EZB_SUMMON_CAP); ++i){
						j = Rand(176);
						for(m=0; m<352&&!EZB_CanPlace(this, ghost, ComboX(j), ComboY(j), 16, 16); m++){
							if(k<176)
								j = Rand(176);
							else
								j = m-176;
						}
						Game->PlaySound(SFX_FALL);
						enem = CreateNPCAt(special, ComboX(j), ComboY(j));
						EZB_AddSummon(enem, summons);
						enem->Z = 176;
						EZB_Waitframes(this, ghost, barrierShift, Rand(6, 17));
					}
				}
				if(attack==55){ //Sine Wave Stream, Directional
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = EZB_DirAngle(Ghost_Dir);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					for(i=0; i<5; ++i){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 350);
						SetEWeaponMovement(e, EWM_SINE_WAVE, 16, 16);
						EZB_Waitframes(this, ghost, barrierShift, 8);
					}
					EZB_Waitframes(this, ghost, barrierShift, 12);
				}
				if(attack==56){ //Sine Wave Stream, Angular
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					for(i=0; i<5; ++i){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 250);
						SetEWeaponMovement(e, EWM_SINE_WAVE, 16, 16);
						EZB_Waitframes(this, ghost, barrierShift, 12);
					}
					EZB_Waitframes(this, ghost, barrierShift, 12);
				}
				if(attack==57){ //Sine Wave, 5 Shot
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Rand(360);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					j = Choose(-40, 40);
					for(k=0; k<3; ++k){
						for(i=0; i<5; ++i){
							e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+72*i, 250);
							SetEWeaponMovement(e, EWM_SINE_WAVE, j, 4);
						}
						EZB_Waitframes(this, ghost, barrierShift, 4);
					}
					EZB_Waitframes(this, ghost, barrierShift, 32);
				}
				if(attack==58){ //Reaim, Cross, Directional
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = EZB_DirAngle(Ghost_Dir);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					for(i=-1; i<=1; i+=2){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+25*i, 300);
						j = 0;
						if(ghost->Weapon==WPN_ENEMYFIREBALL)
							j = 16;
						SetEWeaponLifespan(e, EWL_TIMER, 24+j);
						SetEWeaponDeathEffect(e, EWD_AIM_AT_LINK, 16);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==59){ //Reaim, Cross, Angular
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					for(i=-1; i<=1; i+=2){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+45*i, 250);
						j = 0;
						if(ghost->Weapon==WPN_ENEMYFIREBALL)
							j = 16;
						SetEWeaponLifespan(e, EWL_TIMER, 30+j);
						SetEWeaponDeathEffect(e, EWD_AIM_AT_LINK, 16);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==60){ //Throw, Fixed Dist
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 150, EWF_UNBLOCKABLE|EWF_SHADOW);
					SetEWeaponMovement(e, EWM_THROW, 3.6, EWMF_DIE);
					EZB_SetEWeaponDeathEffect(e);
					
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==61){ //Throw, To Link
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 200, EWF_UNBLOCKABLE|EWF_SHADOW);
					SetEWeaponMovement(e, EWM_THROW, -1, EWMF_DIE);
					EZB_SetEWeaponDeathEffect(e);
					
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==62){ //Throw, To Link, Stream
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					
					for(i=0; i<16; ++i){
						angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 200, EWF_UNBLOCKABLE|EWF_SHADOW);
						SetEWeaponMovement(e, EWM_THROW, -1, EWMF_DIE);
						EZB_SetEWeaponDeathEffect(e);
						
						EZB_Waitframes(this, ghost, barrierShift, 6);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==63){ //Throw, Five Shot
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=-2; i<=2; ++i){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+20*i, 200, EWF_UNBLOCKABLE|EWF_SHADOW);
						SetEWeaponMovement(e, EWM_THROW, 3.6, EWMF_DIE);
						EZB_SetEWeaponDeathEffect(e);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==64){ //Throw, 6 Shot, Volley
					EZB_FaceLink(this, ghost, barrierShift);
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=0; i<=6; ++i){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+Rand(-30, 30), Rand(100, 300), EWF_UNBLOCKABLE|EWF_SHADOW);
						SetEWeaponMovement(e, EWM_THROW, Rand(24, 36)/10, EWMF_DIE);
						EZB_SetEWeaponDeathEffect(e);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==65){ //Throw, Splash
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=0; i<=18; ++i){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, Rand(360), Rand(100, 400), EWF_UNBLOCKABLE|EWF_SHADOW);
						SetEWeaponMovement(e, EWM_THROW, Rand(24, 36)/10, EWMF_DIE);
						EZB_SetEWeaponDeathEffect(e);
					}
				}
				if(attack==66){ //8 Shots, Line, Directional
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					for(i=0; i<8; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir), 200+400*(i/7));
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==67){ //8 Shots, Line, Angular
					EZB_FiringAnim(this, ghost, barrierShift, 1);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=0; i<8; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 200+400*(i/7));
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==68){ //Teleport and Shoot
					EZB_Teleport(this, ghost, barrierShift);
					
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 150);
					
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==69){ //Teleport and Shoot Triple Shot
					EZB_Teleport(this, ghost, barrierShift);
					
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, barrierShift, 12);
					for(i=-1; i<=1; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+20*i, 250);
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==70){ //Teleport 3 Times, Shoot 8 Shots in a line
					for(i=0; i<3; ++i){
						EZB_Waitframes(this, ghost, barrierShift, 4);
						EZB_Teleport(this, ghost, barrierShift);
					}
					
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=0; i<8; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle, 200+400*(i/7));
					}
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==71){ //Throw 3, Fixed Dist, Directional
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					
					angle = EZB_DirAngle(Ghost_Dir);
					for(i=-15; i<=15; i+=15){
						e = EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, angle+i, 150, EWF_UNBLOCKABLE|EWF_SHADOW);
						SetEWeaponMovement(e, EWM_THROW, 3.6, EWMF_DIE);
						EZB_SetEWeaponDeathEffect(e);
					}
					
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==72){ //Directional shot
					/*
					if ( Rand(5) == 0 ) {
						for(i=0; i<2; ++i){
							EZB_Teleport(this, ghost, barrierShift);
							EZB_Waitframes(this, ghost, barrierShift, 18);
						}
					}
					*/
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					EZB_Waitframes(this, ghost, barrierShift, 12);
					EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir), 180);
					EZB_Waitframes(this, ghost, barrierShift, 12);
				}
				if(attack==73){ //Octo Spin Shots
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					for(i=0; i<4; ++i){
						EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir), 250);
						EZB_Waitframes(this, ghost, barrierShift, 24);
						Ghost_Dir = RotateDirNum(Ghost_Dir, 3);
					}
					EZB_Fire(this, ghost, barrierShift, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir), 250);
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				if(attack==74){ //Orb that shoots 4
					EZB_FiringAnim(this, ghost, barrierShift, 0);
					eweapon PulseOrb = Screen->CreateEWeapon(EW_SCRIPT10);
					PulseOrb->DrawYOffset = 0;
					PulseOrb->UseSprite(110);
					PulseOrb->CollDetection = false;
					PulseOrb->DeadState = 2;
					int Vars[11];
					Vars[0] = Link->X; // target x
					Vars[1] = Link->Y; // target y
					Vars[2] = Ghost_X; // curr x
					Vars[3] = Ghost_Y; // curr y
					Vars[4] = Distance(Ghost_X, Ghost_Y, Link->X, Link->Y) * 0.045; // speed
					Vars[5] = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y); // angle
					Vars[6] = 45; // timer
					if ( Ghost_X < Link->X ) { // dest x field 
						Vars[7] = Link->X;
						Vars[8] = 1000;
					}
					else {
						Vars[7] = -1000;
						Vars[8] = Link->X;
					}
					if ( Ghost_Y < Link->Y ) { // dest y field
						Vars[9] = Link->Y;
						Vars[10] = 1000;
					}
					else {
						Vars[9] = -1000;
						Vars[10] = Link->Y;
					}
					
					for(i=0; i<90; ++i){
						if ( Vars[4] > 0 ) {
							Vars[2] = Vars[2] + VectorX(Max(Vars[4], 2.25), Vars[5]);
							Vars[3] = Vars[3] + VectorY(Max(Vars[4], 2.25), Vars[5]);
						}
						
						if ( PointWithinRect(Vars[2], Vars[3], Vars[7], Vars[9], Vars[8], Vars[10]) ) { // destination reached
							Vars[4] = 0;
							Vars[2] = Vars[0];
							Vars[3] = Vars[1];
						}
						
						PulseOrb->X = Vars[2];
						PulseOrb->Y = Vars[3];
						PulseOrb->DeadState = 2;
						
						if ( Vars[4] == 0 ) {
							if ( Vars[6] == 0 ) {
								for(j=0; j<4; ++j){
									EZB_Fire(this, ghost, barrierShift, PulseOrb->X+VectorX(4, EZB_DirAngle(j)), PulseOrb->Y+VectorY(4, EZB_DirAngle(j)), EZB_DirAngle(j), 250);
								}
								break;
							}
							else
								Vars[6] --;
						}
						EZB_Waitframe(this, ghost, barrierShift);
					}
				}
				if(attack==75){ //Do nothing
					EZB_Waitframes(this, ghost, barrierShift, 24);
				}
				
				if(barrierShift[200]){
					Game->PlaySound(SFX_EZB_BARRIERSHIFT);
					if(barrierShift[200]==2)
						EZB_Barriershift_Load(ghost, barrierShift, false);
					else
						EZB_Barriershift_Load(ghost, barrierShift, true);
				
					if(barrierShift[200]==2){
						//When morphing into a different enemy, reload all init stuff
						Ghost_UnsetFlag(GHF_8WAY);
						Ghost_UnsetFlag(GHF_4WAY);
						Ghost_UnsetFlag(GHF_NO_FALL);
						Ghost_UnsetFlag(GHF_IGNORE_ALL_TERRAIN);
						Ghost_UnsetFlag(GHF_FLYING_ENEMY);
						Ghost_UnsetFlag(GHF_FAKE_Z);
						Ghost_UnsetFlag(GHF_WATER_ONLY);
						Ghost_UnsetFlag(GHF_KNOCKBACK);
						Ghost_UnsetFlag(GHF_FAKE_Z);
						Ghost_UnsetFlag(GHF_CLOCK);
						Ghost_UnsetFlag(GHF_STUN);
						
						movementStyle = barrierShift[300];
						attack1 = barrierShift[301];
						attack2 = barrierShift[302];
						attack3 = barrierShift[303];
						shaveHitbox = barrierShift[304];
						special = barrierShift[305];
						size = barrierShift[306];
						fireSFX = barrierShift[307];
						fireSPR = barrierShift[308];
						flags = barrierShift[309];
						
						constantAttack = 0;
						doConstantAttack = 0;
						
						//Certain attacks in Attack 1 do a constant attack instead
						//This is triggered at certain parts of the enemy's walk pattern
						if(attack1==44)
							constantAttack = 44;
						else if(attack1==45)
							constantAttack = 45;
						else if(attack1==46)
							constantAttack = 46;
						else if(attack1==47)
							constantAttack = 47;
						else if(attack1==48)
							constantAttack = 48;
						
						if(attack1==50||attack1==51){
							EZB_Barriershift_Store(ghost, special, barrierShift);
							if(attack1==51)
								barrierShift[200] = 2;
						}
						
						//If there's a constant attack, shift all other attacks down
						if(constantAttack>0||(attack1==50||attack1==51)){
							attack1 = attack2;
							attack2 = attack3;
							attack3 = 0;
						}
						
						shaveX = shaveHitbox&1111b;
						shaveY = Floor(shaveHitbox>>4)&1111b;
						
						//An enemy with no collision uses stun to turn it off and so cannot be stunned normally
						if(!(flags&EZBF_NOCOLL)&&!(flags&EZBF_NOSTUN)){
							Ghost_SetFlag(GHF_STUN);
							Ghost_SetFlag(GHF_CLOCK);
						}
						
						w = size&1111b;
						h = (size>>4)&1111b;
						if(h==0)
							h = w;
						w = Clamp(w, 1, 4);
						h = Clamp(h, 1, 4);
							
						combo = barrierShift[310];
						if(Ghost_TileWidth!=w||Ghost_TileHeight!=h)
							Ghost_Transform(this, ghost, -1, -1, w, h);
						Ghost_SetHitOffsets(ghost, shaveY, shaveY, shaveX, shaveX);
						
						if(flags&EZBF_8WAY)
							Ghost_SetFlag(GHF_8WAY);
						else if(flags&EZBF_4WAY)
							Ghost_SetFlag(GHF_4WAY);
						if(flags&EZBF_NOFALL)
							Ghost_SetFlag(GHF_NO_FALL);
						if(flags&EZBF_FLYING){
							Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
							Ghost_SetFlag(GHF_FLYING_ENEMY);
							this->Flags[FFCF_OVERLAY] = true;
							if(EZB_FLYING_ZPOS&&(flags&EZBF_NOFALL)&&!IsSideview()){
								Ghost_SetFlag(GHF_FAKE_Z);
								Ghost_Z = 8;
							}
						}
						else if(flags&EZBF_AQUATIC){
							Ghost_SetFlag(GHF_WATER_ONLY);
						}
						if(flags&EZBF_KNOCKBACK){
							Ghost_SetFlag(GHF_KNOCKBACK);
						}
						if(EZB_ALWAYS_FAKE_Z)
							Ghost_SetFlag(GHF_FAKE_Z);
						
						stepCounter = -1;
						attackCooldown = ghost->Haltrate*15 - Rand(ghost->Haltrate*4);
						stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
						stepCooldown = ghost->Rate;
						vX = 0; vY = 0;
						int lastAttack = -1;
						
						if(movementStyle==4){
							angle = Rand(360);
							vX = VectorX(ghost->Step/100, angle);
							vY = VectorY(ghost->Step/100, angle);
						}
						if(movementStyle==11){
							stepAngle = Rand(4);
						}
					}
				}
				Ghost_Data = combo;
				
				lastAttack = attack;
				attackCooldown = ghost->Haltrate*15 - Rand(ghost->Haltrate*4);
				if(movementStyle==4){ //Wall bounce
					angle = Rand(360);
					vX = VectorX(ghost->Step/100, angle);
					vY = VectorY(ghost->Step/100, angle);
				}
			}
			EZB_Waitframe(this, ghost, barrierShift);
		}
	}
	bool EZB_CanMoveAngle(int angle){
		int vx = VectorX(10, angle);
		int vy = VectorY(10, angle);
		if((vx<0&&!Ghost_CanMove(DIR_LEFT, 1, 0))||(vx>0&&!Ghost_CanMove(DIR_RIGHT, 1, 0)))
			return false;
		if((vy<0&&!Ghost_CanMove(DIR_UP, 1, 0))||(vy>0&&!Ghost_CanMove(DIR_DOWN, 1, 0)))
			return false;
		return true;
	}
	void EZB_FiringAnim(ffc this, npc ghost, int barrierShift, int delayType){
		int movementStyle = barrierShift[300];
		int flags = barrierShift[309];
		int combo = barrierShift[310];
		if(flags&EZBF_8WAY)
			Ghost_Data = combo+8;
		else if(flags&EZBF_4WAY)
			Ghost_Data = combo+4;
		else
			Ghost_Data = combo+1;
		
		if(delayType==0){ //Normal delay
			if(movementStyle!=0) //Halting walk doesn't need a delay for most attacks
				EZB_Waitframes(this, ghost, barrierShift, EZB_WINDUP_ATTACK);
		}
		else if(delayType==1){ //Medium delay (shake)
			if(movementStyle!=0){
				int dX = 0;
				int dY = 0;
				for(int i=0; i<EZB_WINDUP_ATTACK_MED; ++i){
					if(EZB_DO_WINDUP_SHAKE>1){
						Ghost_X -= dX;
						Ghost_Y -= dY;
						dX = Rand(-1, 1);
						dY = Rand(-1, 1);
						Ghost_X += dX;
						Ghost_Y += dY;
					}
					EZB_Waitframe(this, ghost, barrierShift);
				}
				Ghost_X -= dX;
				Ghost_Y -= dY;
			}
		}
		else if(delayType==2){ //Big delay (shake)
			int dX = 0;
			int dY = 0;
			for(int i=0; i<EZB_WINDUP_ATTACK_STRONG; ++i){
				if(EZB_DO_WINDUP_SHAKE>0){
					Ghost_X -= dX;
					Ghost_Y -= dY;
					dX = Rand(-2, 2);
					dY = Rand(-2, 2);
					Ghost_X += dX;
					Ghost_Y += dY;
				}
				EZB_Waitframe(this, ghost, barrierShift);
			}
			Ghost_X -= dX;
			Ghost_Y -= dY;
		}
	}
	void EZB_Trail(ffc this, npc ghost, int barrierShift){
		if(!EZB_ENABLE_SPEEDTRAILS)
			return;
		
		int flags = barrierShift[309];
		int tile = Game->ComboTile(Ghost_Data);
		if(flags&EZBF_4WAY||flags&EZBF_8WAY)
			tile = Game->ComboTile(Ghost_Data+Ghost_Dir);
		lweapon trail = CreateLWeaponAt(LW_SCRIPT10, ghost->X+ghost->DrawXOffset, ghost->Y+ghost->DrawYOffset);
		trail->Extend = 3;
		trail->TileWidth = ghost->TileWidth;
		trail->TileHeight = ghost->TileHeight;
		trail->DrawYOffset = 0;
		trail->CSet = this->CSet;
		trail->Tile = tile;
		trail->OriginalTile = tile;
		trail->DrawStyle = DS_PHANTOM;
		trail->DeadState = 8;
	}
	int EZB_DirAngle(int dir){
		if(dir==DIR_UP)
			return -90;
		else if(dir==DIR_DOWN)
			return 90;
		else if(dir==DIR_LEFT)
			return 180;
		else if(dir==DIR_LEFTUP)
			return -135;
		else if(dir==DIR_RIGHTUP)
			return -45;
		else if(dir==DIR_LEFTDOWN)
			return 135;
		else if(dir==DIR_RIGHTDOWN)
			return 45;
		else
			return 0;
	}
	eweapon EZB_Fire(ffc this, npc ghost, int barrierShift, int x, int y, int angle, int step){
		eweapon e = EZB_Fire(this, ghost, barrierShift, x, y, angle, step, 0);
		return e;
	}
	eweapon EZB_Fire(ffc this, npc ghost, int barrierShift, int x, int y, int angle, int step, int wflags){
		int flags = barrierShift[309];
		int type = EZB_WeaponTypeToID(ghost->Weapon);
		if(flags&EZBF_UNBLOCKABLE)
			wflags |= EWF_UNBLOCKABLE;
		int fireSFX = barrierShift[307];
		int fireSPR = barrierShift[308];
		if(fireSPR==0&&(type==EW_BEAM||type==EW_ARROW||type==EW_MAGIC||type==EW_BOMB||type==EW_SBOMB))
			wflags |= EWF_ROTATE;
		
		if(fireSPR>=2000){
			wflags |= EWF_ROTATE_360;
			fireSPR -= 2000;
		}
		else if(fireSPR>=1000){
			wflags |= EWF_ROTATE;
			fireSPR -= 000;
		}
		int sfx = fireSFX;
		if(fireSFX<=0)
			sfx = -1;
		int spr = fireSPR;
		if(fireSPR<=0)
			spr = -1;
		eweapon e = FireEWeapon(type, x, y, DegtoRad(angle), step, ghost->WeaponDamage, spr, sfx, wflags);
		return e;
	}
	int EZB_WeaponTypeToID(int wpnt){
		if(wpnt == WPN_ENEMYFLAME) 		return EW_FIRE;
		else if(wpnt == WPN_ENEMYWIND)		return EW_WIND;
		else if(wpnt == WPN_ENEMYFIREBALL)	return EW_FIREBALL;
		else if(wpnt == WPN_ENEMYARROW)		return EW_ARROW;
		else if(wpnt == WPN_ENEMYBRANG)		return EW_BRANG;
		else if(wpnt == WPN_ENEMYSWORD)		return EW_BEAM;
		else if(wpnt == WPN_ENEMYROCK)		return EW_ROCK;
		else if(wpnt == WPN_ENEMYMAGIC)		return EW_MAGIC;
		else if(wpnt == WPN_ENEMYBOMB)		return EW_BOMBBLAST; //flipped bomb and lit bomb in older versions of this file. -Z ( 12th February, 2019 )
		else if(wpnt == WPN_ENEMYSBOMB)		return EW_SBOMBBLAST;
		else if(wpnt == WPN_ENEMYLITBOMB)	return EW_BOMB;
		else if(wpnt == WPN_ENEMYLITSBOMB)	return EW_SBOMB;
		else if(wpnt == WPN_ENEMYFIRETRAIL)	return EW_FIRETRAIL;
		else if(wpnt == WPN_ENEMYFLAME2)	return EW_FIRE2;
		else if(wpnt == WPN_ENEMYFIREBALL2)	return EW_FIREBALL2;
		return -1;
	}
	void EZB_SetEWeaponDeathEffect(eweapon e){
		if(e->ID==EW_FIRE||e->ID==EW_FIRE2){
			SetEWeaponDeathEffect(e, EWD_8_FIRES, -1);
		}
		else if(e->ID==EW_FIRETRAIL){
			SetEWeaponDeathEffect(e, EWD_FIRE, -1);
		}
		else if(e->ID==EW_BOMB){
			SetEWeaponDeathEffect(e, EWD_EXPLODE, e->Damage);
		}
		else if(e->ID==EW_SBOMB){
			SetEWeaponDeathEffect(e, EWD_SBOMB_EXPLODE, e->Damage);
		}
		else if(e->ID==EW_ARROW){
			SetEWeaponDeathEffect(e, EWD_4_FIREBALLS_HV, -1);
		}
		else if(e->ID==EW_MAGIC){
			SetEWeaponDeathEffect(e, EWD_AIM_AT_LINK, 16);
		}
		else{
			SetEWeaponDeathEffect(e, EWD_VANISH, -1);
		}
	}
	void EZB_DrawTeleport(ffc this, npc ghost, int barrierShift, int x, int y, int frame, int maxFrame){
		int w = Ghost_TileWidth;
		int h = Ghost_TileHeight;
		
		int flags = barrierShift[309];
		
		int cmb = Ghost_Data;
		if(flags&EZBF_4WAY||flags&EZBF_8WAY)
			cmb+=Ghost_Dir;
		
		int layer = 2;
		if(ScreenFlag(1, 4)) //Layer -2
			layer = 1;
		int i = frame/maxFrame;
		int op = 128;
		if(frame>maxFrame-8)
			op = 64;
		Screen->DrawCombo(layer, x+w*8*i, y-h*24*i, cmb, w, h, this->CSet, w*16-w*16*i, h*16+h*24*i, 0, 0, 0, -1, 0, true, op);
	}
	void EZB_Teleport(ffc this, npc ghost, int barrierShift){
		int size = barrierShift[306];
		int flags = barrierShift[309];
		int combo = barrierShift[310];
		int w = size&1111b;
		int h = (size>>4)&1111b;
		if(h==0)
			h = w;
		w = Clamp(w, 1, 4);
		h = Clamp(h, 1, 4);
		
		Game->PlaySound(SFX_EZB_TELEPORT);
		int tc;
		ghost->CollDetection = false;
		ghost->DrawYOffset = -1000;
		int oldCombo = Ghost_Data;
		for(int i=0; i<16; ++i){
			if(EZB_TELEPORT_TYPE==1){
				EZB_DrawTeleport(this, ghost, barrierShift, Ghost_X, Ghost_Y-2, i, 16);
			}
			else if(EZB_TELEPORT_TYPE==2){
				ghost->DrawYOffset = -2;
				if(flags&EZBF_4WAY)
					Ghost_Data = combo+8;
				else if(flags&EZBF_8WAY)
					Ghost_Data = combo+16;
				else
					Ghost_Data = combo+2;
			}
			else{
				if(i%2==0)
					ghost->DrawYOffset = -1000;
				else
					ghost->DrawYOffset = -2;
			}
			EZB_Waitframe(this, ghost, barrierShift);
		}
		ghost->DrawYOffset = -1000;
		tc = Rand(176);
		for(int i=0; i<352&&(!EZB_CanPlace(this, ghost, ComboX(tc), ComboY(tc))||Distance(ComboX(tc)+ghost->HitWidth/2, ComboY(tc)+ghost->HitHeight/2, CenterLinkX(), CenterLinkY())<((w+h)/2)*8+32); ++i){
			if(i>=176)
				tc = i-176;
			else
				tc = Rand(176);
		}
		Ghost_X = ComboX(tc);
		Ghost_Y = ComboY(tc);
		EZB_Waitframe(this, ghost, barrierShift);
		EZB_FaceLink(this, ghost, barrierShift);
		for(int i=0; i<16; ++i){
			if(EZB_TELEPORT_TYPE==1){
				EZB_DrawTeleport(this, ghost, barrierShift, Ghost_X, Ghost_Y-2, 16-i, 16);
			}
			else if(EZB_TELEPORT_TYPE==2){
				ghost->DrawYOffset = -2;
				if(flags&EZBF_4WAY)
					Ghost_Data = combo+8;
				else if(flags&EZBF_8WAY)
					Ghost_Data = combo+16;
				else
					Ghost_Data = combo+2;
			}
			else{
				if(i%2==0)
					ghost->DrawYOffset = -1000;
				else
					ghost->DrawYOffset = -2;
			}
			EZB_Waitframe(this, ghost, barrierShift);
		}
		ghost->DrawYOffset = -2;
		Ghost_Data = oldCombo;
		ghost->CollDetection = true;
	}	
	int EZB_AngleDir(ffc this, npc ghost, int barrierShift, int angle){
		int flags = barrierShift[309];
		if(flags&EZBF_8WAY)
			return AngleDir8(angle);
		else
			return AngleDir4(angle);
	}
	float EZB_AngDiff(float angle1, float angle2){
		// Get the difference between the two angles
		float dif = angle2 - angle1;
		
		// Compensate for the difference being outside of normal bounds
		if(dif >= 180)
			dif -= 360;
		else if(dif <= -180)
			dif += 360;
			
		return dif;
	}
	void EZB_FaceLink(ffc this, npc ghost, int barrierShift){
		int flags = barrierShift[309];
		if(flags&EZBF_8WAY)
			Ghost_Dir = AngleDir8(Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()));
		else
			Ghost_Dir = AngleDir4(Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()));
	}
	void EZB_FaceAngle(ffc this, npc ghost, int barrierShift, int angle){
		int flags = barrierShift[309];
		if(flags&EZBF_8WAY)
			Ghost_Dir = AngleDir8(angle);
		else
			Ghost_Dir = AngleDir4(angle);
	}
	bool EZB_CanPlace(ffc this, npc ghost, int X, int Y){
		for(int x=ghost->HitXOffset; x<=ghost->HitXOffset+ghost->HitWidth-1; x=Min(x+8, ghost->HitXOffset+ghost->HitWidth-1)){
			for(int y=ghost->HitYOffset; y<=ghost->HitYOffset+ghost->HitHeight-1; y=Min(y+8, ghost->HitYOffset+ghost->HitHeight-1)){
				if(!Ghost_CanMovePixel(X+x, Y+y))
					return false;
				if(y==ghost->HitYOffset+ghost->HitHeight-1)
					break;
			}
			if(x==ghost->HitXOffset+ghost->HitWidth-1)
				break;
		}
		return true;
	}
	bool EZB_CanPlace(ffc this, npc ghost, int X, int Y, int W, int H){
		for(int x=0; x<=W-1; x=Min(x+8, W-1)){
			for(int y=0; y<=H-1; y=Min(y+8, H-1)){
				if(!Ghost_CanMovePixel(X+x, Y+y))
					return false;
				if(y==H-1)
					break;
			}
			if(x==W-1)
				break;
		}
		return true;
	}
	bool EZB_RotRectCollision(float x1c, float y1c, float height1, float width1, float rot1, float x2c, float y2c, float height2, float width2, float rot2){
		float rad1=Sqrt(height1*height1+width1*width1);
		float rad2=Sqrt(height2*height2+width2*width2);
		float angle1=RadtoDeg(ArcSin(height1/rad1));
		float angle2=RadtoDeg(ArcSin(height2/rad2));
		float x1[4];
		float y1[4];
		float x2[4];
		float y2[4];
		float axisX[4];
		float axisY[4];
		float proj;
		float minProj1;
		float maxProj1;
		float minProj2;
		float maxProj2;
		x1[0]=x1c+rad1*Cos(rot1-angle1);
		y1[0]=y1c+rad1*Sin(rot1-angle1);
		x1[1]=x1c+rad1*Cos(rot1+angle1);
		y1[1]=y1c+rad1*Sin(rot1+angle1);
		x1[2]=x1c+rad1*Cos(rot1+180-angle1);
		y1[2]=y1c+rad1*Sin(rot1+180-angle1);
		x1[3]=x1c+rad1*Cos(rot1+180+angle1);
		y1[3]=y1c+rad1*Sin(rot1+180+angle1);
		x2[0]=x2c+rad2*Cos(rot2-angle2);
		y2[0]=y2c+rad2*Sin(rot2-angle2);
		x2[1]=x2c+rad2*Cos(rot2+angle2);
		y2[1]=y2c+rad2*Sin(rot2+angle2);
		x2[2]=x2c+rad2*Cos(rot2+180-angle2);
		y2[2]=y2c+rad2*Sin(rot2+180-angle2);
		x2[3]=x2c+rad2*Cos(rot2+180+angle2);
		y2[3]=y2c+rad2*Sin(rot2+180+angle2);
		axisX[0]=x1[0]-x1[1];
		axisY[0]=y1[0]-y1[1];
		axisX[1]=x1[2]-x1[1];
		axisY[1]=y1[2]-y1[1];
		axisX[2]=x2[0]-x2[1];
		axisY[2]=y2[0]-y2[1];
		axisX[3]=x2[2]-x2[1];
		axisY[3]=y2[2]-y2[1];
		// if(true){ //Debug draws
			// Screen->Rectangle(5, x1c-width1, y1c-height1, x1c+width1, y1c+height1, 1, -1, x1c, y1c, rot1, true, 128);
			// Screen->Rectangle(5, x2c-width2, y2c-height2, x2c+width2, y2c+height2, 2, -1, x2c, y2c, rot2, true, 128);
		// }
		for(int i=0; i<4; ++i){
			proj=x1[0]*axisX[i]+y1[0]*axisY[i];
			minProj1=proj;
			maxProj1=proj;
			for(int j=1; j<4; ++j){
				proj=x1[j]*axisX[i]+y1[j]*axisY[i];
				if(proj<minProj1)
					minProj1=proj;
				if(proj>maxProj1)
					maxProj1=proj;
			}
			proj=x2[0]*axisX[i]+y2[0]*axisY[i];
			minProj2=proj;
			maxProj2=proj;
			for(int j=1; j<4; ++j){
				proj=x2[j]*axisX[i]+y2[j]*axisY[i];
				if(proj<minProj2)
					minProj2=proj;
				if(proj>maxProj2)
					maxProj2=proj;
			}
			if(maxProj2<minProj1 || maxProj1<minProj2)
				return false;
		}
		return true;
	}
	void EZB_DrawLaser(int layer, int x, int y, int width, int angle, int color){
		if(ScreenFlag(1, 4)&&layer==2) //Layer -2
			layer = 1;
		else if(ScreenFlag(1, 5)&&layer==3) //Layer -3
			layer = 4;
		Screen->Circle(layer, x+width, y, width, color, 1, x, y, angle, true, 128);
		Screen->Rectangle(layer, x+width, y-width, x+width+512, y+width, color, 1, x, y, angle, true, 128);
	}
	void EZB_DrawLaser3Color(int layer, int x, int y, int width, int angle, int color1, int color2, int color3){
		EZB_DrawLaser(layer, x, y, width, angle, color1);
		EZB_DrawLaser(layer, x, y, width/4*3, angle, color2);
		EZB_DrawLaser(layer, x, y, width/2, angle, color3);
	}
	bool EZB_LaserCollision(int x, int y, int width, int angle){
		int hitWidth = Max(1, width-3);
		int cX = x+VectorX(width, angle);
		int cY = y+VectorY(width, angle);
		if(Distance(CenterLinkX(), CenterLinkY(), cX, cY)<width)
			return true;
		return EZB_RotRectCollision(x+VectorX(width+128, angle), y+VectorY(width+128, angle), hitWidth, 128, angle, CenterLinkX(), CenterLinkY(), 4, 4, 0);
	}
	void EZB_Laser3Color(int layer, int x, int y, int width, int angle, int damage, int color1, int color2, int color3){
		if(ScreenFlag(1, 4)&&layer==2) //Layer -2
			layer = 1;
		else if(ScreenFlag(1, 5)&&layer==3) //Layer -3
			layer = 4;
		EZB_DrawLaser3Color(layer, x, y, width, angle, color1, color2, color3);
		if(EZB_LaserCollision(x, y, width, angle)){
			EZB_DamageLink(damage);
		}
	}
	void EZB_Shockwave(int layer, int x, int y, int rad1, int rad2, int rings, int damage, int color1, int color2, int color3){
		if(ScreenFlag(1, 4)&&layer==2) //Layer -2
			layer = 1;
		else if(ScreenFlag(1, 5)&&layer==3) //Layer -3
			layer = 4;
		int clr = Choose(color1, color2, color3);
		for(int i=0; i<rings; ++i){
			if(rad1-i*2>0&&rad1-i*2<rad2){
				Screen->Circle(layer, x, y, rad1-i*2, clr, 1, 0, 0, 0, false, 128);
			}
		}
		int r = Min(rad1, rad2);
		if(Distance(CenterLinkX(), CenterLinkY(), x, y)<r){
			EZB_DamageLink(damage);
		}
	}
	void EZB_DamageLink(int damage){
		eweapon e = FireEWeapon(EW_SCRIPT10, Link->X+InFrontX(Link->Dir, 12), Link->Y+InFrontY(Link->Dir, 12), 0, 0, damage, -1, -1, EWF_UNBLOCKABLE);
		e->Dir = Link->Dir;
		e->DrawYOffset = -1000;
		SetEWeaponLifespan(e, EWL_TIMER, 1);
		SetEWeaponDeathEffect(e, EWD_VANISH, 0);
	}
	void EZB_Explode(ffc this, npc ghost, bool flash){
		int baseX=Ghost_X+ghost->DrawXOffset;
		int baseY=(Ghost_Y+ghost->DrawYOffset)-(Ghost_Z+ghost->DrawZOffset);
		
		__DeathAnimStart(this, ghost);
		__DeathAnimSFX(ghost->ID, ghost->X);
		
		if(flash)
			__Ghost_FlashCounter=10000;
		else
			__Ghost_FlashCounter=0;
		
		// One explosion every 16 frames, 15 times
		for(int i=0; i<15; ++i)
		{
			EZB_CreateDeathExplosion(baseX+Rand(16*Ghost_TileWidth)-8, baseY+Rand(16*Ghost_TileHeight)-8);
			
			for(int j=0; j<16; ++j)
			{
				Ghost_SetPosition(this, ghost); // Make sure it doesn't wander off
				if(flash)
					__Ghost_UpdateFlashing(this, ghost);
				Ghost_WaitframeLight(this, ghost);
			}
		}
		
		__DeathAnimEnd(this, ghost);
	}
	void EZB_CreateDeathExplosion(int x, int y){
		Game->PlaySound(SFX_BOMB);
		
		lweapon explosion=Screen->CreateLWeapon(LW_EZB_DEATHEXPLOSION);
		explosion->X = x-(WIDTH_EZB_DEATHEXPLOSION-1)*8;
		explosion->Y = y-(HEIGHT_EZB_DEATHEXPLOSION-1)*8;
		
		explosion->Extend = 3;
		explosion->TileWidth = WIDTH_EZB_DEATHEXPLOSION;
		explosion->TileHeight = HEIGHT_EZB_DEATHEXPLOSION;
		
		explosion->UseSprite(SPR_EZB_DEATHEXPLOSION);
		explosion->CollDetection = false;
		explosion->DeadState = explosion->NumFrames*explosion->ASpeed;
	}
	void EZB_Barriershift_Store(npc ghost, int newForm, int barrierShift){
		int i;
		
		npc n = CreateNPCAt(newForm, 128, -1000);
		
		barrierShift[000] = Ghost_CSet;
		barrierShift[001] = ghost->Damage;
		barrierShift[002] = ghost->WeaponDamage;
		barrierShift[003] = ghost->Hunger;
		barrierShift[004] = ghost->Rate;
		barrierShift[005] = ghost->Haltrate;
		barrierShift[006] = ghost->Homing;
		barrierShift[007] = ghost->Step;
		barrierShift[008] = ghost->Weapon;
		barrierShift[009] = ghost->ItemSet;
		barrierShift[010] = ghost->SFX;
		for(i=0; i<11; ++i){
			barrierShift[011+i] = ghost->Attributes[i];
		}
		for(i=0; i<18; ++i){
			barrierShift[022+i] = ghost->Defense[i];
		}
		
		barrierShift[100] = n->CSet;
		barrierShift[101] = n->Damage;
		barrierShift[102] = n->WeaponDamage;
		barrierShift[103] = n->Hunger;
		barrierShift[104] = n->Rate;
		barrierShift[105] = n->Haltrate;
		barrierShift[106] = n->Homing;
		barrierShift[107] = n->Step;
		barrierShift[108] = n->Weapon;
		barrierShift[109] = n->ItemSet;
		barrierShift[110] = n->SFX;
		for(i=0; i<11; ++i){
			barrierShift[111+i] = n->Attributes[i];
		}
		for(i=0; i<18; ++i){
			barrierShift[122+i] = n->Defense[i];
		}
		
		barrierShift[200] = 1;
		barrierShift[201] = 0;
		
		n->HP = -1000;
		n->DrawXOffset = -1000;
		n->DrawYOffset = -1000;
		n->ItemSet = 0;
		n->CollDetection = false;
		
		//Flag the enemy as already used by ghost.zh so it doesn't run a script
		n->Misc[__GHI_NPC_DATA] = 0x10000;
	}
	void EZB_Barriershift_Load(npc ghost, int barrierShift, bool onlyDefenses){
		int i;
		int startIndex = 0;
		if(barrierShift[201]==0)
			startIndex = 100;
		
		Ghost_CSet = barrierShift[startIndex+000];
		if(!onlyDefenses){
			ghost->Damage = barrierShift[startIndex+001];
			ghost->WeaponDamage = barrierShift[startIndex+002];
			ghost->Hunger = barrierShift[startIndex+003];
			ghost->Rate = barrierShift[startIndex+004];
			ghost->Haltrate = barrierShift[startIndex+005];
			ghost->Homing = barrierShift[startIndex+006];
			ghost->Step = barrierShift[startIndex+007];
			ghost->Weapon = barrierShift[startIndex+008];
			ghost->ItemSet = barrierShift[startIndex+009];
			ghost->SFX = barrierShift[startIndex+010];
			
			for(i=0; i<11; ++i){
				barrierShift[300+i] = barrierShift[startIndex+011+i];
			}
		}
		
		for(i=0; i<18; ++i){
			ghost->Defense[i] = barrierShift[startIndex+022+i];
		}
	
		if(barrierShift[201]==0)
			barrierShift[201] = 1;
		else
			barrierShift[201] = 0;
	}
	int EZB_NumSummons(npc summons){
		int count;
		for(int i=0; i<256; ++i){
			if(summons[i]->isValid()){
				count++;
			}
		}
		return count;
	}
	void EZB_AddSummon(npc n, npc summons){
		for(int i=0; i<256; ++i){
			if(!summons[i]->isValid()){
				summons[i] = n;
				return;
			}
		}
	}
	void EZB_Waitframes(ffc this, npc ghost, int barrierShift, int frames){
		for(int i=0; i<frames; ++i){
			EZB_Waitframe(this, ghost, barrierShift);
		}
	}
	void EZB_Waitframe(ffc this, npc ghost, int barrierShift){
		int flags = barrierShift[309];
		if(flags&EZBF_NOCOLL){
			ghost->Stun = 60;
		}
		if(flags&EZBF_NOSTUN){
			ghost->Stun = 0;
		}
		
		if(flags&EZBF_EXPLODEEATH){
			if(SPR_EZB_DEATHEXPLOSION>0){
				if(!Ghost_Waitframe(this, ghost, false, false)){
					EZB_Explode(this, ghost, EZB_DEATH_FLASH);
					Quit();
				}
			}
			else
				Ghost_Waitframe(this, ghost, 1, true);
		}
		else
			Ghost_Waitframe(this, ghost);
	}
}

const int SHUTTER_INVISIBLE_COMBO = 1; //Set this to a combo that when placed on a 4x4 FFC will be invisible.

const int CMB_BOMBWALL_MARKER = 0; //Combo used for the hint marker when using the lens on a bomb wall
const int CS_BOMBWALL_MARKER = 7; //CSet of the hint marker

const int D_LTTPDOORS = 6; //Screen->D[] (0-7) index used for directional doors
const int D_LTTPDOORID = 7; //Screen->D[] (0-7) index used for ID'd doors

const int SHUTTER_USE_FFC_CSET = 0; //If 1, will set shutters to the FFC's CSet. Else keep the CSets below the FFC.

const int SHUTTER_OPEN_FRAMES = 6; //How long in frames (60ths of a second) an animated shutter takes to open
const int SHUTTER_LOCK_OPEN_FRAMES = 12; //How long in frames (60ths of a second) an animated locked door takes to open
const int SHUTTER_BOSS_LOCK_OPEN_FRAMES = 12; //How long in frames (60ths of a second) an animated boss lock door takes to open

const int SHUTTER_REPEAT_DELAY_FRAMES = 12; //Delay between a shutter closing and opening
const int SHUTTER_LOCK_ACTIVATION_FRAMES = 12; //Delay when pushing against a locked door before it opens

const int SFX_SHUTTER_OPEN = 9; //SFX of a shutter opening
const int SFX_SHUTTER_CLOSE = 9; //SFX of a shutter closing
const int SFX_LOCK_OPEN = 9; //SFX of a lock opening
const int SFX_BOSS_LOCK_OPEN = 9; //SFX of a boss lock opening
const int SFX_BOMB_WALL_OPEN = 0; //SFX of a bomb wall being blasted open

const int LENS_MP_COST = 1; //The MP cost of the lens item

//If you have different/more lens items in your quest, this function will need to be changed
bool UsingLens(){
	if(Link->MP<LENS_MP_COST)
		return false;
	if(GetEquipmentA()==I_LENS&&Link->InputA)
		return true;
	if(GetEquipmentB()==I_LENS&&Link->InputB)
		return true;
	return false;
}

bool BombWall_HoldingItemButton(int id){
	if(GetEquipmentA()==id&&Link->InputA)
		return true;
	if(GetEquipmentB()==id&&Link->InputB)
		return true;
	return false;
}

//LttP Shutter
//D0: Direction to the wall the shutter is on - 0: Up, 1: Down, 2: Left, 3: Right
//D1: Trigger type for the shutter
//		0: One way
//		1: Kill enemies
//		2: Push block
//		3: Combo change
//		4: Perm secret
//D2: Combo position of the trigger combo for a combo change (3) shutter
//D6: If using an opening animation, this is the first of the combo groups, starting with a closed door.
//	  Opening combo groups should be arranged vertically and be made up of doors the same size as the FFC.
//D7: If using an opening animation, this is the number of frames in the animation.

ffc script LttP_Shutter{
	void run(int dir, int openTrigger, int triggerPos, int d3, int d4, int layer, int openingCmb, int openingFrames){
		int comboPos = ComboAt(this->X+8, this->Y+8);
		
		int closedCmb = this->Data;
		int openCmb = this->Data+4*this->TileHeight;
		this->Data = SHUTTER_INVISIBLE_COMBO;
		
		//Uncheck flags that make the FFC invisible during scrolling
		this->Flags[FFCF_LENSVIS] = false;
		this->Flags[FFCF_CHANGER] = false;
		
		int triggerCD = Screen->ComboD[triggerPos];
		int triggerCC = Screen->ComboC[triggerPos];
		int triggerCF = Screen->ComboF[triggerPos];
		
		//Set opening combo relative to the open and closed states if not set
		if(openingCmb==0&&openingFrames>0){
			openingCmb = closedCmb+2*(4*this->TileHeight);
		}
		
		int linkX = Link->X;
		int linkY = Link->Y;
		//If the script is running while the screen is scrolling, Link's position will be flipped.
		if(this->Flags[FFCF_PRELOAD]){
			if(dir==DIR_UP||dir==DIR_DOWN){
				if(linkY<=0)
					linkY = 160;
				else if(linkY>=160)
					linkY = 0;
			}
			else{
				if(linkX<=0)
					linkX = 240;
				else if(linkX>=240)
					linkX = 0;
			}
		}
		
		// >using variables as labels
		// shiggydiggy
		int SHUTTER_STATE = 0; //0 = Closed, 1 = Opening, 2 = Open, 3 = Closing
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		int shutter[16] = {0, 0, openCmb, closedCmb, comboPos};
		
		if(openTrigger==4&&Screen->State[ST_SECRET]){ //Doors triggered by secret state don't need to run if it's already set
			Shutter_SetCombos(this, layer, comboPos, openCmb);
			Quit();
		}
			
		int shutterCooldown;
		
		//If Link entered from this shutter, push him out and close it
		if(Shutter_LinkCollide(this, dir, linkX, linkY, false)){
			shutterCooldown = SHUTTER_REPEAT_DELAY_FRAMES;
			shutter[SHUTTER_STATE] = 2; //Open
			Shutter_SetCombos(this, layer, comboPos, openCmb);
			Waitframe();
			if ( G[G_Timestop] == 1 )
				Quit();
			while(Link->Action==LA_SCROLLING||Shutter_LinkCollide(this, dir, Link->X, Link->Y, true)){
				if(Link->Action!=LA_SCROLLING)
					Shutter_MoveLink(dir);
				Waitframe();
			}
			Shutter_EjectLink(this, dir);
			Shutter_Close(this, layer, shutter, openingFrames);
		}
		else{
			if(this->Flags[FFCF_PRELOAD]){
				Shutter_SetCombos(this, layer, comboPos, closedCmb);
				//Wait for screen to finish scrolling so Link doesn't get teleported during the animation
				Waitframe();
				while(Link->Action==LA_SCROLLING){
					Waitframe();
				}
			}
			else
				Shutter_Close(this, layer, shutter, openingFrames);
		}
		
		bool open = false;
		bool wasBlock = false;
		bool blockPuzzle = false;
		if(Shutter_CountBlockTriggers()>0)
			blockPuzzle = true;
			
		int enemyCooldown = 12;
		
		while(true){
			if(openTrigger==1){ //Enemies
				if(enemyCooldown>0)
					enemyCooldown--;
				else{
					if(Shutter_CountNPCs()==0)
						open = true;
				}
			}
			else if(openTrigger==2){ //Block
				if(blockPuzzle){ //Block puzzle secrets should override screens that just have blocks
					if(Shutter_CountBlockTriggers()==0)
						open = true;
				}
				else{
					if(Screen->MovingBlockX>-1||Screen->MovingBlockY>-1)
						wasBlock = true;
					else if(wasBlock)
						open = true;
				}
			}
			else if(openTrigger==3){ //Combo change
				if(triggerCD!=Screen->ComboD[triggerPos]||triggerCC!=Screen->ComboC[triggerPos]||triggerCF!=Screen->ComboF[triggerPos]){
					open = true;
				}
				else{
					if(!Shutter_LinkCollide(this, dir, Link->X, Link->Y, true))
						open = false;
				}
			}
			else if(openTrigger==4){ //Perm secret
				if(Screen->State[ST_SECRET])
					open = true;
			}
			
			if(shutter[SHUTTER_STATE]==0&&Shutter_LinkCollide(this, dir, Link->X, Link->Y, false))
				Shutter_EjectLink(this, dir);
			
			if(shutterCooldown>0)
				shutterCooldown--;
			//Open and close the shutter if it should be closed/open but isn't
			if(open&&shutter[SHUTTER_STATE]==0){
				Shutter_Open(this, layer, shutter, openingFrames);
			}
			else if(!open&&shutter[SHUTTER_STATE]==2){
				Shutter_Close(this, layer, shutter, openingFrames);
				shutterCooldown = SHUTTER_REPEAT_DELAY_FRAMES;
			}
				
			Shutter_Update(this, layer, shutter, openingCmb, openingFrames);
			Waitframe();
		}
	}
	bool Shutter_Update(ffc this, int layer, int shutter, int openingCmb, int openingFrames){
		int SHUTTER_STATE = 0;
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		int curFrame;
		if(shutter[SHUTTER_STATE]==1){ //Opening
			if(shutter[SHUTTER_FRAMES]>0){
				shutter[SHUTTER_FRAMES]--;
				curFrame = Clamp(Floor((SHUTTER_OPEN_FRAMES-shutter[SHUTTER_FRAMES])/(SHUTTER_OPEN_FRAMES/openingFrames)), 0, openingFrames-1);
				Shutter_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], openingCmb+curFrame*(4*this->TileHeight));
			}
			else{
				Shutter_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], shutter[SHUTTER_OPENCMB]);
				shutter[SHUTTER_STATE] = 2; //Open
			}
		}
		else if(shutter[SHUTTER_STATE]==3){ //Closing
			if(shutter[SHUTTER_FRAMES]>0){
				shutter[SHUTTER_FRAMES]--;
				curFrame = Clamp(Floor(shutter[SHUTTER_FRAMES]/(SHUTTER_OPEN_FRAMES/openingFrames)), 0, openingFrames-1);
				Shutter_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], openingCmb+curFrame*(4*this->TileHeight));
			}
			else{
				Shutter_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], shutter[SHUTTER_CLOSEDCMB]);
				shutter[SHUTTER_STATE] = 0; //Closed
			}
		}
	}
	void Shutter_Open(ffc this, int layer, int shutter, int openingFrames){
		int SHUTTER_STATE = 0;
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		Game->PlaySound(SFX_SHUTTER_OPEN);
		if(openingFrames==0){
			Shutter_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], shutter[SHUTTER_OPENCMB]);
			shutter[SHUTTER_STATE] = 2; //Open
		}
		else{
			shutter[SHUTTER_STATE] = 1; //Opening
			shutter[SHUTTER_FRAMES] = SHUTTER_OPEN_FRAMES;
		}
	}
	void Shutter_Close(ffc this, int layer, int shutter, int openingFrames){
		int SHUTTER_STATE = 0;
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		Game->PlaySound(SFX_SHUTTER_CLOSE);
		if(openingFrames==0){
			Shutter_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], shutter[SHUTTER_CLOSEDCMB]);
			shutter[SHUTTER_STATE] = 0; //Closed
		}
		else{
			shutter[SHUTTER_STATE] = 3; //Closing
			shutter[SHUTTER_FRAMES] = SHUTTER_OPEN_FRAMES;
		}
	}
	bool Shutter_SetCombos(ffc this, int layer, int comboPos, int cmb){
		int w = this->TileWidth;
		int h = this->TileHeight;
		for(int x=0; x<w; x++){
			for(int y=0; y<h; y++){
				SetLayerComboD(layer, comboPos+x+y*16, cmb+x+y*4);
				if(SHUTTER_USE_FFC_CSET)
					__SetLayerComboC(layer, comboPos+x+y*16, this->CSet);
				//Screen->ComboD[comboPos+x+y*16] = cmb+x+y*4;
			}
		}
	}
	bool Shutter_LinkCollide(ffc this, int dir, int linkX, int linkY, bool fullTile){
		if(Link->Action==LA_SCROLLING||Link->X<0||Link->X>240||Link->Y<0||Link->Y>160)
			return false;
		int w = this->TileWidth;
		int h = this->TileHeight;
		int offset = 0;
		if(fullTile) 
			offset = 16;
		if(dir==DIR_UP){
			return (linkX>=this->X-16 && linkX<=this->X+w*16 && linkY <= Max(this->Y+h*16-16+offset-8, 0));
		}
		else if(dir==DIR_DOWN){
			return (linkX>=this->X-16 && linkX<=this->X+w*16 && linkY >= this->Y-offset);
		}
		else if(dir==DIR_LEFT){
			return (linkY>=this->Y-16 && linkY<=this->Y+h*16 && linkX <= this->X+w*16-16+offset);
		}
		else if(dir==DIR_RIGHT){
			return (linkY>=this->Y-16 && linkY<=this->Y+h*16 && linkX >= this->X-offset);
		}
	}
	bool Shutter_MoveLink(int dir){
		NoAction();
		if(dir==DIR_UP){
			Link->InputDown = true;
			if(!CanWalk(Link->X, Link->Y, DIR_DOWN, 1, false))
				Link->Y++;
		}
		else if(dir==DIR_DOWN){
			Link->InputUp = true;
			if(!CanWalk(Link->X, Link->Y, DIR_UP, 1, false))
				Link->Y--;
		}
		else if(dir==DIR_LEFT){
			Link->InputRight = true;
			if(!CanWalk(Link->X, Link->Y, DIR_RIGHT, 1, false))
				Link->X++;
		}
		else if(dir==DIR_RIGHT){
			Link->InputLeft = true;
			if(!CanWalk(Link->X, Link->Y, DIR_LEFT, 1, false))
				Link->X--;
		}
	}
	bool Shutter_EjectLink(ffc this, int dir){
		if(dir==DIR_UP)
			Link->Y = this->Y+this->TileHeight*16-8;
		else if(dir==DIR_DOWN)
			Link->Y = this->Y-16;
		else if(dir==DIR_LEFT)
			Link->X = this->X+this->TileWidth*16;
		else if(dir==DIR_RIGHT)
			Link->X = this->X-16;
	}
	int Shutter_CountNPCs(){
		int count;
		for(int i=Screen->NumNPCs(); i>=1; i--){
			npc n = Screen->LoadNPC(i);
			if(n->MiscFlags&(1<<3)) //Doesn't count as a beatable enemy flag
				continue;
			if(n->Type==NPCT_GUY||n->Type==NPCT_TRAP||n->Type==NPCT_PROJECTILE||n->Type==NPCT_FAIRY||n->Type==NPCT_NONE)
				continue;
			if(n->Type==NPCT_ZORA) //Borderline if this should be a skippable enemy. I believe most ZC behaviors skip it, so I've put it here
				continue;
			count++;
		}
		return count;
	}
	int Shutter_CountBlockTriggers(){
		int count;
		for(int i=0; i<176; ++i){
			if(ComboFI(i, CF_BLOCKTRIGGER))
				count++;
		}
		return count;
	}
	//A shorthand way to set a combo on the current layer.
	//Layer 0 is the screen itself.
	void __SetLayerComboC(int layer, int pos, int cset) {
	  if (layer == 0)
		Screen->ComboC[pos] = cset;
	  else
		Game->SetComboCSet(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, cset);
	}
}

//LttP Locked Door
//D0: Direction to the wall the door is on - 0: Up, 1: Down, 2: Left, 3: Right
//D1: Special ID of the door (0 for none, 1-16). Be sure to match it with the door on the other side so both open properly.
//D6: If using an opening animation, this is the first of the combo groups, starting with a closed door.
//	  Opening combo groups should be arranged vertically and be made up of doors the same size as the FFC.
//D7: If using an opening animation, this is the number of frames in the animation.
ffc script LttP_LockedDoor{
	void run(int dir, int id, int d2, int d3, int d4, int layer, int openingCmb, int openingFrames){
		int comboPos = ComboAt(this->X+8, this->Y+8);
		
		int closedCmb = this->Data;
		int openCmb = this->Data+4*this->TileHeight;
		this->Data = SHUTTER_INVISIBLE_COMBO;
		
		//Uncheck flags that make the FFC invisible during scrolling
		this->Flags[FFCF_LENSVIS] = false;
		this->Flags[FFCF_CHANGER] = false;
		
		//Set opening combo relative to the open and closed states if not set
		if(openingCmb==0&&openingFrames>0){
			openingCmb = closedCmb+2*(4*this->TileHeight);
		}
		
		// >using variables as labels
		// shiggydiggy
		int SHUTTER_STATE = 0; //0 = Closed, 1 = Opening, 2 = Open, 3 = Closing
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		int shutter[16] = {0, 0, openCmb, closedCmb, comboPos};
		
		//If screen D bit is set, open the door
		if(LockedDoor_CheckD(dir, id)){
			if(this->Flags[FFCF_PRELOAD]){
				LockedDoor_SetCombos(this, layer, comboPos, openCmb);
				Quit();
			}
			else{
				LockedDoor_Open(this, layer, shutter, openingFrames);
			}
		}
		else{
			LockedDoor_SetCombos(this, layer, comboPos, closedCmb);
		}
		
		int lockCount = SHUTTER_LOCK_ACTIVATION_FRAMES;
		while(true){
			if(shutter[SHUTTER_STATE]==0){ //Closed
				if(LockedDoor_DetectOpen(this, dir)){
					if(lockCount>0)
						lockCount--;
					else if(LockedDoor_HasKey()){
						LockedDoor_Open(this, layer, shutter, openingFrames);
						LockedDoor_SetD(dir, id);
						LockedDoor_TakeKey();
					}
				}
				else
					lockCount = SHUTTER_LOCK_ACTIVATION_FRAMES;
			}
			LockedDoor_Update(this, layer, shutter, openingCmb, openingFrames);
			Waitframe();
		}
	}
	bool LockedDoor_Update(ffc this, int layer, int shutter, int openingCmb, int openingFrames){
		int SHUTTER_STATE = 0;
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		int curFrame;
		if(shutter[SHUTTER_STATE]==1){ //Opening
			if(shutter[SHUTTER_FRAMES]>0){
				shutter[SHUTTER_FRAMES]--;
				curFrame = Clamp(Floor((SHUTTER_LOCK_OPEN_FRAMES-shutter[SHUTTER_FRAMES])/(SHUTTER_LOCK_OPEN_FRAMES/openingFrames)), 0, openingFrames-1);
				LockedDoor_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], openingCmb+curFrame*(4*this->TileHeight));
			}
			else{
				LockedDoor_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], shutter[SHUTTER_OPENCMB]);
				shutter[SHUTTER_STATE] = 2; //Open
			}
		}
	}
	void LockedDoor_Open(ffc this, int layer, int shutter, int openingFrames){
		int SHUTTER_STATE = 0;
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		Game->PlaySound(SFX_LOCK_OPEN);
		if(openingFrames==0){
			LockedDoor_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], shutter[SHUTTER_OPENCMB]);
			shutter[SHUTTER_STATE] = 2; //Open
		}
		else{
			shutter[SHUTTER_STATE] = 1; //Opening
			shutter[SHUTTER_FRAMES] = SHUTTER_OPEN_FRAMES;
		}
	}
	bool LockedDoor_SetCombos(ffc this, int layer, int comboPos, int cmb){
		int w = this->TileWidth;
		int h = this->TileHeight;
		for(int x=0; x<w; x++){
			for(int y=0; y<h; y++){
				SetLayerComboD(layer, comboPos+x+y*16, cmb+x+y*4);
				if(SHUTTER_USE_FFC_CSET)
					__SetLayerComboC(layer, comboPos+x+y*16, this->CSet);
				//Screen->ComboD[comboPos+x+y*16] = cmb+x+y*4;
			}
		}
	}
	bool LockedDoor_DetectOpen(ffc this, int dir){
		int hitboxX;
		int hitboxY;
		if(dir==DIR_UP){
			hitboxX = this->X+this->TileWidth*8-8;
			hitboxY = this->Y+this->TileHeight*16-16;
		}
		else if(dir==DIR_DOWN){
			hitboxX = this->X+this->TileWidth*8-8;
			hitboxY = this->Y;
		}
		else if(dir==DIR_LEFT){
			hitboxX = this->X+this->TileWidth*16-16;
			hitboxY = this->Y+this->TileHeight*8-8;
		}
		else if(dir==DIR_RIGHT){
			hitboxX = this->X;
			hitboxY = this->Y+this->TileHeight*8-8;
		}
		
		if(Link->X>=hitboxX-8&&Link->X<=hitboxX+8&&Link->Y>=hitboxY-16&&Link->Y<=hitboxY&&Link->InputDown&&Link->Dir==DIR_DOWN&&dir<2)
			return true;
		if(Link->X>=hitboxX-8&&Link->X<=hitboxX+8&&Link->Y>=hitboxY&&Link->Y<=hitboxY+8&&Link->InputUp&&Link->Dir==DIR_UP&&dir<2)
			return true;
		if(Link->X>=hitboxX-16&&Link->X<=hitboxX&&Link->Y>=hitboxY-8&&Link->Y<=hitboxY+8&&Link->InputRight&&Link->Dir==DIR_RIGHT&&dir>=2)
			return true;
		if(Link->X>=hitboxX&&Link->X<=hitboxX+16&&Link->Y>=hitboxY-8&&Link->Y<=hitboxY+8&&Link->InputLeft&&Link->Dir==DIR_LEFT&&dir>=2)
			return true;
		return false;
	}
	bool LockedDoor_CheckD(int dir, int id){
		if(id>0)
			return Screen->D[D_LTTPDOORID]&(1<<(Clamp(id-1, 0, 15)));
		else
			return Screen->D[D_LTTPDOORS]&(1<<Clamp(dir, 0, 3));
	}
	void LockedDoor_SetD(int dir, int id){
		int offset;
		if(dir==DIR_UP)
			offset = -16;
		else if(dir==DIR_DOWN)
			offset = 16;
		else if(dir==DIR_LEFT)
			offset = -1;
		else
			offset = 1;
		int nextD;
		if(id>0){
			Screen->D[D_LTTPDOORID] |= (1<<(Clamp(id-1, 0, 15)));
			nextD = Game->GetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORID);
			Game->SetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORID, nextD|(1<<(Clamp(id-1, 0, 15))));
		}
		else{
			Screen->D[D_LTTPDOORS] |= (1<<Clamp(dir, 0, 3));
			nextD = Game->GetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORS);
			Game->SetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORS, nextD|(1<<Clamp(OppositeDir(dir), 0, 3)));
		}
	}
	bool LockedDoor_HasKey(){
		if(Link->Item[I_MAGICKEY])
			return true;
		if(Game->Counter[CR_KEYS]>0)
			return true;
		if(Game->LKeys[Game->GetCurLevel()]>0)
			return true;
		return false;
	}
	void LockedDoor_TakeKey(){
		if(Link->Item[I_MAGICKEY])
			return;
		if(Game->LKeys[Game->GetCurLevel()]>0)
			Game->LKeys[Game->GetCurLevel()]--;
		else if(Game->Counter[CR_KEYS]>0)
			Game->Counter[CR_KEYS]--;
	}
	//A shorthand way to set a combo on the current layer.
	//Layer 0 is the screen itself.
	void __SetLayerComboC(int layer, int pos, int cset) {
	  if (layer == 0)
		Screen->ComboC[pos] = cset;
	  else
		Game->SetComboCSet(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, cset);
	}
}

//LttP Bomb Wall
//D0: Direction to the wall the door is on - 0: Up, 1: Down, 2: Left, 3: Right
//D1: Special ID of the door (0 for none, 1-16). Be sure to match it with the door on the other side so both open properly.
ffc script LttP_BombWall{
	void run(int dir, int id, int d2, int d3, int d4, int layer, int d6, int d7){
		int comboPos = ComboAt(this->X+8, this->Y+8);
		
		int openCmb = this->Data;
		int rubbleCmb = this->Data+4*this->TileHeight;
		this->Data = SHUTTER_INVISIBLE_COMBO;
		
		//Uncheck flags that make the FFC invisible during scrolling
		this->Flags[FFCF_LENSVIS] = false;
		this->Flags[FFCF_CHANGER] = false;
		
		//If screen D bit is set, open the door
		if(BombWall_CheckD(dir, id)){
			BombWall_SetCombos(this, layer, comboPos, openCmb);
			BombWall_SetRubble(this, dir, rubbleCmb);
			Quit();
		}
		
		while(true){
			//Draw a hint graphic when using the lens
			if(UsingLens()){
				int x;
				int y;
				if(dir==DIR_UP){
					x = this->X+this->TileWidth*8-8;
					y = this->Y+this->TileHeight*16-16;
				}
				else if(dir==DIR_DOWN){
					x = this->X+this->TileWidth*8-8;
					y = this->Y;
				}
				else if(dir==DIR_LEFT){
					x = this->X+this->TileWidth*16-16;
					y = this->Y+this->TileHeight*8-8;
				}
				else if(dir==DIR_RIGHT){
					x = this->X;
					y = this->Y+this->TileHeight*8-8;
				}
				
				if(CMB_BOMBWALL_MARKER>0)
					Screen->FastCombo(6, x, y, CMB_BOMBWALL_MARKER, CS_BOMBWALL_MARKER, 128);
			}
			
			if(BombWall_DetectOpen(this, dir)){
				BombWall_SetCombos(this, layer, comboPos, openCmb);
				BombWall_SetRubble(this, dir, rubbleCmb);
				BombWall_SetD(dir, id);
				Game->PlaySound(SFX_BOMB_WALL_OPEN);
				Quit();
			}
			
			Waitframe();
		}
	}
	bool BombWall_SetCombos(ffc this, int layer, int comboPos, int cmb){
		int w = this->TileWidth;
		int h = this->TileHeight;
		for(int x=0; x<w; x++){
			for(int y=0; y<h; y++){
				SetLayerComboD(layer, comboPos+x+y*16, cmb+x+y*4);
				if(SHUTTER_USE_FFC_CSET)
					__SetLayerComboC(layer, comboPos+x+y*16, this->CSet);
				//Screen->ComboD[comboPos+x+y*16] = cmb+x+y*4;
			}
		}
	}
	void BombWall_SetRubble(ffc this, int dir, int cmb){
		int rubbleX;
		int rubbleY;
		
		if(dir==DIR_UP){
			rubbleX = this->X+this->TileWidth*8-8;
			rubbleY = this->Y+this->TileHeight*16;
		}
		else if(dir==DIR_DOWN){
			rubbleX = this->X+this->TileWidth*8-8;
			rubbleY = this->Y-16;
		}
		else if(dir==DIR_LEFT){
			rubbleX = this->X+this->TileWidth*16;
			rubbleY = this->Y+this->TileHeight*8-8;
		}
		else if(dir==DIR_RIGHT){
			rubbleX = this->X-16;
			rubbleY = this->Y+this->TileHeight*8-8;
		}
		
		this->Data = cmb;
		this->X = rubbleX;
		this->Y = rubbleY;
		this->TileWidth = 1;
		this->TileHeight = 1;
	}
	bool BombWall_DetectOpen(ffc this, int dir){
		int hitboxX;
		int hitboxY;
		if(dir==DIR_UP){
			hitboxX = this->X+this->TileWidth*8-8;
			hitboxY = this->Y+this->TileHeight*16-16;
		}
		else if(dir==DIR_DOWN){
			hitboxX = this->X+this->TileWidth*8-8;
			hitboxY = this->Y;
		}
		else if(dir==DIR_LEFT){
			hitboxX = this->X+this->TileWidth*16-16;
			hitboxY = this->Y+this->TileHeight*8-8;
		}
		else if(dir==DIR_RIGHT){
			hitboxX = this->X;
			hitboxY = this->Y+this->TileHeight*8-8;
		}
		
		for(int i=Screen->NumLWeapons(); i>=1; i--){
			lweapon l = Screen->LoadLWeapon(i);
			if( l->ID == LW_SCRIPT1 ){
				if( l->Misc[0] == LWType_RealBlast ){
					if(RectCollision(l->X+l->HitXOffset, l->Y+l->HitYOffset, l->X+l->HitXOffset+l->HitWidth-1, l->Y+l->HitYOffset+l->HitHeight-1, hitboxX, hitboxY, hitboxX+15, hitboxY+15)){
						return true;
					}
				}
			}
		}
		return false;
	}
	bool BombWall_CheckD(int dir, int id){
		if(id>0)
			return Screen->D[D_LTTPDOORID]&(1<<(Clamp(id-1, 0, 15)));
		else
			return Screen->D[D_LTTPDOORS]&(1<<(8+Clamp(dir, 0, 3)));
	}
	void BombWall_SetD(int dir, int id){
		int offset;
		if(dir==DIR_UP)
			offset = -16;
		else if(dir==DIR_DOWN)
			offset = 16;
		else if(dir==DIR_LEFT)
			offset = -1;
		else
			offset = 1;
		int nextD;
		if(id>0){
			Screen->D[D_LTTPDOORID] |= (1<<(Clamp(id-1, 0, 15)));
			nextD = Game->GetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORID);
			Game->SetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORID, nextD|(1<<(Clamp(id-1, 0, 15))));
		}
		else{
			Screen->D[D_LTTPDOORS] |= (1<<(8+Clamp(dir, 0, 3)));
			nextD = Game->GetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORS);
			Game->SetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORS, nextD|(1<<(8+Clamp(OppositeDir(dir), 0, 3))));
		}
	}
	//A shorthand way to set a combo on the current layer.
	//Layer 0 is the screen itself.
	void __SetLayerComboC(int layer, int pos, int cset) {
	  if (layer == 0)
		Screen->ComboC[pos] = cset;
	  else
		Game->SetComboCSet(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, cset);
	}
}

const int MAX_PUSH = 4;

int LinkMovement[16];
const int LM_PUSHX1A = 0;
const int LM_PUSHY1A = 1;
const int LM_PUSHX1B = 2;
const int LM_PUSHY1B = 3;
const int LM_PUSHX2A = 4;
const int LM_PUSHY2A = 5;
const int LM_PUSHX2B = 6;
const int LM_PUSHY2B = 7;
const int LM_STICKX = 8;
const int LM_STICKY = 9;
const int LM_MOVEBOOST = 10;

void LinkMovement_UpdateInput(){
	if(LinkMovement[LM_STICKY]==0){ //If no Y axis pressed
		if(Link->InputUp&&Link->InputDown) //Default to up when buttons pressed simultaneously
			LinkMovement[LM_STICKY] = -1;
		else if(Link->InputUp) //Set axis based on which button what pressed
			LinkMovement[LM_STICKY] = -1;
		else if(Link->InputDown)
			LinkMovement[LM_STICKY] = 1;
	}
	else{ //If Y axis pressed
		if(!Link->InputUp&&!Link->InputDown) //Release Y axis if neither button pressed
			LinkMovement[LM_STICKY] = 0;
		else if(LinkMovement[LM_STICKY]==-1&&!Link->InputUp) //Reverse Y axis if opposite direction held and button released
			LinkMovement[LM_STICKY] = 1;
		else if(LinkMovement[LM_STICKY]==1&&!Link->InputDown)
			LinkMovement[LM_STICKY] = -1;
	}
	
	if(LinkMovement[LM_STICKX]==0){ //If no X axis pressed
		if(Link->InputLeft&&Link->InputRight) //Default to left when buttons pressed simultaneously
			LinkMovement[LM_STICKX] = -1;
		else if(Link->InputLeft) //Set axis based on which button what pressed
			LinkMovement[LM_STICKX] = -1;
		else if(Link->InputRight)
			LinkMovement[LM_STICKX] = 1;
	}
	else{ //If Y axis pressed
		if(!Link->InputLeft&&!Link->InputRight) //Release Y axis if neither button pressed
			LinkMovement[LM_STICKX] = 0;
		else if(LinkMovement[LM_STICKX]==-1&&!Link->InputLeft) //Reverse Y axis if opposite direction held and button released
			LinkMovement[LM_STICKX] = 1;
		else if(LinkMovement[LM_STICKX]==1&&!Link->InputRight)
			LinkMovement[LM_STICKX] = -1;
	}
}

//Function adds extra movement to Link's step speed
void LinkMovement_SpeedChange(){
	if(Link->Action==LA_WALKING){
		if(LinkMovement[LM_STICKX]!=0||LinkMovement[LM_STICKY]!=0){
			float movementSpeed = LinkMovement[LM_MOVEBOOST];
			if((LinkMovement[LM_STICKX]<0&&LinkMovement[LM_STICKY]<0) || //Up-left
				(LinkMovement[LM_STICKX]>0&&LinkMovement[LM_STICKY]<0) || //Up-right
				(LinkMovement[LM_STICKX]<0&&LinkMovement[LM_STICKY]>0) || //Down-left
				(LinkMovement[LM_STICKX]>0&&LinkMovement[LM_STICKY]>0)) //Down-right
					movementSpeed = movementSpeed*0.7071; //Reduce movement speed at a diagonal
			
			if(LinkMovement[LM_STICKX]<0)
				LinkMovement[LM_PUSHX2A] -= movementSpeed;
			else if(LinkMovement[LM_STICKX]>0)
				LinkMovement[LM_PUSHX2A] += movementSpeed;
			if(LinkMovement[LM_STICKY]<0)
				LinkMovement[LM_PUSHY2A] -= movementSpeed;
			else if(LinkMovement[LM_STICKY]>0)
				LinkMovement[LM_PUSHY2A] += movementSpeed;
		}	
	}
	LinkMovement[LM_MOVEBOOST] = 0; //Movement boost reset until the next frame to prevent forgetting to clear the boost
}

bool LinkMovement_CanWalk(int x, int y, int dir, int step, bool full_tile, bool noEdge) {
	//if(!noEdge)
	//	return CanWalk(x, y, dir, step, full_tile);
	
	int c=8;
	int xx = x+15;
	int yy = y+15;
	if(full_tile) c=0;
	if(dir==0) return ( PositionIsOk(x,y+c-step, 4) && PositionIsOk(x+8,y+c-step, 4) && PositionIsOk(xx,y+c-step, 4) );
	else if(dir==1) return ( PositionIsOk(x,yy+step, 4) && PositionIsOk(x+8,yy+step, 4) && PositionIsOk(xx,yy+step, 4) );
	else if(dir==2) return ( PositionIsOk(x-step,y+c, 4) && PositionIsOk(x-step,y+c+7, 4) && PositionIsOk(x-step,yy, 4) );
	else if(dir==3) return ( PositionIsOk(xx+step,y+c, 4) && PositionIsOk(xx+step,y+c+7, 4) && PositionIsOk(xx+step,yy, 4) );
	return false; //invalid direction
}

void LinkMovement_UpdatePush(int indexX, int indexY, bool noEdge){
	int Imprecision = 0;
	for(int i=0; i<MAX_PUSH&&LinkMovement[indexX]<=-1; i++){
		if(LinkMovement_CanWalk(Link->X, Link->Y, DIR_LEFT, 1, false, noEdge)){
			Link->X--;
			LinkMovement[indexX]++;
		}
		else if(Imprecision>0&&Abs(GridY(Link->Y+8)-Link->Y)<Imprecision&&LinkMovement_CanWalk(Link->X, GridY(Link->Y+8), DIR_LEFT, 1, false, noEdge)){
			Link->Y = GridY(Link->Y+8);
			Link->X--;
			LinkMovement[indexX]++;
		}
		else{
			LinkMovement[indexX] = 0;
		}
	}
	for(int i=0; i<MAX_PUSH&&LinkMovement[indexX]>=1; i++){
		if(LinkMovement_CanWalk(Link->X, Link->Y, DIR_RIGHT, 1, false, noEdge)){
			Link->X++;
			LinkMovement[indexX]--;
		}
		else if(Imprecision>0&&Abs(GridY(Link->Y+8)-Link->Y)<Imprecision&&LinkMovement_CanWalk(Link->X, GridY(Link->Y+8), DIR_RIGHT, 1, false, noEdge)){
			Link->Y = GridY(Link->Y+8);
			Link->X++;
			LinkMovement[indexX]--;
		}
		else{
			LinkMovement[indexX] = 0;
		}
	}
	for(int i=0; i<MAX_PUSH&&LinkMovement[indexY]<=-1; i++){
		if(LinkMovement_CanWalk(Link->X, Link->Y, DIR_UP, 1, false, noEdge)){
			Link->Y--;
			LinkMovement[indexY]++;
		}
		else if(Imprecision>0&&Abs(GridX(Link->X+8)-Link->X)<Imprecision&&LinkMovement_CanWalk(GridX(Link->X+8), Link->Y, DIR_UP, 1, false, noEdge)){
			Link->X = GridX(Link->X+8);
			Link->Y--;
			LinkMovement[indexY]++;
		}
		else{
			LinkMovement[indexY] = 0;
		}
	}
	for(int i=0; i<MAX_PUSH&&LinkMovement[indexY]>=1; i++){
		if(LinkMovement_CanWalk(Link->X, Link->Y, DIR_DOWN, 1, false, noEdge)){
			Link->Y++;
			LinkMovement[indexY]--;
		}
		else if(Imprecision>0&&Abs(GridX(Link->X+8)-Link->X)<Imprecision&&LinkMovement_CanWalk(GridX(Link->X+8), Link->Y, DIR_DOWN, 1, false, noEdge)){
			Link->X = GridX(Link->X+8);
			Link->Y++;
			LinkMovement[indexY]--;
		}
		else{
			LinkMovement[indexY] = 0;
		}
	}
}

void LinkMovement_Init(){
	LinkMovement[LM_PUSHX1A] = 0;
	LinkMovement[LM_PUSHY1A] = 0;
	LinkMovement[LM_PUSHX1B] = 0;
	LinkMovement[LM_PUSHY1B] = 0;
	LinkMovement[LM_PUSHX2A] = 0;
	LinkMovement[LM_PUSHY2A] = 0;
	LinkMovement[LM_PUSHX2B] = 0;
	LinkMovement[LM_PUSHY2B] = 0;
	LinkMovement[LM_STICKX] = 0;
	LinkMovement[LM_STICKY] = 0;
	LinkMovement[LM_MOVEBOOST] = 0;
}

void LinkMovement_Update1(){
	LinkMovement_UpdateInput();
	LinkMovement_SpeedChange();
	LinkMovement_UpdatePush(LM_PUSHX1A, LM_PUSHY1A, false);
	LinkMovement_UpdatePush(LM_PUSHX1B, LM_PUSHY1B, true);
}

void LinkMovement_Update2(){
	LinkMovement_UpdatePush(LM_PUSHX2A, LM_PUSHY2A, false);
	LinkMovement_UpdatePush(LM_PUSHX2B, LM_PUSHY2B, true);
}

void LinkMovement_Push(int pX, int pY){
	LinkMovement[LM_PUSHX1A] += pX;
	LinkMovement[LM_PUSHY1A] += pY;
}

void LinkMovement_PushNoEdge(int pX, int pY){
	LinkMovement[LM_PUSHX1B] += pX;
	LinkMovement[LM_PUSHY1B] += pY;
}

void LinkMovement_Push2(int pX, int pY){
	LinkMovement[LM_PUSHX2A] += pX;
	LinkMovement[LM_PUSHY2A] += pY;
}

void LinkMovement_Push2NoEdge(int pX, int pY){
	LinkMovement[LM_PUSHX2B] += pX;
	LinkMovement[LM_PUSHY2B] += pY;
}

void LinkMovement_AddLinkSpeedBoost(float i){
	LinkMovement[LM_MOVEBOOST] += i;
}

void LinkMovement_SetLinkSpeedBoost(float i){
	LinkMovement[LM_MOVEBOOST] = i;
}

int LinkMovement_StickX(){
	return LinkMovement[LM_STICKX];
}

int LinkMovement_StickY(){
	return LinkMovement[LM_STICKY];
}

const int HEALTHBAR_DRAW_DAMAGE = 0; //Set to 1 if you want to draw damage numbers
const int HEALTHBAR_DAMAGE_COUNT = 96; //How many frames damage numbers last for

const int HEALTHBAR_DRAW_CHIP = 1; //Set to 1 if you want to draw the health draining away when hit
const int HEALTHBAR_CHIP_RATE = 16; //How fast the damage drains from the bar after a hit

const int HEALTHBAR_ENDDELAY = 0; //How many frames the health bar lasts for after all enemies are dead when disappearOnDeath is set

//Health bar dimensions
const int HEALTHBAR_X = 8;
const int HEALTHBAR_Y = 156;
const int HEALTHBAR_WIDTH = 240;
const int HEALTHBAR_HEIGHT = 8;

//Offsets for the font of the NPC's name
const int HEALTHBAR_FONT_X_OFFSET = 0;
const int HEALTHBAR_FONT_Y_OFFSET = -9;

//Y offset for duplicate health bars
const int HEALTHBAR_DUPE_OFFSET = -12;

const int FONT_HEALTHBAR_TITLE = 0; //Font for the title and damage numbers. See FONT_ in std_constants.zh

const int C_HEALTHBAR_FONT = 0x01; //Color of the health bar's font
const int C_HEALTHBAR_FONTBG = 0x0F; //Color of the health bar's font background

const int C_HEALTHBAR_OUTLINE = 0x00; //Color of the health bar's outline
const int C_HEALTHBAR_BAR = 0x05; //Color of the health bar
const int C_HEALTHBAR_DRAIN = 0x06; //Color of the section of the health bar being removed
const int C_HEALTHBAR_BG = 0x0F; //Color of the health bar's background

ffc script HealthBar_Single{
	void run(int npcid, int str, int npcNumber, int disappearOnDeath){
		disappearOnDeath = 1; //let's just do this so its consistent in this quest :)
		Waitframes(4);
		npc n = HealthBar_GetNPC(npcid, npcNumber);
		if(!n->isValid()) //If an enemy isn't found, quit out
			Quit();
		
		int hp = n->HP;
		int maxHP = n->HP;
		int lastHP = n->HP;
		int drainHP = n->HP;
		int lastDrainHP = n->HP;
		int damage;
		int damageCounter;
		
		//If there's more than one enemy with health bars on the screen, offset them by the 
		int ffcCount;
		for(int i=1; i<=32; i++){
			ffc f = Screen->LoadFFC(i);
			if(f->Script==this->Script){
				if(f==this)
					break;
				else
					ffcCount++;
			}
		}
		
		this->InitD[0] = 0; //Mark the FFC as "Alive"
		
		//Begin main loop that runs until HP drains to 0
		while(drainHP>0){
			if(n->isValid()) //If the enemy isn't there, assume it's dead
				hp = Max(GetEnemyProperty(n, ENPROP_HP), 0);
			else
				hp = 0;
			
			if(damageCounter>0)
				damageCounter--;
			
			//Keep track of when the enemy takes damage
			if(hp!=lastHP){
				if(hp<lastHP){
					if(damageCounter>0)
						damage += lastHP-hp;
					else
						damage = lastHP-hp;
					damageCounter = HEALTHBAR_DAMAGE_COUNT;
				}
				lastDrainHP = lastHP;
				lastHP = hp;
			}
			
			//Decrease drainHP towards the current HP
			if(drainHP!=hp){
				if(drainHP>hp){
					drainHP = Max(drainHP-(Abs(lastDrainHP-hp)/HEALTHBAR_CHIP_RATE), hp);
				}
				else
					drainHP = hp;
			}
			
			HealthBar_Draw(0, hp, maxHP, drainHP, damage, damageCounter, HEALTHBAR_DUPE_OFFSET*ffcCount);
			Waitframe();
		}
		
		this->InitD[0] = 1; //Mark the FFC as "Dead"
		
		while(true){ 
			if(damageCounter>0)
				damageCounter--;
			HealthBar_Draw(0, 0, maxHP, 0, damage, damageCounter, HEALTHBAR_DUPE_OFFSET*ffcCount);
			
			//If marked to disappear, wait until all health bars are "Dead" before removing
			if(disappearOnDeath){
				if(HealthBar_CheckDone(this)){
					break;
				}
			}
			Waitframe();
		}
		
		//Wait extra frames before quitting out so it doesn't look as abrupt
		for(int i=0; i<HEALTHBAR_ENDDELAY; i++){
			if(damageCounter>0)
				damageCounter--;
			HealthBar_Draw(0, 0, maxHP, 0, damage, damageCounter, HEALTHBAR_DUPE_OFFSET*ffcCount);
			Waitframe();
		}
	}
	//Returns true if all FFCs with this script are "Dead"
	bool HealthBar_CheckDone(ffc this){
		for(int i=1; i<=32; i++){
			ffc f = Screen->LoadFFC(i);
			if(f->Script==this->Script){
				if(f->InitD[0]==0)
					return false;
			}
		}
		return true;
	}
	//Returns the nth enemy with a certain ID on the screen
	npc HealthBar_GetNPC(int id, int extra){
		for(int i=Screen->NumNPCs(); i>=1; i--){
			npc n = Screen->LoadNPC(i);
			if(n->ID==id){
				if(extra<=1)
					return n;
				else
					extra--;
			}
		}
	}
	//Draws the entire health bar
	void HealthBar_Draw(int str, int HP, int maxHP, int drainHP, int damage, int damageCounter, int offset){
		int x1 = HEALTHBAR_X;
		int y1 = HEALTHBAR_Y+offset;
		int x2 = HEALTHBAR_X+HEALTHBAR_WIDTH-1;
		int y2 = HEALTHBAR_Y+HEALTHBAR_HEIGHT-1+offset;
		int hpLength = (x2-x1-2)*(HP/maxHP);
		int drainLength = (x2-x1-2)*(drainHP/maxHP);
		
		//Draws the main body of the health bar
		Screen->Rectangle(6, x1, y1, x2, y2, C_HEALTHBAR_BG, 1, 0, 0, 0, true, 128);
		if(drainHP>0&&HEALTHBAR_DRAW_CHIP)
			Screen->Rectangle(6, x1+1, y1+1, x1+1+Clamp(drainLength, 0, x2-x1-2), y2-1, C_HEALTHBAR_DRAIN, 1, 0, 0, 0, true, 128);
		if(HP>0)
			Screen->Rectangle(6, x1+1, y1+1, x1+1+Clamp(hpLength, 0, x2-x1-2), y2-1, C_HEALTHBAR_BAR, 1, 0, 0, 0, true, 128);
		//Screen->Rectangle(6, x1, y1, x2, y2, C_HEALTHBAR_OUTLINE, 1, 0, 0, 0, false, 128);
	}
}

////////////////////////
//    Ice Physics     //
//     ForceSlide     //
//       2.53         //
//       V1.1         //
////////////////////////
//Dependencies: "LinkMovement.zh"

int icePhysicsData[7];

const int ICE_MOVESPEED = 0;
const int ICE_COMBO_TYPE = 1;
const int ICE_ITEMCLASS = 2;
const int ICE_COMBOGRIDLOCK = 3; //Value of 0 is "no lock", 1 is "half-grid", 2 is "whole-grid"
const int ICE_SLIDEDIR = 4;
const int ICE_FULLTILE_LINK = 5;

const int GRID_NONE = 0;
const int GRID_HALF = 1;
const int GRID_FULL = 2;

void doIcePhysics()
{
	if(Link->Action == LA_SCROLLING) return;
	if(icePhysicsData[ICE_ITEMCLASS] > 0)
	{
		int tractbootsID = GetHighestLevelItemOwned(icePhysicsData[ICE_ITEMCLASS]);
		if(tractbootsID>=0)
		{
			return;
		}
	}
	for(int q = Screen->NumLWeapons(); q >= MIN_LWEAPON; --q)
	{
		lweapon l = Screen->LoadLWeapon(q);
		if(l->ID == LW_HOOKSHOT)
			return;
	}
	bool onIce = false;
	for(int dir = DIR_UP; !onIce && (dir < 4); ++dir)
	{
		int gridlockedX = Link->X;
		int gridlockedY = Link->Y;
		//
		if(icePhysicsData[ICE_SLIDEDIR]==-1)
		{
			if(dir == DIR_UP && !Link->InputUp) continue;
			else if(dir == DIR_DOWN && !Link->InputDown) continue;
			else if(dir == DIR_LEFT && !Link->InputLeft) continue;
			else if(dir == DIR_RIGHT && !Link->InputRight) continue;
			if(icePhysicsData[ICE_COMBOGRIDLOCK] == 1)
			{
				if(dir==DIR_UP || dir==DIR_DOWN) gridlockedX = ((Link->X+4) >> 3) << 3;
				else if(dir==DIR_RIGHT || dir==DIR_LEFT) gridlockedY = ((Link->Y+4) >> 3) << 3;
			}
			else if(icePhysicsData[ICE_COMBOGRIDLOCK] == 2)
			{
				if(dir==DIR_UP || dir==DIR_DOWN) gridlockedX = ((Link->X+8) >> 4) << 4;
				else if(dir==DIR_RIGHT || dir==DIR_LEFT) gridlockedY = ((Link->Y+8) >> 4) << 4;
			}
		}
		for(int layer = 0; layer < 3; ++layer)
		{
			if(layer > 0) if(Screen->LayerMap(layer) == -1) continue; //Skip nonexistant layers
			if(icePhysicsData[ICE_FULLTILE_LINK])
			{
				if(GetLayerComboT(layer, ComboAt(gridlockedX, gridlockedY)) == icePhysicsData[ICE_COMBO_TYPE])
				{
					onIce = true;
					break;
				}
				if(GetLayerComboT(layer, ComboAt(gridlockedX+15, gridlockedY)) == icePhysicsData[ICE_COMBO_TYPE])
				{
					onIce = true;
					break;
				}
			}
			if(GetLayerComboT(layer, ComboAt(gridlockedX, gridlockedY+8)) == icePhysicsData[ICE_COMBO_TYPE])
			{
				onIce = true;
				break;
			}
			if(GetLayerComboT(layer, ComboAt(gridlockedX+15, gridlockedY+8)) == icePhysicsData[ICE_COMBO_TYPE])
			{
				onIce = true;
				break;
			}
			if(GetLayerComboT(layer, ComboAt(gridlockedX, gridlockedY+15)) == icePhysicsData[ICE_COMBO_TYPE])
			{
				onIce = true;
				break;
			}
			if(GetLayerComboT(layer, ComboAt(gridlockedX+15, gridlockedY+15)) == icePhysicsData[ICE_COMBO_TYPE])
			{
				onIce = true;
				break;
			}
		}
		if(icePhysicsData[ICE_SLIDEDIR]==-1 && onIce)
		{
			icePhysicsData[ICE_SLIDEDIR] = dir;
			Link->X = gridlockedX;
			Link->Y = gridlockedY;
			Link->Dir = dir;
		}
	}

	if(!onIce)
	{
		icePhysicsData[ICE_SLIDEDIR] = -1;
		return;
	}
	int spd = icePhysicsData[ICE_MOVESPEED];
	int dir = icePhysicsData[ICE_SLIDEDIR];
	if(!CanWalk(Link->X, Link->Y, icePhysicsData[ICE_SLIDEDIR], spd, icePhysicsData[ICE_FULLTILE_LINK]))
	{
		do
		{
			int screen = Game->GetCurScreen();
			if(dir==DIR_RIGHT && Link->X+spd>=240 && ((screen&0x0F) != 0x0F)) break;
			if(dir==DIR_LEFT && Link->X-spd<=0 && ((screen&0x0F) != 0x00)) break;
			if(dir==DIR_UP && Link->Y-spd<=0 && ((screen-(screen&0x0F)) != 0x00)) break;
			if(dir==DIR_DOWN && Link->Y+spd>=160 && ((screen-(screen&0x0F)) != 0x70)) break;
			icePhysicsData[ICE_SLIDEDIR] = -1;
			return;
		} while(false);
	}
	//
	if(dir==DIR_RIGHT) LinkMovement_PushNoEdge(spd, 0);
	else if(dir==DIR_LEFT) LinkMovement_PushNoEdge(-spd, 0);
	else if(dir==DIR_UP) LinkMovement_PushNoEdge(0, -spd);
	else if(dir==DIR_DOWN) LinkMovement_PushNoEdge(0, spd);
}

//This function sets all the variables at once
//You can set them individually using the 'ICE_' constants to access the 'icePhysicsData' array.
//spd: Pixels per frame for sliding
//combotype: The combo type representing ice
//itemClass: The item class for Traction Boots. These negate ice completely.
//combogrid: If 0, no grid-locking. If 1, half-grid locking. If 2, whole-grid locking. (any other value = no grid-locking)
//		NOTE: I highly recommend at least half-grid lock if diagonal movement is enabled.
//biglink: If the full 16x16 hitbox should be used for ice, instead of just the bottom 8 pixels
void setIcePhysics(int spd, int combotype, int itemClass, int combogrid)
{
	setIcePhysics(spd, combotype, itemClass, combogrid, false);
}
void setIcePhysics(int spd, int combotype, int itemClass, int combogrid, bool biglink)
{
	icePhysicsData[ICE_MOVESPEED] = spd;
	icePhysicsData[ICE_COMBO_TYPE] = combotype;
	icePhysicsData[ICE_ITEMCLASS] = itemClass;
	icePhysicsData[ICE_COMBOGRIDLOCK] = combogrid;
	icePhysicsData[ICE_FULLTILE_LINK] = Cond(biglink, 1, 0);
}

bool isSliding()
{
	return icePhysicsData[ICE_SLIDEDIR] > -1;
}